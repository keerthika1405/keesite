<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaApi</title>
    <link rel="stylesheet" href="javaapi.css">
    <style>
      

:root{
  --body-color: rgb(253, 253, 253);
  --text-color:rgb(244, 245, 211);
  --list-color: white;
  --list-text-color:black;
  --hover:grey;
  --tab-content:white;
  --containerprofile:white;
}


body.dark{
  --hover:grey;
  --list-text-color:white;
 --list-color: rgb(48, 46, 46);
  --body-color:rgb(0, 0, 0,0.7);
  --text-color:rgb(255, 255, 255);
  --gry-color:rgba(0, 0, 0);
  --tab-content: rgb(48, 46, 46);
  --containerprofile:rgb(48, 46, 46);
 

}
body {
	/* background: var(--body-color); */
	height: 100%;
}


.nav-bar .darkLight-searchBox{
  display: flex;
  align-items: center;
}
.darkLight-searchBox .dark-light
{
  position: fixed;
  height: 40px;
  width: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 5px;
}
.dark-light i{
  margin-left: 2200px;
  position: absolute;
  color: var(--text-color);
  font-size: 22px;
  cursor: pointer;
  transition: all 0.3s ease;
margin-top: -50px;
}
.dark-light i.sun{
  opacity: 0;
  pointer-events: none;
}
.dark-light.active i.sun{
  opacity: 1;
  pointer-events: auto;
}
.dark-light.active i.moon{
  opacity: 0;
  pointer-events: none;
}
.dark-light i.moon:hover{
  color: rgb(0, 0, 0);
}
.dark-light i.sun:hover{
  color: yellow;

} 
    </style>
     <!-- <style>
     
      
        .sidebar {
          height: 100%;
          width: 250px;
          position: fixed;
          z-index: 1;
          top: 30;
          left: 0;
          background-color: #111;
          overflow-x: hidden;
          transition: 0.5s;
          padding-top: 60px;
        }
        
        .sidebar a {
          padding: 8px 8px 8px 32px;
          text-decoration: none;
          font-size: 25px;
          color: #818181;
          display: block;
          transition: 0.3s;
        }
        
        .sidebar a:hover {
          color: #f1f1f1;
        }
        
        .sidebar .closebtn {
          position: absolute;
          top: 0;
          right: 25px;
          font-size: 36px;
          margin-left: 50px;
        }
        
        .openbtn {
          font-size: 20px;
          cursor: pointer;
          background-color: #111;
          color: white;
          padding: 10px 15px;
          border: none;
        }
        
        .openbtn:hover {
          background-color: #444;
        }
        
        #main {
       
          position: fixed;
          margin-top:50px;
          transition: margin-left .5s;
          padding: 6px;
        }
        
        /* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */
        @media screen and (max-height: 450px) {
          .sidebar {padding-top: 15px;}
          .sidebar a {font-size: 18px;}
        }
        </style> -->
      <style>
  
        .hamburger-menu{
         padding-right: 1.5rem;
         cursor: pointer;
       }
       .hamburger-menu .line{
       display: block; 
       width:25px;
       height: 20px; 
       margin-top: -25px;
       margin-left: 60px;
       color: rgb(80, 80, 80);
       cursor: pointer;
       }
       .nav-menu{
         position: fixed;
         width: 34%;
         top: 0;
         left: 50px;
         background-color: rgb(255, 255, 255);
         font-weight: 600;
       
       }
       .nav-menu a{
        margin-top: 40px;
         font-size: 15px;
         color: rgb(255, 255, 255);
         text-decoration: none;
         display: block;
         text-align: center;
         padding: 20px 0;
       }
  
       .hide{
         display: none;
       }
  
           /* for Desktop view */
           @media screen and (min-width:600px){
             .navbar{
               justify-content: space-around;
             }
             .nav-menu{
               width: 60%;
               display: block;
               position: static;
               margin-top: -25px;
               margin-left: 70px;
              
               background: none;
             }
             .nav-menu a{
               display: inline-block;
             padding: 0px 10px;
             cursor: pointer;
               /* padding: -px 20px; */
             
             }
         
             .hamburger-menu{
               display: none;
             }
           }
           
    </style>

     <style type="text/css">
  
      #stage{
      position: fixed;
      margin-left: 10px;
      margin-top: 10px;
      cursor: pointer;
      z-index: 200;
  
  
      }
          @font-face {
           font-family: 'FontAwesome';
           src: url('fontawesome/fonts/fontawesome-webfont.ttf');
           font-weight: normal;
           font-style: normal;
       
          }
          #stage{
            font-family:FontAwesome;
          }

          </style> 
 <style>
            #bg{
  position: fixed;
width: 100%;
height:180px; 
/* border: 1px solid black; */

}

.bg h1{
color: rgb(251, 251, 251);
 position: absolute;
font-size: 30px;
top:500px;
z-index: 100;
margin-left: 100px;

    }
    .bg img{
      margin-top: -50px;
      z-index: -1;
    } 
          </style> 

<link href='https://unpkg.com/boxicons@2.1.1/css/boxicons.min.css' rel='stylesheet'>
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@10.1.0/swiper-bundle.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> -->
    <link href='https://unpkg.com/boxicons@2.1.1/css/boxicons.min.css' rel='stylesheet'>
    <script src="https://code.jquery.com/jquery-3.4.1.js"></script>


    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"> -->
  
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>


    
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<bodyid="mode">

  

        <!-- <div class="loader">
          <h1>keesite</h1>
        </div> -->
        
        
        
            <!-- <div class="sideMenu" id="side-menu">
                <a class="closebtn" href="javascript:void(0)" onclick="closeNav()">x</a> -->
        
              <!-- <div class="sidebar">
                
                <ul>
                  <li><i class="bx bx-home"></i><a href="chrome.html">home</a></li>
                  <li><i class="bx bx-home"></i><a href="chrome.html">course </a></li>
                  <li><i class="bx bx-home"></i><a href="chrome.html">gallery</a></li>
                  <li><i class="bx bx-github"></i><a href="chrome.html">github</a></li>
          
                </ul>
            
        </div>
              </div> -->
              <div id="stage">
                <canvas id="Canvas" width="50" height="45"></canvas>
             </div>
        
        
              <nav class="navbar" id="navbar">
                <div class="content-area">
                   <!-- <button  class="content-area1" onclick="openNav()" style="font-size:20px;cursor:pointer"><i class="fa fa-navicon" style="color: black;"></i></button> -->
              
               <!-- <div class="dropdown-content" id="myDropdown">
                 <a href="#">Link 1</a>
                 <a href="#">Link 2</a>
                 <a href="#">Link 3 &emsp;&emsp;&emsp;&emsp; <button class="content-area2" onclick="openNavy()" >&#62;</button>
                 <div class="dropdown-content1" id="myDropdown1" >
                   <a href="#">python</a>
                   <a href="#">java</a> </div>
                 </a>
                 <a href="#">Link 2</a>
               </div> -->
            
               <div class="hamburger-menu">
                 <span class="line">Menu</span><!--â˜°-->
               </div> 
             
               <div class="nav-menu hide">
                <a onclick="view()" target="_top" > <i class='bx bx-star'  style="font-size: 20px;"></i>Explore</a>
             <a href="https://github.com/keerthika1405" target="_top" >   <i class='bx bxl-github ' name='github' type="logo"  style="font-size: 20px;"></i> Github</a>
             <a href="https://github.com/keerthika1405/keesite/discussions" target="_top" ><i class='bx bx-comment '  style="font-size: 20px;"></i>Community</a>
          
        
             <!-- <a href="#">About</a> -->
             </div>
            </div>
            
            
            <div class="search-box">
            <div class="row">
              <form id="search"  method="post" >
                 <input type="text" id="input-box" placeholder="search here" autocomplete="off">
                 <button type="submit"><i class='bx bx-search bx-sm'  id="input-box"></i></button>
            </div>
        
        
            </form>
                 <form id="css" action="explore.html" methode="get"></form>
                 <form id="HTML" action="chrome.html" methode="get"></form>
                 <form id="javascript" action="about.html" methode="get"></form>
                   
            <div class="result-box">     </div>      
            </div>
            
        

        
            <!-- <div class="containerprofile" id="profileform">
             
              <form  onsubmit="; reset(); " >
               
        
                <h3 >profile</h3>
               <div class="profile_img">
                <img src="profile.png" alt="" id="profile_img">
                <label for="image-preview">upload</label>
                <input type="file" accept="image/jpeg, image/png, image/jpg" id="image-preview" name="image" class="file-input"  >
               </div>
        
               
                <h1 ><span style="color: rgb(123, 100, 100);"><i class="fa fa-user-circle"></i></span>    <script> document.write(localStorage.getItem("name"));</script></button></h1>
                <h1><span style="color: rgb(123, 100, 100);"><i class="fa fa-envelope" ></i>   </span><script> document.write(localStorage.getItem("email"));</script></h1>
               <h1><span style="color: rgb(123, 100, 100);"><i class="fa fa-home" ></i></span> <a href="about.html">Home</a></h1>
               <h1><span style="color: rgb(123, 100, 100);"><i class="fa fa-bookmark"></i></span>  <a href="#features">Course</a></h1>
               <h1><span onclick="logout()" >Logout</span></h1>
               <button type="button" class="btn cancel" onclick="logincloseForm()"> close</button>
            
              </form>
             
            </div> -->
        
           
        
        
           
           
            <div class="darkLight-searchBox">
              <div class="dark-light">
                  <i class='bx bx-moon moon'></i>
                  <i class='bx bx-sun sun'></i>
              </div>
              </div>
        
            <div class="webname">
            <h2>keesite</h2>
            </div>
            
            </nav>
   
            <button class="open-button" onclick="openForm()"><i class='bx bx-question-mark'></i></button>
            <div class="container" id="myForm">
            <form  onsubmit="sendEmail(); reset(); " >
            <h3>Let's Solve</h3>
            <input type="text" id="name" placeholder="Your Name" autocomplete="off"  required>
            <input type="email" id="email" placeholder="Your Email Id" autocomplete="off" required>
            <input type="text" id="phone" placeholder="phone no" autocomplete="off" >
            <textarea  id="message" name="" id="message" cols="30" rows="5" placeholder="Write Your Query Here We Will Reach You Soon ?"  required></textarea>
            <button type="submit">send</button>
            <button type="button" class="btn cancel" onclick="closeForm()">Close</button>
            </form>
            </div> 


            <div   class="bg" id="bgcontent">
                <img  id="bg" class="image-container" src="bgimg18.avif" height="100px" width=" 100%" alt="">
                <!-- <h1>welcome  <script> document.write(localStorage.getItem("name").toUpperCase());</script> </h1> -->
            </div>



            <div class="menu__wrapper"  id="wrapper">
    
              <div class="menu__bar">
            
                <nav class="navi">
                   
                  <div class="navigation hide">
                  <ul>
                    <li>
                        <button type="button" class="btn cancel" onclick="nonview()">X</button>
                    </li>
                      <li>
                        
                          <button>
                              DSA
                            
                            
                                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                                  <path
                                      d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                                  </path>
                              </svg>
                          </button>
            
            
            
            
                          <div class="dropdown__wrapper">
                              <div class="dropdown">
                                  <ul class="list-items-with-description">
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg"
                                        class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                        viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                        stroke-linecap="round" stroke-linejoin="round">
                                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                        <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                        <path d="M15 12v-3" />
                                    </svg>
                                         
            
                                          <div class="item-title">
                                              <h3>DSA</h3>
                                              <p>Tree Roadmap of dsa</p>
                                          </div>
                                      </li>
                                      <li>
                                       <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                              stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                              stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                          </svg>
                                         
                                          <div class="item-title">
                                              <h3>Infrastructure</h3>
                                              <p>Always fast always online</p>
                                          </div>
                                      </li>
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                        viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                        stroke-linecap="round" stroke-linejoin="round">
                                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                        <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                        <path d="M4 12l8 4l8 -4" />
                                        <path d="M4 16l8 4l8 -4" />
                                    </svg>
                                          <div class="item-title">
                                              <h3>Next js</h3>
                                              <p>The native Next.js platform</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                              <path d="M3.6 9h16.8" />
                                              <path d="M3.6 15h16.8" />
                                              <path d="M11.5 3a17 17 0 0 0 0 18" />
                                              <path d="M12.5 3a17 17 0 0 1 0 18" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Edge Functions</h3>
                                              <p>Dynamic pages, static speed</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Analytics</h3>
                                              <p>Real-time insights, peak performance</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                              <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                              <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Storage</h3>
                                              <p>Serverless storage for frontend</p>
                                          </div>
                                      </li>
                                  </ul>
                              </div>
                          </div>
                      </li>
            
            
            
            
            
                      <li>
                         <button>
                              JAVA
                              <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                                  <path
                                      d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                                  </path>
                              </svg>
                          </button>
            
            
            
            
                          <div class="dropdown__wrapper">
                              <div class="dropdown">
                                  <ul class="list-items-with-description">
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                        viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                        stroke-linecap="round" stroke-linejoin="round">
                                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                        <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                        <path d="M4 12l8 4l8 -4" />
                                        <path d="M4 16l8 4l8 -4" />
                                    </svg>
                                          
                                          <div class="item-title">
                                              <h3>Previews</h3>
                                              <p>Zero config, more innovation</p>
                                          </div>
                                      </li>
                                      <li>
                                        <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                        stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                        stroke-linejoin="round">
                                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                        <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                    </svg>
                                          <div class="item-title">
                                              <h3>Infrastructure</h3>
                                              <p>Always fast always online</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg"
                                              class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                              <path d="M15 12v-3" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Next js</h3>
                                              <p>The native Next.js platform</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                              <path d="M3.6 9h16.8" />
                                              <path d="M3.6 15h16.8" />
                                              <path d="M11.5 3a17 17 0 0 0 0 18" />
                                              <path d="M12.5 3a17 17 0 0 1 0 18" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Edge Functions</h3>
                                              <p>Dynamic pages, static speed</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Analytics</h3>
                                              <p>Real-time insights, peak performance</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                              <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                              <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Storage</h3>
                                              <p>Serverless storage for frontend</p>
                                          </div>
                                      </li>
                                  </ul>
                              </div>
                          </div>
                          <!-- <a href="#docs" title="Docs">
                              Docs
                          </a> -->
                      </li>
                      <li>
                        <button>
                          frontend
                          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                              <path
                                  d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                              </path>
                          </svg>
                      </button>
            
            
            
            
                      <div class="dropdown__wrapper">
                          <div class="dropdown">
                              <ul class="list-items-with-description">
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                    <path d="M4 12l8 4l8 -4" />
                                    <path d="M4 16l8 4l8 -4" />
                                </svg>
                                      
                                      <div class="item-title">
                                          <h3>Previews</h3>
                                          <p>Zero config, more innovation</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                    stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                </svg>
                                      <div class="item-title">
                                          <h3>Infrastructure</h3>
                                          <p>Always fast always online</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg"
                                          class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                          <path d="M15 12v-3" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Next js</h3>
                                          <p>The native Next.js platform</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                          <path d="M3.6 9h16.8" />
                                          <path d="M3.6 15h16.8" />
                                          <path d="M11.5 3a17 17 0 0 0 0 18" />
                                          <path d="M12.5 3a17 17 0 0 1 0 18" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Edge Functions</h3>
                                          <p>Dynamic pages, static speed</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Analytics</h3>
                                          <p>Real-time insights, peak performance</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                          <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                          <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Storage</h3>
                                          <p>Serverless storage for 
                                            </p>
                                          </div>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                           </li> 
                           <li>
            
                              <button>
                              Database
                              <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                                  <path
                                      d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                                  </path>
                              </svg>
                          </button>
            
            
                        
                         
            
                          <div class="dropdown__wrapper">
                              <div class="dropdown">
                                  <ul class="list-items-with-description">
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                        viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                        stroke-linecap="round" stroke-linejoin="round">
                                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                        <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                        <path d="M4 12l8 4l8 -4" />
                                        <path d="M4 16l8 4l8 -4" />
                                    </svg>
                                          
                                          <div class="item-title">
                                              <h3>Previews</h3>
                                              <p>Zero config, more innovation</p>
                                          </div>
                                      </li>
                                      <li>
                                        <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                        stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                        stroke-linejoin="round">
                                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                        <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                    </svg>
                                          <div class="item-title">
                                              <h3>Infrastructure</h3>
                                              <p>Always fast always online</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg"
                                              class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                              <path d="M15 12v-3" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Next js</h3>
                                              <p>The native Next.js platform</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                              <path d="M3.6 9h16.8" />
                                              <path d="M3.6 15h16.8" />
                                              <path d="M11.5 3a17 17 0 0 0 0 18" />
                                              <path d="M12.5 3a17 17 0 0 1 0 18" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Edge Functions</h3>
                                              <p>Dynamic pages, static speed</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Analytics</h3>
                                              <p>Real-time insights, peak performance</p>
                                          </div>
                                      </li>
                                      <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                              <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                              <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Storage</h3>
                                              <p>Serverless storage for frontend</p>
                                          </div>
                                      </li>
                                  </ul>
                              </div>
                          </div>
                       </li>
                          <!-- <a href="#templates" title="Templates">
                              font-end
                          </a> -->
                     
            
                      <li>
                       
                        <button>
                          SDLC/Networking
                          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                              <path
                                  d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                              </path>
                          </svg>
                      </button>
            
            
            
            
                      <div class="dropdown__wrapper">
                          <div class="dropdown">
                              <ul class="list-items-with-description">
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                    <path d="M4 12l8 4l8 -4" />
                                    <path d="M4 16l8 4l8 -4" />
                                </svg>
                                      
                                      <div class="item-title">
                                          <h3>Previews</h3>
                                          <p>Zero config, more innovation</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                    stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                </svg>
                                      <div class="item-title">
                                          <h3>Infrastructure</h3>
                                          <p>Always fast always online</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg"
                                          class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                          <path d="M15 12v-3" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Next js</h3>
                                          <p>The native Next.js platform</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                          <path d="M3.6 9h16.8" />
                                          <path d="M3.6 15h16.8" />
                                          <path d="M11.5 3a17 17 0 0 0 0 18" />
                                          <path d="M12.5 3a17 17 0 0 1 0 18" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Edge Functions</h3>
                                          <p>Dynamic pages, static speed</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Analytics</h3>
                                          <p>Real-time insights, peak performance</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                          <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                          <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Storage</h3>
                                          <p>Serverless storage for frontend</p>
                                      </div>
                                  </li>
                              </ul>
                          </div>
                      </div>
            
                      </li>
                      <li>
                           
                        <button>
                          Git/Github
                          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                              <path
                                  d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                              </path>
                          </svg>
                      </button>
            
            
            
            
                      <div class="dropdown__wrapper">
                          <div class="dropdown">
                              <ul class="list-items-with-description">
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                    <path d="M4 12l8 4l8 -4" />
                                    <path d="M4 16l8 4l8 -4" />
                                </svg>
                                      
                                      <div class="item-title">
                                          <h3>Previews</h3>
                                          <p>Zero config, more innovation</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                    stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                </svg>
                                      <div class="item-title">
                                          <h3>Infrastructure</h3>
                                          <p>Always fast always online</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg"
                                          class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                          <path d="M15 12v-3" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Next js</h3>
                                          <p>The native Next.js platform</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                          <path d="M3.6 9h16.8" />
                                          <path d="M3.6 15h16.8" />
                                          <path d="M11.5 3a17 17 0 0 0 0 18" />
                                          <path d="M12.5 3a17 17 0 0 1 0 18" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Edge Functions</h3>
                                          <p>Dynamic pages, static speed</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Analytics</h3>
                                          <p>Real-time insights, peak performance</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                          <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                          <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Storage</h3>
                                          <p>Serverless storage for frontend</p>
                                      </div>
                                  </li>
                              </ul>
                          </div>
                      </div>
            
                      </li>
                      <!-- <li>
                        <button>
                         Gallery
                          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                              <path
                                  d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                              </path>
                          </svg>
                      </button>
            
            
            
            
                      <div class="dropdown__wrapper">
                          <div class="dropdown">
                              <ul class="list-items-with-description">
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                    <path d="M4 12l8 4l8 -4" />
                                    <path d="M4 16l8 4l8 -4" />
                                </svg>
                                      
                                      <div class="item-title">
                                          <h3>Previews</h3>
                                          <p>Zero config, more innovation</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                    stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                </svg>
                                      <div class="item-title">
                                          <h3>Infrastructure</h3>
                                          <p>Always fast always online</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg"
                                          class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                          <path d="M15 12v-3" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Next js</h3>
                                          <p>The native Next.js platform</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                          <path d="M3.6 9h16.8" />
                                          <path d="M3.6 15h16.8" />
                                          <path d="M11.5 3a17 17 0 0 0 0 18" />
                                          <path d="M12.5 3a17 17 0 0 1 0 18" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Edge Functions</h3>
                                          <p>Dynamic pages, static speed</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Analytics</h3>
                                          <p>Real-time insights, peak performance</p>
                                      </div>
                                  </li>
                                  <li>
                                      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                          <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                          <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                      </svg>
                                      <div class="item-title">
                                          <h3>Storage</h3>
                                          <p>Serverless storage for frontend</p>
                                      </div>
                                  </li>
                              </ul>
                          </div>
                      </div>
                      </li> -->
                      <!-- <li>
                      <a href="#pricing" title="Pricing">
                        Pricing
                      </a>
                      </li>
                      <li>
                        <a href="#pricing" title="Pricing">
                          Pricing
                        </a>
                      </li> -->
                  </ul>
                </div>
            
              </nav>
            </div>
            </div>
            


            <div class="htmlsidebar1">

              <h1><a href="#api"> JAVA API</a></h1>
             <h1><a href="#io">Input/Output Operations</a></h1>
             <h1><a href="#network">Networking</a></h1>
             <h1><a href="#Concurrency"> Multithreading and Concurrency</a></h1>
             <h1><a href="#gui">GUI Development</a></h1>
             <h1><a href="#sql">Database Connectivity</a></h1>
             <h1><a href="#security">Security</a> </h1>
             <h1><a href="#ut">Utilities and Tools</a> </h1>
             <h1><a href="#xml">XML and JSON Processing</a> </h1>
             <h1><a href="#webS">Web Services</a> </h1>
             <h1><a href="#il">Internationalization and Localization</a> </h1>
             <h1><a href="#rlf">Reflection</a> </h1>
             <h1><a href="#jmx">Java Management Extensions (JMX) </a></h1>
            
        </div>
        

        <div class="Topic" id="api"> 
          <br><br>
          <h1>JAVA APIs</h1> </div>
        <br><br><br><br>
        
        
                  
        <div class="sort" id="section1">
          
          <h1>Data Structure and Collection</h1>
          <h1>java.util</h1>
          <pre>
            
        
        Classes:
        Collections: Provides utility methods for working with collections, like sorting and searching.
        ArrayList: Implements a resizable array.
        LinkedList: Implements a doubly-linked list.
        HashMap: Implements a hash table for key-value pairs.
        HashSet: Implements a set using a hash table.
        Hashtable: An obsolete class representing a hash table (use HashMap instead).
        LinkedHashMap: Extends HashMap to maintain the order of insertion.
        LinkedHashSet: Extends HashSet to maintain the order of insertion.
        PriorityQueue: Implements a priority queue using a heap.
        Properties: Represents a persistent set of properties (key-value pairs).
        Stack: Represents a last-in, first-out stack of objects.
        TreeMap: Implements a map using a red-black tree.
        TreeSet: Implements a set using a red-black tree.
        Vector: An obsolete class representing a growable array of objects (use ArrayList instead).
        
        Interfaces:
        Collection: The root interface for all collection classes.
        List: Extends Collection to represent an ordered collection (allows duplicate elements).
        Set: Extends Collection to represent a collection with no duplicate elements.
        Map: Represents a collection of key-value pairs.
        Queue: Represents a collection used to hold multiple elements before processing.
        Deque: Extends Queue to represent a double-ended queue.
        Iterator: Allows iterating over elements in a collection.
        ListIterator: Extends Iterator to allow bidirectional iteration of a list.
        Map.Entry: Represents a key-value pair in a Map.
        Enumeration: Represents a series of elements (used in legacy classes like Vector).
          </pre>
        
          <div class="string" id="string">
            <h1>String</h1>
               
            <details>
              <summary>
                <span class="faq-title"> 
                  <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                <img src="plus.svg" class="expand-icon" alt="Plus">
              </summary>        
              <div class="faq-content">
              <pre><code>
                STRING 
          
                public static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;
                public java.lang.String();
                public java.lang.String(java.lang.String);
                public java.lang.String(char[]);
                public java.lang.String(char[], int, int);
                public java.lang.String(int[], int, int);
                public java.lang.String(byte[], int, int, int);
                public java.lang.String(byte[], int);
                public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
                public java.lang.String(byte[], int, int, java.nio.charset.Charset);
                public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException;
                public java.lang.String(byte[], java.nio.charset.Charset);
                public java.lang.String(byte[], int, int);
                public java.lang.String(byte[]);
                public java.lang.String(java.lang.StringBuffer);
                public java.lang.String(java.lang.StringBuilder);
                public int length();
                public boolean isEmpty();
                public char charAt(int);
                public int codePointAt(int);
                public int codePointBefore(int);
                public int codePointCount(int, int);
                public int offsetByCodePoints(int, int);
                public void getChars(int, int, char[], int);
                public void getBytes(int, int, byte[], int);
                public byte[] getBytes(java.lang.String) throws java.io.UnsupportedEncodingException;
                public byte[] getBytes(java.nio.charset.Charset);
                public byte[] getBytes();
                public boolean equals(java.lang.Object);
                public boolean contentEquals(java.lang.StringBuffer);
                public boolean contentEquals(java.lang.CharSequence);
                public boolean equalsIgnoreCase(java.lang.String);
                public int compareTo(java.lang.String);
                public int compareToIgnoreCase(java.lang.String);
                public boolean regionMatches(int, java.lang.String, int, int);
                public boolean regionMatches(boolean, int, java.lang.String, int, int);
                public boolean startsWith(java.lang.String, int);
                public boolean startsWith(java.lang.String);
                public boolean endsWith(java.lang.String);
                public int hashCode();
                public int indexOf(int);
                public int indexOf(int, int);
                public int lastIndexOf(int);
                public int lastIndexOf(int, int);
                public int indexOf(java.lang.String);
                public int indexOf(java.lang.String, int);
                public int lastIndexOf(java.lang.String);
                public int lastIndexOf(java.lang.String, int);
                public java.lang.String substring(int);
                public java.lang.String substring(int, int);
                public java.lang.CharSequence subSequence(int, int);
                public java.lang.String concat(java.lang.String);
                public java.lang.String replace(char, char);
                public boolean matches(java.lang.String);
                public boolean contains(java.lang.CharSequence);
                public java.lang.String replaceFirst(java.lang.String, java.lang.String);
                public java.lang.String replaceAll(java.lang.String, java.lang.String);
                public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);
                public java.lang.String[] split(java.lang.String, int);
                public java.lang.String[] split(java.lang.String);
                public static java.lang.String join(java.lang.CharSequence, java.lang.CharSequence...);
                public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable<? extends java.lang.CharSequence>);
                public java.lang.String toLowerCase(java.util.Locale);
                public java.lang.String toLowerCase();
                public java.lang.String toUpperCase(java.util.Locale);
                public java.lang.String toUpperCase();
                public java.lang.String trim();
                public java.lang.String strip();
                public java.lang.String stripLeading();
                public java.lang.String stripTrailing();
                public boolean isBlank();
                public java.util.stream.Stream<java.lang.String> lines();
                public java.lang.String indent(int);
                public java.lang.String stripIndent();
                public java.lang.String translateEscapes();
                public <R> R transform(java.util.function.Function<? super java.lang.String, ? extends R>);
                public java.lang.String toString();
                public java.util.stream.IntStream chars();
                public java.util.stream.IntStream codePoints();
                public char[] toCharArray();
                public static java.lang.String format(java.lang.String, java.lang.Object...);
                public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object...);
                public java.lang.String formatted(java.lang.Object...);
                public static java.lang.String valueOf(java.lang.Object);
                public static java.lang.String valueOf(char[]);
                public static java.lang.String valueOf(char[], int, int);
                public static java.lang.String copyValueOf(char[], int, int);
                public static java.lang.String copyValueOf(char[]);
                public static java.lang.String valueOf(boolean);
                public static java.lang.String valueOf(char);
                public static java.lang.String valueOf(long);
                public static java.lang.String valueOf(float);
                public static java.lang.String valueOf(double);
                public native java.lang.String intern();
                public java.lang.String repeat(int);
                public java.util.Optional<java.lang.String> describeConstable();
                public java.lang.String resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);
                public int compareTo(java.lang.Object);
                public java.lang.Object resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException;
              </code></pre>
        
              <h2> public static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;</h2>
                <p>the stringList is sorted using the CASE_INSENSITIVE_ORDER comparator, which ensures that the strings are sorted in a case-insensitive manner</p>
        
        <pre><code>
          import java.util.ArrayList;
          import java.util.Collections;
          import java.util.List;
          
          public class stringbuildin {
              public static void main(String[] args) {
                  List<String> stringList = new ArrayList<>();
                  stringList.add("apple");
                  stringList.add("Banana");
                  stringList.add("Orange");
                  stringList.add("grapes");
          
                  // Sorting the list using CASE_SENSITIVE_ORDER comparator
                  Collections.sort(stringList);
                    for (String str : stringList) {
                      System.out.println(str);
                  }
            //output      // Banana
                          // Orange
                          // apple
                          // grapes
          
                  Collections.sort(stringList, String.CASE_INSENSITIVE_ORDER);
                  System.out.println();
                  for (String str : stringList) {
                      System.out.println(str);
                  }
             //output      // apple
                          // Banana
                          // grapes
                          // Orange
          
              }
          }
        </code></pre>
             
        <h2> 
          public java.lang.String(); <br>
          public java.lang.String(java.lang.String); <br>
          public java.lang.String(char[]); <br>
          public java.lang.String(char[], int, int); <br>
          public java.lang.String(int[], int, int); <br>
          public java.lang.String(byte[], int, int, int); <br>
          public java.lang.String(byte[], int); <br>
          public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException; <br>
          public java.lang.String(byte[], int, int, java.nio.charset.Charset); <br>
          public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException; <br>
          public java.lang.String(byte[], java.nio.charset.Charset); <br>
          public java.lang.String(byte[], int, int); <br>
          public java.lang.String(byte[]); <br>
          public java.lang.String(java.lang.StringBuffer); <br>
          public java.lang.String(java.lang.StringBuilder); <br>
        </h2>
        <p> public java.lang.String();, appears to be a constructor declaration for the String class in Java. constructors are not explicitly declared like this in the source code. Constructors are special methods used for initializing objects when they are created. The String class in Java has several constructors, but they are not declared using the public java.lang.String(); syntax.</p>
        <pre><code>
          import java.io.UnsupportedEncodingException;
        
        public class createstring {
            public static void main(String[]args) throws UnsupportedEncodingException{
        
                String str1 = "Hello"; // Using a string literal
        
                String originalString1 = "Hello";
                String str5 = new String(originalString1); // String created from another string object
        
                String originalString = "Hello, World!";
                String substring = new String(originalString.substring(0, 5)); // Using a substring
        
                String str8 = new String("Hello".getBytes()); // String created from byte array using the platform's default charset
        
                String str = "Hello, World!";//(A-Z==65-91) (a-z==97-123)
                byte[] byteArray = str.getBytes();//output - 72 101 108 108 111 44 32 87 111 114 108 100 33 
        
        
                //public java.lang.String(); 
                 String emptyString = new String(); // Creates an empty string
        
                //public java.lang.String(java.lang.String);
                 String originalString = "Hello, World!";
                 String newString = new String(originalString); 
        
                //public java.lang.String(byte[], int);
                 byte[] byteArray = {72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33};
                 String strFromBytes = new String(byteArray, 0);
            
                //public java.lang.String(char[]);
                char[] charArray = {'H', 'e', 'l', 'l', 'o'};
                String str2 = new String(charArray); // Using a character array
        
                //public java.lang.String(char[], int, int);
                char[] charArray1 = {'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd'};
                String str3 = new String(charArray1, 0, 5); // Creates a string from charArray starting from index 0 with length 5
               
                //public java.lang.String(int[], int, int);
                int[] codePoints = {72, 101, 108, 108, 111};
                String strFromCodePoints = new String(codePoints, 0,5);
             
                //public java.lang.String(byte[], int, int, int);
                byte[] byteArray = {72, 101, 108, 108, 111};
                String strFromBytes = new String(byteArray, 0, 5, StandardCharsets.UTF_8);
        
        
                //public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
                byte[] byteArray = {-50, -77, -48, -68, 44, 32, -48, -71, -48, -65, -48, -66, -48, -64, -48, -65, -48, -72, -48, -69, -48, -68, -48, -70, 33};
                try {
                    String strFromBytes = new String(byteArray, 0, 24, "UTF-8");
                    System.out.println("String from bytes: " + strFromBytes);
                } 
                catch (UnsupportedEncodingException e) {
                    // Handle the exception (e.g., print an error message)
                    e.printStackTrace();
                }
        
                //public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException;
                byte[] byteArray = {-50, -77, -48, -68, 44, 32, -48, -71, -48, -65, -48, -66, -48, -64, -48, -65, -48, -72, -48, -69, -48, -68, -48, -70, 33};
                try {
                    String strFromBytes = new String(byteArray, "UTF-8");
                    System.out.println("String from bytes: " + strFromBytes);
                } 
                catch (UnsupportedEncodingException e) {
                    // Handle the exception (e.g., print an error message)
                    e.printStackTrace();
                }
        
        
                //public java.lang.String(java.lang.StringBuilder);
                StringBuilder stringBuilder = new StringBuilder("Hello");
                String str6 = new String(stringBuilder); // String created from StringBuilder
        
                //public java.lang.String(java.lang.StringBuffer);
                StringBuffer stringBuffer = new StringBuffer("Hello");
                String str7 = new String(stringBuffer); // String created from StringBuffer
        
                //import java.io.UnsupportedEncodingException;
                //public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
                byte[] byteArray2 = str.getBytes("UTF-8"); (unicode transformation formate) //throw unsupportedexception 
                byte[] byteArray3 = str.getBytes(java.nio.charset.StandardCharsets.UTF_8);
        
                //public java.lang.String(byte[], int, int, java.nio.charset.Charset);
                byte[] byteArray = {72, 101, 108, 108, 111};
                String byteArray4 = new String(byteArray,0,3,StandardCharsets.UTF_8);
             
        
                //public java.lang.String(byte[], java.nio.charset.Charset);
                byte[] byteArray = {72, 101, 108, 108, 111};
                String byteArray4 = new String(byteArray,StandardCharsets.UTF_8);
        
                //public java.lang.String(byte[], int, int);
                byte[] byteArray = {72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33}; //hello world
                String strFromBytes = new String(byteArray, 0, 5);
        
                //public java.lang.String(byte[]);
                byte[] byteArray = {72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33}; // ASCII values for "Hello, World!"
                String strFromBytes = new String(byteArray);
        
                //In Java, the getBytes() method in the String class is used to encode the string into a sequence of bytes using the platform's default charset and returns the resulting byte array. 
        
        
            }
        }
        </code></pre>
        <h2> public int length();</h2>
        <p>The length() method in Java is a member of the String class. It returns the length (the number of characters) of the string</p>
              <pre>
                <code>
                1. //.length();
                  public class StringLengthExample {
                    public static void main(String[] args) {
                        String str = "Hello, World!";
                        int length = str.length();         
                        System.out.println("Length of the string: " + length);
                    }
                }
        
               2. //without inbuild function
                public class StringLengthWithoutLengthMethod {
                  public static void main(String[] args) {
                    String str = "Hello, World!";
                    int length = calculateStringLength(str);
                    System.out.println("Length of the string: " + length);
                }
        
                  public static int calculateStringLength(String str) {
                      int length = 0;
                      char[] charArray = str.toCharArray();
                      for (char ch : charArray) {
                          length++;
                      }
                      return length;
                  }
              }
            </code>
              </pre>
        
              <h2> public boolean isEmpty();</h2>
        <p>The isEmpty() method in Java is a member of the String class. It returns true if the string length is 0 (i.e., the string does not contain any characters), and false </p>
        <pre>
          <code>
            1.//isEmpty()
            public class StringIsEmptyExample {
        
              public static void main(String[] args) {
                  String str1 = ""; 
                  String str2 = "Hello, World!";
                 
                  boolean isEmpty1 = str1.isEmpty();
                  boolean isEmpty2 = str2.isEmpty();
                
                  System.out.println("Is str1 empty? " + isEmpty1); // Output: Is str1 empty? true
                  System.out.println("Is str2 empty? " + isEmpty2); // Output: Is str2 empty? false
              }
          }
        
          2.//without buildin 
          public class StringIsEmptyWithoutBuiltInExample {
        
            public static void main(String[] args) {
              String str1 = ""; 
              String str2 = "Hello, World!"; 
            
              boolean isEmpty1 = isEmptyString(str1);
              boolean isEmpty2 = isEmptyString(str2);
        
              System.out.println("Is str1 empty? " + isEmpty1); // Output: Is str1 empty? true
              System.out.println("Is str2 empty? " + isEmpty2); // Output: Is str2 empty? false
          }
        
            public static boolean isEmptyString(String str) {
               1. //return str.length() == 0;
        
               2. // for (int i = 0; i < str.length(); i++) {
                //  if (str.charAt(i) != ' ') {
                //      return false;  }
                // } return true;  
        
               3. //return str.equals("");
                }
        }
        
          
          </code>
        </pre>
        <h2>public char charAt(int);</h2>
        <p>The charAt(int index) method in Java is a member of the String class. It returns the character at the specified index within the string. </p>
           
        <pre>
         <code>
          1.//.charAt()
          public class CharAtExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
              
                char character = str.charAt(7);
                System.out.println("Character at index 7: " + character); // Output: Character at index 7: W
            }
        }
        
          2.//without buildin
        
          public class GetCharacterWithoutBuiltInExample {
        
            public static void main(String[] args) {
              String str = "Hello, World!";
              int index = 7;
              char character = getCharacterAtIndex(str, index);
              System.out.println("Character at index " + index + ": " + character); // Output: Character at index 7: W
          }
        
            public static char getCharacterAtIndex(String str, int index) {
                if (index >= 0 && index < str.length()) {
                    return str.toCharArray()[index];
                }
                else {
                    return '\0'; 
                }  
            }
        }
         </code>
        </pre>
        <h2>public int codePointAt(int);</h2>
        <p>
          The codePointAt(int index) method in Java is a member of the String class. It returns the Unicode code point of the character at the specified index within the string. </p>
        <pre><code>
        1.//.codePointAt()
          public class CodePointAtExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
              
                int codePoint = str.codePointAt(7); //w
                System.out.println("Unicode code point at index 7: " + codePoint); // Output: Unicode code point at index 7: 87
            }
        }
        
        
        2.//without buildin 
          public class highorlowsurrogate {
            public static void main(String[] args) {
                  String str = "Hello, World!";
                  int index = 7; 
          
                  int unicodeCodePoint = getUnicodeCodeAtPosition(str, index);
                  System.out.println(  "Unicode code point at index " + index +" of character is "+str.charAt(index)+ ": " + unicodeCodePoint); // Output: Unicode code point at index 7: 87
              }
        
              public static int getUnicodeCodeAtPosition(String str, int index) {
                  // Check if the index is valid
                  if (index >= 0 && index < str.length()) {
                      char charAtIndex = str.charAt(index);
                  //UTF-16
                      if (Character.isHighSurrogate(charAtIndex) && index + 1 < str.length()) {    // If the character is a surrogate pair (UTF-16 supplementary character)
                          char lowSurrogate = str.charAt(index + 1);
                          if (Character.isLowSurrogate(lowSurrogate)) {
                            
                              return Character.toCodePoint(charAtIndex, lowSurrogate);  // Calculate and return the Unicode code point for the surrogate pair
                          }
                      }
                      //The Unicode code point values for  high surrogates range from '\uD800' to '\uDBFF'. In decimal, these values are from 55296 to 56319.
                      //The Unicode code point values for low surrogates range from '\uDC00' to '\uDFFF'. In decimal, these values are from 56320 to 57343.
                    
                      // If the character is not a surrogate pair, return its Unicode code point
                      return (int) charAtIndex;
                  } 
                  else {
                      return -1;
                  }
              }
         }
        </code></pre>
        
        
        <h2>  public int codePointBefore(int);</h2>
        <p>The codePointBefore(int index) method in Java is a member of the String class. It returns the Unicode code point of the character preceding(before) the specified index within the string. </p>
        <pre><code>
          1.//.codePointBefore()
          public class codebefore {
            public static void main(String[] args) {
                String str = "Hello, World!";
                int index = 8; 
        
                int codePoint = str.codePointBefore(index);
        
                System.out.println("Unicode code point before index " + index + ": " + codePoint); // Output: Unicode code point before index 8: 32
            //current index is 8 : o (but it will print  before the index of 8, character is W :87)
            }
        }
        
        
        2.//without buildin
        public class codebefore {
          public static void main(String[] args) {
                String str = "Hello, World!";
                int index = 8; 
        
                int unicodeCodePoint = codePointBefore(str, index);
                System.out.println("Unicode code point before index " + index + ": " + unicodeCodePoint); // Output: Unicode code point before index 8: 32
            }
        
            public static int codePointBefore(String str, int index) {
                if (index > 0 && index < str.length()) {
                    char currentChar = str.charAt(index-1);
                   
                    if (Character.isLowSurrogate(currentChar)) {
                        char lowSurrogate = currentChar;
                        char highSurrogate = str.charAt(index - 1);
                      
                        if (Character.isHighSurrogate(highSurrogate)) {
                            return Character.toCodePoint(highSurrogate, lowSurrogate);
                        }
                    }
                    return (int) currentChar;
                }
                return -1;
            }
        }
        </code></pre>
        
        <h2> public int codePointCount(int, int);</h2>
        <p>The codePointCount(int beginIndex, int endIndex) method in Java is a member of the String class. It returns the number of Unicode code points in the specified text range of the string.</p>
        <pre><code>
          1.//.codePointCount()
          public class codepointCount {
            public static void main(String[] args) {
                String str = "Hello,ðŸ˜ŠðŸ˜ŠWorld!."; // String with Unicode and non-Unicode characters
                String str1 = "Hello,World!."; 
                  System.out.println(str.length());   
             
                int codePointCount = str.codePointCount(0, 8); //index(0-8)=>(Hello,ðŸ˜ŠðŸ˜Š) surrogate pair of emoji represent single unicode character
                int codePointCount1 = str1.codePointCount(0, 8);// index (0-8)=>(Hello,Wo) 
        
        
                System.out.println("Number of Unicode code points: " + codePointCount); // Output: Number of Unicode code points: 7
               System.out.println("Number of Unicode code points: " + codePointCount1);//Output: Number of Unicode code points: 8
            }       
        }
        </code></pre>
        
        
        <h2>public int offsetByCodePoints(int, int);</h2>
        <p>The offsetByCodePoints(int index, int codePointOffset) method in Java is a member of the String class. It calculates the index that is offset from a given index by a specified number of Unicode code points. <br> <br>
          <br>
          Text Processing: When processing natural language text, especially in languages with complex scripts or when dealing with emojis and other symbols, offsetByCodePoints helps in iterating through text characters regardless of whether they are within the BMP or outside it.
        <br>
        Cursor Movement in User Interfaces: In graphical user interfaces, when users are allowed to navigate through text using arrow keys, offsetByCodePoints can help move the cursor position accurately within the text, even if it contains characters represented by surrogate pairs
        </p>
        <pre><code>
          public static void main(String[] args) {
            String text = "Hello,ðŸ˜ŠWorld!";
            int index = 0;
        
            while (index < text.length()) {
                int codePoint = text.codePointAt(index);
                System.out.println("Code Point at index " + index + ": " + codePoint);
                index = text.offsetByCodePoints(index, 1);
            }
        }
        </code></pre>
        
        
        <h2>  public void getChars(int, int, char[], int);</h2>
        <p> The getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) method is a member of the String class in Java. It allows you to copy characters from a portion of the string (from srcBegin index to srcEnd - 1 index) into a character array dst, starting at the specified dstBegin index.</p>
        <ol>
          <li>  srcBegin: The starting index of the substring within the string.</li>
          <li>srcEnd: The ending index of the substring within the string (exclusive, i.e., the character at srcEnd index is not included).</li>
          <li>dst: The destination character array where the characters will be copied.</li>
          <li>dstBegin: The starting index in the destination character array where the characters will be placed.</li>
        </ol>
        
        <pre><code>
          public class get {
            public static void main(String[] args) {
                String str = "Hello, World!";
                char[] charArray = new char[10]; // Destination character array
        
                str.getChars(7, 13, charArray, 0);
        
                for (char c : charArray) {
                    System.out.print(c); // Output: World!
                }
            }
        }
        </code></pre>
        
        
        <h2>public void getBytes(int, int, byte[], int);</h2>
        <p>The getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) method in Java is a member of the String class. It allows you to encode characters from a portion of the string (from srcBegin index to srcEnd - 1 index) into a byte array dst, starting at the specified dstBegin index.</p>
        <p>use: <br>"UTF-8" is a string literal representing the name of the UTF-8 character encoding. <br>when creating a BufferedReader or PrintWriter with UTF-8 encoding, you can use this string literal</p>
        <pre><code>
          public class GetBytesExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
                byte[] byteArray = new byte[10]; // Destination byte array
        
                str.getBytes(7, 16, byteArray, 0);
        
                System.out.println("Encoded bytes in the byteArray:");
                for (byte b : byteArray) {
                    System.out.print(b + " "); // Output: 87 111 114 108 100 33 32 32 32 32
                }
            }
        }
        
        </code></pre>
        
        <h2>public byte[] getBytes(java.lang.String) throws java.io.UnsupportedEncodingException;</h2>
        <p>The getBytes(String charsetName) method in Java is a member of the String class. It allows you to encode the string into a sequence of bytes using the specified character encoding,</p>
        <p> use : <br>when using the getBytes(Charset charset) method of the String class or when working with classes from the java.nio.charset package.</p>
        <pre><code>
          import java.io.UnsupportedEncodingException;
        public class get {
            public static void main(String[] args) {
                String str = "Hello, World!";
            
                try {
                    byte[] byteArray = str.getBytes("UTF-8");
        
                    for (byte b : byteArray) {
                        System.out.print(b + " ");
                    }
                } 
                catch (UnsupportedEncodingException e) {
                    System.out.println("Unsupported encoding: " );
                }
            }
        }
        </code></pre>
        
        
        <h2>public byte[] getBytes();</h2>
        <p>The getBytes() method in Java is a member of the String class. It encodes the string into a sequence of bytes using the platform's default character encoding and returns the resulting byte array.</p>
        <pre><code>
        public class get {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                byte[] byteArray = str.getBytes();
        
                for (byte b : byteArray) {
                    System.out.print(b + " ");
                }
            }
        }
        </code></pre>
        
        
        <h2> public boolean equals(java.lang.Object);</h2>
        <p>When you use the equals method to compare instances of your custom class, it will use the overridden logic for equality comparison. This allows you to define equality based on the specific attributes or criteria that are meaningful for your class.</p>
        <pre><code>
        
          public class Person {
        
            public static void main(String[] args) {
              Person person1 = new Person("Alice", 30);
              Person person2 = new Person("Bob", 25);
              Person person3 = new Person("Alice", 30);
        
              // Compare persons for equality
              System.out.println("person1 equals person2: " + person1.equals(person2)); // Output: false
              System.out.println("person1 equals person3: " + person1.equals(person3)); // Output: true
          }
        
            private String name;
            private int age;
        
            public Person(String name, int age) {
                this.name = name;
                this.age = age;
            }
        
            // Getters and other methods...
            @Override
            public boolean equals(Object obj) {
                if (this == obj) {
                    return true;
                }
                if (obj == null || getClass() != obj.getClass()) {
                    return false;
                }
                Person person = (Person) obj;
                return age == person.age && name.equals(person.name);
            }
        }
        
        </code></pre>
        
        <h2>public boolean contentEquals(java.lang.StringBuffer);</h2>
        <p>The contentEquals(StringBuffer sb) method in Java is a member of the String class. It checks whether the content of the current string is equal to the content of the specified StringBuffer object sb.</p>
        <p>This method is specific to the String class and checks if the content of the current String object is equal to the content of the specified StringBuffer object sb.</p>
        
        <pre><code>
          public class ContentEqualsExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
                StringBuffer stringBuffer = new StringBuffer("Hello, World!");
        
                boolean isEqual = str.contentEquals(stringBuffer);
        
                System.out.println("Content is equal: " + isEqual); // Output: Content is equal: true
            }
        }
        </code></pre>
        
        
        
        <h2>public boolean contentEquals(java.lang.CharSequence);</h2>
        <p>This method is also specific to the String class, but it accepts any object that implements the CharSequence interface, such as String, StringBuilder, and StringBuffer.</p>
        <pre><code>
          public class ContentEqualsExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
                StringBuilder stringBuilder = new StringBuilder("Hello, World!");
        
                boolean isEqual = str.contentEquals(stringBuilder);
        
                System.out.println("Content is equal: " + isEqual); // Output: Content is equal: true
            }
        }
        </code></pre>
        
        
        
        <h2>public boolean equalsIgnoreCase(java.lang.String);</h2>
        <p>The equalsIgnoreCase(String anotherString) method in Java is a member of the String class. It compares the current string with another string (specified by anotherString) without considering their case. It checks if the characters in both strings are equal when converted to lowercase (or uppercase) characters.</p>
        <pre><code>
          public class EqualsIgnoreCaseExample {
            public static void main(String[] args) {
                String str1 = "Hello, World!";
                String str2 = "hello, world!";
        
                boolean isEqual = str1.equalsIgnoreCase(str2);
        
                System.out.println("Strings are equal ignoring case: " + isEqual); // Output: Strings are equal ignoring case: true
            }
        }
        </code></pre>
        
        
        <h2>public int compareTo(java.lang.String);</h2>
        <p>The compareTo(String anotherString) method in Java is a member of the String class. It compares the current string lexicographically (based on the Unicode values of characters) with another string (anotherString). The comparison is case-sensitive, meaning uppercase and lowercase characters are treated differently.</p>
        <pre><code>
          public class get {
            public static void main(String[] args) {
                String str1 = "apple";
                String str2 = "orange";
        
                // Compare strings lexicographically
                int result = str1.compareTo(str2);
        
              //Since 'a' (97) comes before 'o' (111) in Unicode order, the result of the comparison is negative.
              //Specifically, the difference between the Unicode values of 'o' and 'a' is 111 - 97 = -14.
                if (result < 0) {    //negative
                    System.out.println("str1 comes before str2");
                } 
                else if (result > 0) {  //positive
                    System.out.println("str1 comes after str2");
                } 
                else { //equal
                    System.out.println("str1 and str2 are equal");
                }
            }
        }
        </code></pre>
        
        <h2>public int compareToIgnoreCase(java.lang.String);</h2>
        <p>The compareToIgnoreCase(String anotherString) method in Java is a member of the String class. It compares the current string lexicographically (based on Unicode values of characters) with another string (anotherString), ignoring case differences. The comparison is case-insensitive, meaning uppercase and lowercase characters are treated the same way.</p>
        <pre><code>
          public class get {
            public static void main(String[] args) {
                String str1 = "apple";
                String str2 = "Orange";
        
                // Compare strings lexicographically ignoring case differences
                int result = str1.compareToIgnoreCase(str2);
        
                if (result < 0) {
                    System.out.println("str1 comes before str2");
                } else if (result > 0) {
                    System.out.println("str1 comes after str2");
                } else {
                    System.out.println("str1 and str2 are equal ignoring case");
                }
            }
            // In this example, str1 and str2 are compared lexicographically ignoring case differences. Since "apple" comes before "Orange" in dictionary order (when ignoring case), 
            // result will be a negative integer, indicating that str1 comes before str2. If the two strings were equal ignoring case, result would be 0. If str1 came after str2 ignoring case, result would be a positive integer.
        }
        </code></pre>
        
        
        <h2>public boolean regionMatches(int, java.lang.String, int, int);</h2>
        <p>The regionMatches(int toffset, String other, int ooffset, int length) method in Java is a member of the String class. It checks whether a specific region of the current string matches the specified region of another string (other).</p>
        <ol>
          <li>toffset: The starting index of the region in the current string.</li>
          <li>other: The string to be compared with.</li>
          <li>ooffset: The starting index of the region in the other string.</li>
          <li>length: The number of characters to compare in both strings.</li>
        </ol>
        <pre><code>
          public class RegionMatchesExample {
            public static void main(String[] args) {
                String str1 = "Hello, World!";
                String str2 = "World";
        
                boolean matches = str1.regionMatches(7, str2, 0, 5);
        
                System.out.println("Region matches: " + matches); // Output: Region matches: true
            }
        }
        
        </code></pre>
        
        
        <h2>public boolean regionMatches(boolean, int, java.lang.String, int, int);</h2>
        <p>The Java String regionMatches() method checks whether the two strings regions are equivalent or not. It compares a substring of the current object to a substring of the given String.</p>
        <ol>
          <li>ignoreCase : If true, ignore case, when comparing characters. # second syntax</li>
          <li>toffset : The starting offset of the subregion in this string.</li>
          <li>other : The string argument.</li>
          <li>ooffset : The starting offset of the subregion in the string argument.</li>
          <li>len : The number of characters to compare.</li>
        </ol>
        <pre><code>
          public class get {
            public static void main(String[] args) {
                String str1 = "Collection of tutorials";
                String str2 = "Consists of different tutorials";
                /* matches characters from index 14 in str1 to characters from  index 22 in str2 considering same case of the letters */
                
                boolean match1 = str1.regionMatches(14, str2, 22, 9);
                System.out.println("region matched = " + match1); //true 
        
                /* considering different case, "true" is set which will ignore   case when matched */
                str2 = "Consists of different Tutorials";
                match1 = str1.regionMatches(true, 14, str2, 22, 9); 
                System.out.println("region matched = " + match1);   //true 
             }
            }
        </code></pre>
        
        
        <h2>public boolean startsWith(java.lang.String, int);</h2>
        <p>The startsWith(String prefix, int toffset) method in Java is a member of the String class. It checks whether a substring of the current string, starting from the specified index toffset, starts with the specified prefix.</p>
        <ol>
          <li>prefix: The prefix to be checked.</li>
          <li>toffset: The starting index in the current string where the comparison should begin.</li>
        </ol>
        <pre><code>
          public class StartsWithExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
                String prefix = "World";
        
                boolean startsWith = str.startsWith(prefix, 7)
        
                System.out.println("Substring starts with prefix: " + startsWith); // Output: Substring starts with prefix: true
            }
        }
        
        </code></pre>
        
        
        <h2>public boolean startsWith(java.lang.String);</h2>
        <p> The startsWith(String prefix) method in Java is a member of the String class. It checks whether the current string starts with the specified prefix</p>
        <pre><code>
          public class StartsWithExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
                String prefix = "Hello";
        
                boolean startsWith = str.startsWith(prefix);
        
                System.out.println("String starts with prefix: " + startsWith); // Output: String starts with prefix: true
            }
        }
        
        </code></pre>
        
        
        <h2>public boolean endsWith(java.lang.String);</h2>
        <p>The endsWith(String suffix) method in Java is a member of the String class. It checks whether the current string ends with the specified suffix.</p>
        <pre><code>
          public class EndsWithExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
                String suffix = "World!";
        
                boolean endsWith = str.endsWith(suffix);
        
                System.out.println("String ends with suffix: " + endsWith); // Output: String ends with suffix: true
            }
        }
        
        </code></pre>
        
        <h2>public int hashCode();</h2>
        <p>The hashCode() method in Java is a member of the Object class, and it is also overridden in the String class. This method returns a hash code value for the object, which is used in hash-based collections like HashMap, HashSet, etc., to improve the performance of data retrieval operations.</p>
        <p>use: <br>
        Hash-based Collections: Hash-based data structures use hash codes to determine the index at which an object should be stored or looked up in the underlying array. This allows for constant-time complexity (O(1)) for insertion, deletion, and retrieval operations, on average, making these operations very fast even for large data sets.</p>
        <p>In this example, hashCode1 and hashCode2 will have the same value because the hashCode() method generates the hash code based on the content of the strings, not their memory addresses. If two strings have the same content, they will have the same hash code.</p>
        <pre><code>
        public class HashCodeExample {
            public static void main(String[] args) {
                String str1 = "Hello, World!";
                String str2 = "Hello, World!";
        
                int hashCode1 = str1.hashCode();
                int hashCode2 = str2.hashCode();
        
                System.out.println("Hash Code for str1: " + hashCode1); // Output: Hash Code for str1: -862545276
                System.out.println("Hash Code for str2: " + hashCode2); // Output: Hash Code for str2: -862545276
            }
        }
        
        </code></pre>
        
        
        <h2>public int indexOf(int);</h2>
        <p>The indexOf(int ch) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified character (Unicode code point) in the string. If the character is not found, it returns -1.</p>
        <pre><code>
        1.  //.indexOf()
        public class IndexOfExample {
        
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                int indexOfO = str.indexOf('o');
        
                System.out.println("Index of 'o': " + indexOfO);  // Output: Index of 'o': 4
            }
        }
        2.//without buildin
        public class CustomIndexOf {
            public static int customIndexOf(char target, String str) {
                for (int i = 0; i < str.length(); i++) {
                    if (str.charAt(i) == target) {
                        return i;  // Return the index if the character is found
                    }
                }
                return -1; 
            }
        
            public static void main(String[] args) {
                String myString = "Hello, World!";
                char targetChar = 'o';
        
                int indexOfO = customIndexOf(myString ,targetChar);
        
                System.out.println("Index of 'o': " + indexOfO);  // Output: Index of 'o': 4
            }
        }
        </code></pre>
        
        
        <h2>public int indexOf(int, int);</h2>
        <p>The indexOf(int ch, int fromIndex) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified character (ch) in the string, starting the search from the specified index (fromIndex). If the character is not found, it returns -1.</p>
        <pre><code>
          1.//.indexOf()
          public class IndexOfExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                int indexOfO = str.indexOf('o', 5);
        
                System.out.println("Index of 'o' starting from index 5: " + indexOfO);  // Output: Index of 'o' starting from index 5: 7
            }
        }
        
        2.//without buildin
        public class CustomIndexOf {
          public static int customIndexOf(char target, String str, int fromIndex) {
              if (fromIndex < 0 || fromIndex >= str.length()) {
                  return -1;  // Invalid fromIndex, return -1
              }
        
              for (int i = fromIndex; i < str.length(); i++) {
                  if (str.charAt(i) == target) {
                      return i; 
                  }
              }
              return -1; 
          }
        
          public static void main(String[] args) {
              String myString = "Hello, World!";
              char targetChar = 'o';
              int startIndex = 5;
        
              int indexOfO = customIndexOf(targetChar, myString, startIndex);
        
              System.out.println("Index of 'o' starting from index 5: " + indexOfO);  // Output: Index of 'o' starting from index 5: 7
          }
        }
        
        </code></pre>
        
        
        <h2>public int lastIndexOf(int);</h2>
        <p>The lastIndexOf(int ch) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified character (ch) in the string. If the character is not found, it returns -1</p>
        <pre><code>
        1.//.lastIndexOf
          public class LastIndexOfExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                int lastIndexOfO = str.lastIndexOf('o');
        
                System.out.println("Last index of 'o': " + lastIndexOfO);  // Output: Last index of 'o': 8
            }
        }
        
        2.//without buildin
        public class CustomLastIndexOf {
          public static int customLastIndexOf(char target, String str) {
              for (int i = str.length() - 1; i >= 0; i--) {
                  if (str.charAt(i) == target) {
                      return i; 
                  }
              }
              return -1;  
          }
        
          public static void main(String[] args) {
              String myString = "Hello, World!";
              char targetChar = 'o';
        
              int lastIndexOfO = customLastIndexOf(targetChar, myString);
        
              System.out.println("Last index of 'o': " + lastIndexOfO);  // Output: Last index of 'o': 8
          }
        }
        
        </code></pre>
        
        
        <h2>public int lastIndexOf(int, int);</h2>
        <p> The lastIndexOf(int ch, int fromIndex) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified character (ch) in the string, searching backward starting from the specified index (fromIndex). If the character is not found, it returns -1.</p>
        <pre><code>
          1.//.lastIndexOf
          public class LastIndexOfExample {
            public static void main(String[] args) {
                String str = "Hello, World! Hello, Java!";
        
                int lastIndexOfO = str.lastIndexOf('o', 10);
        
                System.out.println("Last index of 'o' before index 10: " + lastIndexOfO);  // Output: Last index of 'o' before index 10: 8
            }
        }
        
        2.//without inbuild
        public class CustomLastIndexOf {
          public static int customLastIndexOf(char target, String str, int fromIndex) {
              if (fromIndex < 0 || fromIndex >= str.length()) {
                  return -1;  // Invalid fromIndex, return -1
              }
        
              for (int i = fromIndex; i >= 0; i--) {
                  if (str.charAt(i) == target) {
                      return i;  // Return the index if the character is found
                  }
              }
              return -1;  // Return -1 if the character is not found
          }
        
          public static void main(String[] args) {
              String myString = "Hello, World! Hello, Java!";
              char targetChar = 'o';
              int startIndex = 10;
        
              int lastIndexOfO = customLastIndexOf(targetChar, myString, startIndex);
        
              System.out.println("Last index of 'o' before index 10: " + lastIndexOfO);  // Output: Last index of 'o' before index 10: 8
          }
        }
        
        </code></pre>
        
        
        
        <h2>public int indexOf(java.lang.String);</h2>
        <p>The indexOf(String str) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified substring (str) in the string. If the substring is not found, it returns -1.</p>
        <pre><code>
          1.//.indexof()
          public class IndexOfExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                int indexOfWorld = str.indexOf("World");
        
                System.out.println("Index of 'World': " + indexOfWorld);  // Output: Index of 'World': 7
            }
        }
        
        2.//without inbuild
        public class get {
          public static int customIndexOf(String target, String str) {
              for (int i = 0; i <= str.length() - target.length(); i++) {
                  if (str.substring(i, i + target.length()).equals(target)) {
                      return i;  // Return the index if the substring is found
                  }
              }
              return -1;  
          }
          public static void main(String[] args) {
              String myString = "Hello, World!";
              String targetSubstring = "World";
        
              int indexOfWorld = customIndexOf(targetSubstring, myString);
        
              System.out.println("Index of 'World': " + indexOfWorld);  // Output: Index of 'World': 7
          }
        }
        </code></pre>
        <pre>
        Start with i = 0.
        Check the substring from index 0 to 5 ("Hello"). No match.
        Increment i to 1.
        Check the substring from index 1 to 6 ("ello,"). No match.
        Increment i to 2.
        Check the substring from index 2 to 7 ("llo, W"). No match.
        Increment i to 3.
        Check the substring from index 3 to 8 ("lo, Wo"). No match.
        Increment i to 4.
        Check the substring from index 4 to 9 ("o, Wor"). No match.
        Increment i to 5.
        Check the substring from index 5 to 10 (", Worl"). No match.
        Increment i to 6.
        Check the substring from index 6 to 11 (" World"). Match found
        </pre>
        
        
        <h2>public int indexOf(java.lang.String, int);</h2>
        <p>The indexOf(String str, int fromIndex) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified substring (str) in the string, starting the search from the specified index (fromIndex). If the substring is not found, it returns -1.</p>
        <pre><code>
          public class IndexOfExample {
        
            public static void main(String[] args) {
                String str = "Hello, World! Hello, Java!";
        
                // Find the index of the substring "Hello" in the string starting from index 7
                int indexOfHello = str.indexOf("Hello", 7);
        
                // Print the result
                System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
            }
        }
        
        
        2.//without buildin
        public class CustomIndexOf {
          public static int customIndexOf(String target, String str, int fromIndex) {
              if (fromIndex < 0 || fromIndex >= str.length()) {
                  return -1;  // Invalid fromIndex, return -1
              }
        
              for (int i = fromIndex; i <= str.length() - target.length(); i++) {
                  if (str.substring(i, i + target.length()).equals(target)) {
                      return i;  // Return the index if the substring is found
                  }
              }
              return -1;  // Return -1 if the substring is not found
          }
        
          public static void main(String[] args) {
              String myString = "Hello, World! Hello, Java!";
              String targetSubstring = "Hello";
              int startIndex = 7;
        
              // Use the customIndexOf method to find the index of "Hello" starting from index 7
              int indexOfHello = customIndexOf(targetSubstring, myString, startIndex);
        
              System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
          }
        }
        
        </code></pre>
        
        
        
        <h2>public int lastIndexOf(java.lang.String);</h2>
        <p>The lastIndexOf(String str, int fromIndex) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified substring (str) in the string, starting the search from the specified index (fromIndex). If the substring is not found, it returns -1.</p>
        <pre><code>
          1.//.indexOf()
          public class IndexOfExample {
            public static void main(String[] args) {
                String str = "Hello, World! Hello, Java!";
        
                int indexOfHello = str.indexOf("Hello", 7);
        
                System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
            }
        }
        
        2.//without buildin
        public class ManualIndexOf {
        
          public static int manualIndexOf(String target, String str, int fromIndex) {
              if (fromIndex < 0 || fromIndex >= str.length()) {
                  return -1;  // Invalid fromIndex, return -1
              }
        
              for (int i = fromIndex; i <= str.length() - target.length(); i++) {
                  if (str.substring(i, i + target.length()).equals(target)) {
                      return i;  // Return the index if the substring is found
                  }
              }
              return -1;  // Return -1 if the substring is not found
          }
        
          public static void main(String[] args) {
              String myString = "Hello, World! Hello, Java!";
              String targetSubstring = "Hello";
              int startIndex = 7;
        
              int indexOfHello = manualIndexOf(targetSubstring, myString, startIndex);
        
              System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
          }
        }
        
        </code></pre>
        
        
        
        <h2>public int lastIndexOf(java.lang.String, int);</h2>
        <p>The lastIndexOf(String str, int fromIndex) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified substring (str) in the string, starting the search from the specified index (fromIndex). If the substring is not found, it returns -1.</p>
        <pre><code>
          public class LastIndexOfExample {
            public static void main(String[] args) {
                String str = "Hello, World! Hello, Java!";
        
                int lastIndexOfHello = str.lastIndexOf("Hello", 18);
        
                System.out.println("Last index of 'Hello' before index 18: " + lastIndexOfHello);  // Output: Last index of 'Hello' before index 18: 13
            }
        }
        
        2.//without buildin
        public class CustomLastIndexOf {
        
          public static void main(String[] args) {
            String myString = "Hello, World! Hello, Java!";
            String targetSubstring = "Hello";
            int startIndex = 18;
        
            int lastIndexOfHello = customLastIndexOf(targetSubstring, myString, startIndex);
        
            System.out.println("Last index of 'Hello' before index 18: " + lastIndexOfHello);  // Output: Last index of 'Hello' before index 18: 13
        }
        
          public static int customLastIndexOf(String target, String str, int fromIndex) {
              if (fromIndex < 0 || fromIndex >= str.length()) {
                  return -1;  
              }
        
              for (int i = fromIndex; i >= target.length() - 1; i--) {
                  if (substringEquals(str, i - target.length() + 1, i + 1, target)) {
                      return i - target.length() + 1;  // Return the index if the substring is found
                  }
              }
              return -1;  // Return -1 if the substring is not found
          }
        
          // Custom method to check if two substrings are equal
          private static boolean substringEquals(String str, int start1, int end1, String target) {
              if (end1 - start1 != target.length()) {
                  return false;  // Different lengths, not equal
              }
              for (int i = start1; i < end1; i++) {
                for (int j = 0; j < target.length(); j++) {
              <!-- for (int i = start1, j = 0; i < end1; i++, j++) { -->
                  if (str.charAt(i) != target.charAt(j)) {
                      return false;  // Characters don't match, not equal
                  }
              }
            }
              return true;  // All characters match, equal
          }
        
        }
        
        </code></pre>
        <pre>
          Start with i = 18 (fromIndex).
        Check the substring from index 17 to 13 ("Hello"). Match found!
        </pre>
        
        <h2>public java.lang.String substring(int);</h2>
        <p>The substring(int beginIndex) method in Java is a member of the String class. It is used to create a new string that is a substring of the original string, starting from the specified index (beginIndex) to the end of the original string.</p>
        <pre><code>
          1.//.Substring
          public class SubstringExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                String substring = str.substring(7);
        
                System.out.println("Substring from index 7 to the end: " + substring);  // Output: Substring from index 7 to the end: World!
            }
        }
        
        2.//without buildin
        public class CustomSubstring {
          public static void main(String[] args) {
            String myString = "Hello, World!";
        
            String customSubstring = customSubstring(myString, 7);
        
            System.out.println("Custom substring from index 7: " + customSubstring);  // Output: Custom substring from index 7: World!
        }
          public static String customSubstring(String str, int beginIndex) {
              if (beginIndex < 0 || beginIndex >= str.length()) {
                  return "";  // Invalid beginIndex, return an empty string
              }
        
              StringBuilder result = new StringBuilder();
              for (int i = beginIndex; i < str.length(); i++) {
                  result.append(str.charAt(i));
              }
        
              return result.toString();
          }
        }
        
        </code></pre>
        
        
        
        <h2>public java.lang.String substring(int, int);</h2>
        <p> The substring(int beginIndex, int endIndex) method in Java is a member of the String class. It is used to create a new string that is a substring of the original string, starting from the specified beginIndex and extending to the character at index endIndex - 1. The substring includes the character at beginIndex and goes up to, but does not include, the character at endIndex.</p>
        <pre><code>
          1.//.substring()
          public class SubstringExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                String substring = str.substring(7, 12);
        
                System.out.println("Substring from index 7 to index 12 (exclusive): " + substring);  // Output: Substring from index 7 to index 12 (exclusive): World
            }
        }
        
        2.//without buildin
        public class CustomSubstring {
        
          public static String customSubstring(String str, int beginIndex, int endIndex) {
              if (beginIndex < 0 || beginIndex >= str.length() || endIndex > str.length() || beginIndex > endIndex) {
                  return "";  // Invalid indices, return an empty string
              }
        
              StringBuilder result = new StringBuilder();
              for (int i = beginIndex; i < endIndex; i++) {
                  result.append(str.charAt(i));
              }
        
              return result.toString();
          }
        
          public static void main(String[] args) {
              String myString = "Hello, World!";
        
              // Use the customSubstring method to create a substring from index 7 to index 12 (exclusive)
              String customSubstring = customSubstring(myString, 7, 12);
        
              // Print the result
              System.out.println("Custom substring from index 7 to index 12 (exclusive): " + customSubstring);  // Output: Custom substring from index 7 to index 12 (exclusive): World
          }
        }
        
        </code></pre>
        
        
        
        <h2>public java.lang.CharSequence subSequence(int, int);</h2>
        <p>The subSequence(int beginIndex, int endIndex) method in Java is a member of the CharSequence interface. The CharSequence interface is implemented by various classes in Java, including String, StringBuilder, and StringBuffer.
        
          The subSequence method returns a new CharSequence that is a subsequence of the original sequence. The subsequence starts with the character at the specified beginIndex and extends to the character at endIndex - 1. The endIndex is exclusive, similar to the substring method.</p>
        <pre><code>
          public class SubsequenceExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                CharSequence subsequence = str.subSequence(7, 12);
        
                System.out.println("Subsequence from index 7 to index 12 (exclusive): " + subsequence);
            }
        }
        
        2.//without buildin
        public class CustomSubsequence {
          public static void main(String[] args) {
            String original = "Hello, World!";
        
            CharSequence customSubsequence = customSubsequence(original, 7, 12);
        
            System.out.println("Custom subsequence from index 7 to index 12 (exclusive): " + customSubsequence);
        }
          public static CharSequence customSubsequence(CharSequence sequence, int beginIndex, int endIndex) {
              if (beginIndex < 0 || beginIndex >= sequence.length() || endIndex > sequence.length() || beginIndex > endIndex) {
                  return "";  // Invalid indices, return an empty CharSequence
              }
        
              StringBuilder result = new StringBuilder();
              for (int i = beginIndex; i < endIndex; i++) {
                  result.append(sequence.charAt(i));
              }
        
              return result.toString();
          }
        }
        
        </code></pre>
        
        
        
        <h2>public java.lang.String concat(java.lang.String);</h2>
        <p>The concat method in Java is a member of the String class. It is used to concatenate one string to the end of another. The method returns a new string that represents the concatenation of the original string and the specified string.</p>
        <pre><code>
          public class ConcatExample {
            public static void main(String[] args) {
                String str1 = "Hello, ";
                String str2 = "World!";
        
                String result = str1.concat(str2);
        
                System.out.println("Concatenated String: " + result);  // Output: Concatenated String: Hello, World!
            }
        }
        
        2.//without buildin
        public class CustomConcatenation {
          public static void main(String[] args) {
            String str1 = "Hello, ";
            String str2 = "World!";
        
            String result = customConcat(str1, str2);
        
            System.out.println("Concatenated String: " + result);  // Output: Concatenated String: Hello, World!
        }
          public static String customConcat(String str1, String str2) {
              char[] resultArray = new char[str1.length() + str2.length()];
        
              // Copy characters from str1 to the resultArray
              for (int i = 0; i < str1.length(); i++) {
                  resultArray[i] = str1.charAt(i);
              }
        
              // Copy characters from str2 to the resultArray
              for (int i = 0; i < str2.length(); i++) {
                  resultArray[str1.length() + i] = str2.charAt(i);
              }
        
              // Create a new string from the resultArray
              return new String(resultArray);
          }
        }
        
        
        </code></pre>
        
        
        
        
        <h2>public java.lang.String replace(char, char);</h2>
        <p>The replace(char oldChar, char newChar) method in Java is a member of the String class. It is used to create a new string in which all occurrences of a specified character (oldChar) are replaced with another character (newChar).</p>
        <pre><code>
          public class ReplaceExample {
            public static void main(String[] args) {
                String original = "Hello, World!";
                char oldChar = 'o';
                char newChar = 'x';
        
                String result = original.replace(oldChar, newChar);
        
                System.out.println("Modified String: " + result);  // Output: Modified String: Hellx, Wxrld!
            }
        }
        
        2//without buildin
        public class CustomReplace {
        
          public static String customReplace(String original, char oldChar, char newChar) {
              char[] resultArray = new char[original.length()];
        
              // Iterate through each character in the original string
              for (int i = 0; i < original.length(); i++) {
                  char currentChar = original.charAt(i);
        
                  // Replace oldChar with newChar if it matches
                  if (currentChar == oldChar) {
                      resultArray[i] = newChar;
                  } 
                  else {
                      resultArray[i] = currentChar;
                  }
              }
        
              // Create a new string from the resultArray
              return new String(resultArray);
          }
        
          public static void main(String[] args) {
              String original = "Hello, World!";
              char oldChar = 'o';
              char newChar = 'x';
        
              String result = customReplace(original, oldChar, newChar);
        
              System.out.println("Modified String: " + result);  // Output: Modified String: Hellx, Wxrld!
          }
        }
        
        </code></pre>
        
        
        
        
        <h2>public boolean matches(java.lang.String);</h2>
        <p>The matches method in Java is a member of the String class. It is used to check whether a string matches a given regular expression. The method returns true if the entire string matches the specified regular expression, and false otherwise.</p>
        <pre><code>
          public class MatchesExample {
            public static void main(String[] args) {
                String str = "Hello123";
        
                boolean isMatch = str.matches("[A-Za-z]+\\d+");
        
                System.out.println("Is the string a match? " + isMatch);  // Output: Is the string a match? true
            }
        }
        
        
        public class CustomMatches {
        
          
          public static void main(String[] args) {
            String str = "Hello123";
        
            boolean isMatch = customMatches(str, "[A-Za-z]+\\d+");
        
            System.out.println("Is the string a match? " + isMatch);  // Output: Is the string a match? true
        }
          public static boolean customMatches(String input, String regex) {
              int inputLength = input.length();
              int regexLength = regex.length();
        
              // If the lengths are different, the strings cannot match
              if (inputLength != regexLength) {
                  return false;
              }
        
              // Iterate through each character and check for a match
              for (int i = 0; i < inputLength; i++) {
                  char inputChar = input.charAt(i);
                  char regexChar = regex.charAt(i);
        
                  // Check if the characters match or if regexChar is a wildcard '.'
                  if (inputChar != regexChar && regexChar != '.') {
                      return false;
                  }
              }
        
              // All characters match
              return true;
          }
        }
        
        </code></pre>
        
        
        
        
        <h2>public boolean contains(java.lang.CharSequence);</h2>
        <p>The contains method in Java is a member of the String class. It is used to check whether a sequence of characters (specified as a CharSequence) is present in the original string. The method returns true if the sequence is found, and false otherwise.</p>
        <pre><code>
          public class ContainsExample {
            public static void main(String[] args) {
                String str = "Hello, World!";
        
                boolean containsSequence = str.contains("World");
        
                System.out.println("Does the string contain the sequence? " + containsSequence);  // Output: Does the string contain the sequence? true
            }
        }
        
        2.//without buildin
        public class CustomContains {
        
          public static void main(String[] args) {
            String str = "Hello, World!";
        
            boolean containsSequence = customContains(str, "World");
        
            System.out.println("Does the string contain the sequence? " + containsSequence);  // Output: Does the string contain the sequence? true
        }
          public static boolean customContains(String original, CharSequence sequence) {
              int sequenceLength = sequence.length();
              int originalLength = original.length();
        
              // Iterate through each possible starting index in the original string
              for (int i = 0; i <= originalLength - sequenceLength; i++) {
                  // Check if the substring starting at index i matches the sequence
        
                  if (original.regionMatches(i, sequence.toString(), 0, sequenceLength)) {
                      return true;
                  }
              }
        
              // The sequence is not found in the original string
              return false;
          }
        }
        
        </code></pre>
        <p>
          <ol>
          <li>toffset: The starting index of the region in the current string.</li>
          <li>other: The string to be compared with.</li>
          <li>ooffset: The starting index of the region in the other string.</li>
          <li>length: The number of characters to compare in both strings.</li>
        </ol></p>
        
        
        <h2>public java.lang.String replaceFirst(java.lang.String, java.lang.String);</h2>
        <p>The replaceFirst method in Java is a member of the String class. It is used to replace the first occurrence of a specified substring (specified as the first parameter) with another substring (specified as the second parameter). The method returns a new string with the first occurrence of the specified substring replaced.</p>
        <pre><code>
          1//.replaceFirst()
          public class ReplaceFirstExample {
            public static void main(String[] args) {
                String str = "apple banana apple orange apple";
        
                String result = str.replaceFirst("apple", "fruit");
        
                System.out.println("Modified String: " + result);  // Output: Modified String: fruit banana apple orange apple
            }
        }
        
        2.//without buildin
        public class CustomReplaceFirst {
          public static String customReplaceFirst(String original, String target, String replacement) {
              int index = original.indexOf(target);
        
              // If the target substring is found, replace it; otherwise, return the original string
              if (index != -1) {
                  return original.substring(0, index) + replacement + original.substring(index + target.length());
              } else {
                  return original;
              }
          }
        
          public static void main(String[] args) {
              String str = "apple banana apple orange apple";
        
              String result = customReplaceFirst(str, "apple", "fruit");
        
              System.out.println("Modified String: " + result);
              // Output: Modified String: fruit banana apple orange apple
          }
        }
        
        </code></pre>
        
        
        
        <h2>public java.lang.String replaceAll(java.lang.String, java.lang.String);</h2>
        <p>The replaceAll method in Java is a member of the String class. It is used to replace all occurrences of a specified substring (specified as the first parameter) with another substring (specified as the second parameter). The method returns a new string with all occurrences of the specified substring replaced.</p>
        <pre><code>
          1.//.replaceAll()
          public class ReplaceAllExample {
        
            public static void main(String[] args) {
                String str = "apple banana apple orange apple";
        
                String result = str.replaceAll("apple", "fruit");
        
                System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
            }
        }
        
        2.//without buildin
        public class CustomReplaceAll {
          public static String customReplaceAll(String original, String target, String replacement) {
        
              // Iterate until no more occurrences of the target substring are found
              while (original.contains(target)) {
                  int index = original.indexOf(target);
        
                  original = original.substring(0, index) + replacement + original.substring(index + target.length());
              }
        
              // Return the modified string
              return original;
          }
        
          public static void main(String[] args) {
              String str = "apple banana apple orange apple";
        
              String result = customReplaceAll(str, "apple", "fruit");
        
              System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
          }
        }
        
        </code></pre>
        
        <pre>
          Construct New String:
        
        original.substring(0, index): The substring before the target substring, i.e., an empty string.
        replacement: The replacement string, i.e., "fruit".
        original.substring(index + target.length()): The substring after the target substring, i.e., " banana apple orange apple".
        </pre>
        
        <h2>public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);</h2>
        <p>The replace method in Java is a member of the String class. It is used to replace all occurrences of a specified CharSequence (substring or character sequence) with another CharSequence. The method returns a new string with all occurrences of the specified CharSequence replaced.</p>
        
        <pre><code>
          public class ReplaceExample {
            public static void main(String[] args) {
                String str = "apple banana apple orange apple";
        
                String result = str.replace("apple", "fruit");
        
                System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
            }
        }
        2.//without buildin
        
        public class CustomReplace {
        
          public static String customReplace(String original, CharSequence target, CharSequence replacement) {
              // Convert CharSequence to String
              String targetStr = target.toString();
              String replacementStr = replacement.toString();
        
              // Iterate until no more occurrences of the target substring are found
              while (original.contains(targetStr)) {
                  int index = original.indexOf(targetStr);
        
                  original = original.substring(0, index) + replacementStr + original.substring(index + targetStr.length());
              }
        
              // Return the modified string
              return original;
          }
        
          public static void main(String[] args) {
              String str = "apple banana apple orange apple";
        
              String result = customReplace(str, "apple", "fruit");
        
              System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
          }
        }
        
        </code></pre>
        
        
        <h2>public java.lang.String[] split(java.lang.String, int);</h2>
        <p>The split method in Java is a member of the String class. It is used to split a string into an array of substrings based on a specified regular expression. The method returns an array of strings.</p>
        <pre><code>
          public class SplitExample {
            public static void main(String[] args) {
                String str = "apple,banana,orange,grape";
        
                String[] result = str.split(",");
        
            
                System.out.println("Split String:");
                for (String s : result) {
                    System.out.println(s);
                }
                // Output:
                // Split String:
                // apple
                // banana
                // orange
                // grape
            }
        }
        
        2.//without buildin
        public class CustomSplit {
        
          public static String[] customSplit(String original, String delimiter, int limit) {
              // Check if the delimiter is present in the original string
              if (!original.contains(delimiter)) {
                  // If the delimiter is not found, return the original string as the only element in the array
                  return new String[]{original};
              }
        
              // Create a list to store the substrings
              List<String> substrings = new ArrayList<>();
        
              // Initialize variables for tracking the start and end indices
              int startIndex = 0;
              int endIndex;
        
              // Iterate through the original string
              while ((endIndex = original.indexOf(delimiter, startIndex)) != -1) {
                  // Add the substring to the list
                  substrings.add(original.substring(startIndex, endIndex));
        
                  // Move the start index to the next position after the delimiter
                  startIndex = endIndex + delimiter.length();
        
                  // Break if the number of substrings reaches the specified limit
                  if (substrings.size() == limit - 1) {
                      break;
                  }
              }
        
              // Add the remaining substring (after the last delimiter) to the list
              substrings.add(original.substring(startIndex));
        
              // Convert the list to an array
              return substrings.toArray(new String[0]);
          }
        
          public static void main(String[] args) {
              String str = "apple,banana,orange,grape";
        
              // Split the string based on the comma (",") delimiter with a limit of 2
              String[] result = customSplit(str, ",", 2);
        
              System.out.println("Custom Split String:");
              for (String s : result) {
                  System.out.println(s);
              }
              // Output:
              // Custom Split String:
              // apple
              // banana,orange,grape
          }
        }
        
        </code></pre>
        <pre>
          // First iteration
        endIndex = original.indexOf(delimiter, startIndex); // endIndex = 5
        // Loop body executes
        
        // Second iteration
        startIndex = endIndex + delimiter.length(); // startIndex = 6
        endIndex = original.indexOf(delimiter, startIndex); // endIndex = 12
        // Loop body executes
        
        // Third iteration
        startIndex = endIndex + delimiter.length(); // startIndex = 13
        endIndex = original.indexOf(delimiter, startIndex); // endIndex = 19
        // Loop body executes
        
        // Fourth iteration
        startIndex = endIndex + delimiter.length(); // startIndex = 20
        endIndex = original.indexOf(delimiter, startIndex); // endIndex = -1
        // Loop condition is false, loop exits
        </pre>
        
        <h2>public java.lang.String[] split(java.lang.String);</h2>
        <p></p>
        <pre><code>
          public class SplitExample {
        
            public static void main(String[] args) {
                String str = "apple,banana,orange,grape";
        
                // Split the string based on the comma (",") delimiter
                String[] result = str.split(",");
        
                // Print the result
                System.out.println("Split String:");
                for (String s : result) {
                    System.out.println(s);
                }
                // Output:
                // Split String:
                // apple
                // banana
                // orange
                // grape
            }
        }
        
        2.//without buildin
        public class CustomSplit {
        
          public static String[] customSplit(String original, String delimiter) {
              // Create a list to store the substrings
              List<String> substrings = new ArrayList<>();
        
              // Initialize variables for tracking the start and end indices
              int startIndex = 0;
              int endIndex;
        
              // Iterate through the original string
              while ((endIndex = original.indexOf(delimiter, startIndex)) != -1) {
                  // Add the substring to the list
                  substrings.add(original.substring(startIndex, endIndex));
        
                  // Move the start index to the next position after the delimiter
                  startIndex = endIndex + delimiter.length();
              }
        
              // Add the remaining substring (after the last delimiter) to the list
              substrings.add(original.substring(startIndex));
        
              // Convert the list to an array
              return substrings.toArray(new String[0]);
          }
        
          public static void main(String[] args) {
              String str = "apple,banana,orange,grape";
        
              // Split the string based on the comma (",") delimiter using custom method
              String[] result = customSplit(str, ",");
        
              // Print the result
              System.out.println("Custom Split String:");
              for (String s : result) {
                  System.out.println(s);
              }
              // Output:
              // Custom Split String:
              // apple
              // banana
              // orange
              // grape
          }
        }
        
        </code></pre>
        
        
        <h2>public static java.lang.String join(java.lang.CharSequence, java.lang.CharSequence...);</h2>
        <p>The join method in Java is a static method of the String class introduced in Java 8. It is used to join multiple CharSequence instances into a single String. </p>
        <pre><code>
          1.//.Join()
          public class JoinExample {
            public static void main(String[] args) {
                // Join three strings with a comma as a delimiter
                String result = String.join(", ", "apple", "banana", "orange");
        
                System.out.println("Joined String: " + result); // Output: Joined String: apple, banana, orange
            }
        }
        
        
        2.//without buildin
        public class CustomJoin {
        
          public static void main(String[] args) {
            
            String result = customJoin(", ", "apple", "banana", "orange");
        
            System.out.println("Custom Joined String: " + result); // Output: Custom Joined String: apple, banana, orange
        }
          public static String customJoin(CharSequence delimiter, CharSequence... elements) {
              // Check if there are no elements to join
              if (elements.length == 0) {
                  return "";
              }
        
              // Initialize the result with the first element
              StringBuilder result = new StringBuilder(elements[0]);
        
              // Iterate through the remaining elements
              for (int i = 1; i < elements.length; i++) {
                  // Append the delimiter and the current element to the result
                  result.append(delimiter).append(elements[i]);
              }
        
              // Convert StringBuilder to String
              return result.toString();
          }
        }
        
        </code></pre>
        
        
        <h2>public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable`<` ? extends java.lang.CharSequence>);</h2>
        <p>
          The split method in Java is used to split a string into an array of substrings based on a specified regular expression. When you call split with a single String parameter, that string is treated as a regular expression to determine the splitting pattern.</p>
        <pre><code>
          1.//.join()
          import java.util.Arrays;
          public class JoinIterableExample {
          
              public static void main(String[] args) {
                  // Join an Iterable of strings with a comma as a delimiter
                  Iterable<CharSequence> elements = Arrays.asList("apple", "banana", "orange");
                  String result = String.join(", ", elements);
          
                  System.out.println("Joined String: " + result);// Output: Joined String: apple, banana, orange
              }
          }
          
          2.//without buildin
          import java.util.Arrays;
        
        public class CustomJoinIterable {
        
            public static String customJoin(CharSequence delimiter, Iterable < ? extends CharSequence> elements) {
                // Create a StringBuilder to store the result
                StringBuilder result = new StringBuilder();
        
                // Initialize a flag to determine if the delimiter should be added
                boolean addDelimiter = false;
        
                // Iterate through the elements
                for (CharSequence element : elements) {
                    // Add the delimiter if needed
                    if (addDelimiter) {
                        result.append(delimiter);
                    }
        
                    // Add the current element to the result
                    result.append(element);
        
                    // Set the flag to true for subsequent elements
                    addDelimiter = true;
                }
        
                // Convert StringBuilder to String
                return result.toString();
            }
        
            public static void main(String[] args) {
                // Join an Iterable of strings with a comma as a delimiter using custom method
                Iterable<CharSequence> elements = Arrays.asList("apple", "banana", "orange");
                String result = customJoin(", ", elements);
        
                System.out.println("Custom Joined String: " + result); // Output: Custom Joined String: apple, banana, orange
            }
        }
        
        </code></pre>
        
        
        <h2>public java.lang.String toLowerCase(java.util.Locale);</h2>
        <p>The toLowerCase(Locale) method in Java is a member of the String class. It is used to convert all the characters in a string to lowercase based on the rules of a specified Locale.</p>
        <pre><code>
          public class ToLowerCaseExample {
            public static void main(String[] args) {
                String original = "HELLO WORLD";
            
                String lowercaseDefault = original.toLowerCase();     // Convert the string to lowercase using the default locale
        
                String lowercaseUS = original.toLowerCase(Locale.US);     // Convert the string to lowercase using a specific locale (for example, Locale.US)
        
                System.out.println("Lowercase (Default Locale): " + lowercaseDefault); // Lowercase (Default Locale): hello world
                System.out.println("Lowercase (Locale.US): " + lowercaseUS);// Lowercase (Locale.US): hello world  
            }
        } 
        </code></pre>
        
        
        
        
        <h2>public java.lang.String toLowerCase();</h2>
        <p></p>
        <pre><code>
          public class ToLowerCaseExample {
            public static void main(String[] args) {
                String original = "Hello World";
        
                String lowercase = original.toLowerCase();
        
                System.out.println("Lowercase: " + lowercase); // Lowercase: hello world
            }
        }
        
        2.//without buildin
        public class CustomToLowerCase {
        
          public static void main(String[] args) {
            String original = "Hello World";
        
            String lowercase = customToLowerCase(original);
        
            System.out.println("Lowercase: " + lowercase); // Lowercase: hello world
        }
          public static String customToLowerCase(String original) {
              // Create a StringBuilder to store the result
              StringBuilder result = new StringBuilder();
        
              // Iterate through each character in the original string
              for (int i = 0; i < original.length(); i++) {
                  char currentChar = original.charAt(i);
        
                  // Check if the character is an uppercase letter
                  if (currentChar >= 'A' && currentChar <= 'Z') {
                      // Convert uppercase letter to lowercase and append to the result
                      result.append((char) (currentChar + ('a' - 'A')));
                  } 
                  else {
                      // Keep non-uppercase letters unchanged and append to the result
                      result.append(currentChar);
                  }
              }
        
              // Convert StringBuilder to String
              return result.toString();
          }
        }
        
        </code></pre>
        
        <h2>public java.lang.String toUpperCase(java.util.Locale);</h2>
        <p>e customToUpperCase method iterates through each character in the original string. If a character is a lowercase letter, it is converted to uppercase by adjusting its ASCII value. Non-lowercase letters remain unchanged. The result is then stored in a StringBuilder and converted to a String.</p>
        <pre><code>
          import java.util.Locale;
          public class ToUpperCaseExample {
              public static void main(String[] args) {
                  String original = "hello world";
          
                  // Using the built-in toUpperCase(Locale) method
                  String uppercaseDefault = original.toUpperCase();
          
                  // Using the built-in toUpperCase(Locale) method with a specific locale (for example, Locale.US)
                  String uppercaseUS = original.toUpperCase(Locale.US);
        
                  System.out.println("Uppercase (Default Locale): " + uppercaseDefault);  // Uppercase (Default Locale): HELLO WORLD
                  System.out.println("Uppercase (Locale.US): " + uppercaseUS); // Uppercase (Locale.US): HELLO WORLD
              }
          }
          
          2.//without buildin
          public class CustomToUpperCase {
        
            public static String customToUpperCase(String original) {
                // Create a StringBuilder to store the result
                StringBuilder result = new StringBuilder();
        
                // Iterate through each character in the original string
                for (int i = 0; i < original.length(); i++) {
                    char currentChar = original.charAt(i);
        
                    // Check if the character is a lowercase letter
                    if (currentChar >= 'a' && currentChar <= 'z') {
                        // Convert lowercase letter to uppercase and append to the result
                        result.append((char) (currentChar - ('a' - 'A')));
                    } else {
                        // Keep non-lowercase letters unchanged and append to the result
                        result.append(currentChar);
                    }
                }
        
                // Convert StringBuilder to String
                return result.toString();
            }
        
            public static void main(String[] args) {
                String original = "hello world";
                // Convert the string to uppercase using custom method
                String uppercase = customToUpperCase(original);
        
                System.out.println("Uppercase: " + uppercase);    // Uppercase: HELLO WORLD
            }
        }
        
        </code></pre>
        
        <h2>public java.lang.String toUpperCase();</h2>
        <p>The toUpperCase() method in Java is a member of the String class. It is used to convert all the characters in a string to uppercase.</p>
        <pre><code>
          public class ToUpperCaseExample {
            public static void main(String[] args) {
                String original = "hello world";
        
                // Convert the string to uppercase
                String uppercase = original.toUpperCase();
        
                System.out.println("Uppercase: " + uppercase);  // Uppercase: HELLO WORLD
            }
        }
        
        </code></pre>
        
        
        
        
        <h2>public java.lang.String trim();</h2>
        <p>The trim() method in Java is a member of the String class. It is used to remove leading and trailing whitespace (spaces, tabs, and newlines) from a string. The method returns a new string with the whitespace removed.</p>
        <pre><code>
          public class TrimExample {
            public static void main(String[] args) {
                String original = "   Hello, World!   ";
        
                // Trim the string to remove leading and trailing whitespace
                String trimmed = original.trim();
        
                System.out.println("Trimmed: '" + trimmed + "'"); // Trimmed: 'Hello, World!'
            }
        }
        
        </code></pre>
        <pre>
          Initialization:
          start: Initialized to 0, representing the start index of the string.
          end: Initialized to original.length() - 1, representing the end index of the string.
        
          Find Start Index:
          A while loop is used to find the index of the first non-whitespace character from the start of the string.
          Inside the loop, Character.isWhitespace(original.charAt(start)) checks if the character at the current start index is whitespace.
          Return Trimmed Substring:
        
          Find End Index:
        Another while loop is used to find the index of the first non-whitespace character from the end of the string.
        Inside the loop, Character.isWhitespace(original.charAt(end)) checks if the character at the current end index is whitespace.
        The loop decrements end until a non-whitespace character is found or until end goes below start.
        
          
        Return Trimmed Substring:
          The substring(start, end + 1) method is then called to extract the substring from start to end + 1.
          The end + 1 is used to include the character at the end index in the resulting substring.
        
          Result:
          The resulting substring is the trimmed version of the original string, containing only the characters between the first non-whitespace character from the start and the first non-whitespace character from the end.
        </pre>
        
        <h2>public java.lang.String strip();</h2>
        <p>The strip() method in Java is a member of the String class. It was introduced in Java 11 and is used to remove leading and trailing whitespace from a string. The method is similar to trim(), but it uses the Unicode-aware definition of whitespace, which includes not only ASCII spaces, tabs, and newlines but also other Unicode whitespace characters</p>
        <pre><code>
          public class StripExample {
            public static void main(String[] args) {
                String original = "   Hello, World!   ";
        
                // Strip the string to remove leading and trailing whitespace
                String stripped = original.strip();
        
                System.out.println("Original: '" + original + "'");  // Original: '   Hello, World!   '
                System.out.println("Stripped: '" + stripped + "'");  // Original: '   Hello, World!   '
             
              
         x
            }
        }
        
        </code></pre>
        
        <h2>public java.lang.String stripLeading();</h2>
        <p>The strip() method in Java is a member of the String class. It was introduced in Java 11 and is used to remove leading and trailing whitespace from a string. The method is similar to trim(), but it uses the Unicode-aware definition of whitespace, which includes not only ASCII spaces, tabs, and newlines but also other Unicode whitespace characters.</p>
        <pre><code>
          public class StripExample {
            public static void main(String[] args) {
                String original = "   Hello, World!   ";
        
                // Strip the string to remove leading and trailing whitespace
                String stripped = original.strip();
        
                System.out.println("Original: '" + original + "'"); // Original: '   Hello, World!   '
                System.out.println("Stripped: '" + stripped + "'"); // Stripped: 'Hello, World!'       
               
            }
        }
        </code></pre>
        
        
        
        
        <h2>public java.lang.String stripTrailing();</h2>
        <p>The stripTrailing() method in Java is a member of the String class. It was introduced in Java 11 and is used to remove trailing whitespace (spaces, tabs, and newlines) from a string. Similar to strip(), it uses the Unicode-aware definition of whitespace.</p>
        <pre><code>
          public class StripTrailingExample {
            public static void main(String[] args) {
                String original = "   Hello, World!   ";
        
                // Strip trailing whitespace from the string
                String strippedTrailing = original.stripTrailing();
             
                System.out.println("Original: '" + original + "'");  // Original: '   Hello, World!   '
                System.out.println("Stripped Trailing: '" + strippedTrailing + "'"); // Stripped Trailing: '   Hello, World!'
            }
        }
        
        </code></pre>
        
        
        <h2>public boolean isBlank();</h2>
        <p>The isBlank() method in Java is a member of the String class. It was introduced in Java 11 and is used to check whether a string is empty or contains only whitespace characters (including Unicode whitespace). It returns true if the string is empty or contains only whitespace; otherwise, it returns false.</p>
        <pre><code>
          public class IsBlankExample {
        
            public static void main(String[] args) {
                String emptyString = "";
                String whitespaceString = "    ";
                String nonEmptyString = "Hello, World!";
        
                // Check if strings are blank
                boolean isEmptyBlank = emptyString.isBlank();
                boolean isWhitespaceBlank = whitespaceString.isBlank();
                boolean isNonEmptyBlank = nonEmptyString.isBlank();
        
                System.out.println("Is Empty String Blank: " + isEmptyBlank);             // true
                System.out.println("Is Whitespace String Blank: " + isWhitespaceBlank); // true
                System.out.println("Is Non-Empty String Blank: " + isNonEmptyBlank);     // false
            }
        }
        
        2.//without buildin
        public class CustomIsBlank {
        
          public static boolean customIsBlank(String str) {
              // Check if the string is null
              if (str == null) {
                  return true;
              }
        
              // Check if the string is empty or contains only whitespace
              for (int i = 0; i < str.length(); i++) {
                  if (!Character.isWhitespace(str.charAt(i))) {
                      return false; // Non-whitespace character found
                  }
              }
        
              return true; // String is either empty or contains only whitespace
          }
        
          public static void main(String[] args) {
              String emptyString = "";
              String whitespaceString = "    ";
              String nonEmptyString = "Hello, World!";
        
              // Check if strings are blank using custom method
              boolean isEmptyBlank = customIsBlank(emptyString);
              boolean isWhitespaceBlank = customIsBlank(whitespaceString);
              boolean isNonEmptyBlank = customIsBlank(nonEmptyString);
        
         
              System.out.println("Is Empty String Blank: " + isEmptyBlank);             // true
              System.out.println("Is Whitespace String Blank: " + isWhitespaceBlank); // true
              System.out.println("Is Non-Empty String Blank: " + isNonEmptyBlank);     // false
          }
        }
        
        </code></pre>
           
        <h2>  public java.util.stream.Stream<java.lang.String> lines();</h2>
        <p>The lines() method in Java is a member of the BufferedReader class and is used to create a Stream of lines from the text read from the underlying Reader. It is commonly used with the Files class to read lines from a file.</p>
        <pre><code>
          import java.io.BufferedReader;
          import java.io.FileReader;
          import java.io.IOException;
          import java.util.stream.Stream;
          
          public class LinesExample {
          
              public static void main(String[] args) {
                  // Provide the path to your text file
                  String filePath = "path/to/your/textfile.txt";
          
                  // Try-with-resources to ensure proper resource management
                  try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                      // Use lines() to create a Stream of lines
                      Stream<String> lines = reader.lines();
          
                      // Process each line using the Stream API
                      lines.forEach(System.out::println);
                  } 
                  catch (IOException e) {
                      e.printStackTrace();
                  }
              }
          }
          
        </code></pre>
        
        
        <h2>  public java.lang.String indent(int);</h2>
        <p>The indent(int) method in Java is a member of the String class. It was introduced in Java 12 and is used to create a new String where each line in the original string is indented by a specified number of spaces.</p>
        <pre><code>
          public class IndentExample {
        
            public static void main(String[] args) {
                String original = "Line 1\nLine 2\nLine 3";
        
                // Indent each line by 4 spaces
                String indented = original.indent(4);
        
                // Print the results
                System.out.println("Original:\n" + original);
                System.out.println("Indented:\n" + indented);
            }
        }
        
        2.//without buildin
        public class ManualIndent {
        
          public static String manualIndent(String original, int spaces) {
              if (original == null) {
                  return null;
              }
        
              // Step 2: Split into Lines
              String[] lines = original.split("\n");
        
              // Step 3: Indent Each Line
              StringBuilder indentedBuilder = new StringBuilder();
              for (String line : lines) {
                  // Step 3: Append Indentation and Line
                  for (int i = 0; i < spaces; i++) {
                      indentedBuilder.append(' '); // Append spaces
                  }
                  indentedBuilder.append(line).append("\n");
              }
        
              // Step 4: Remove Trailing Newline
              if (lines.length > 0) {
                  indentedBuilder.deleteCharAt(indentedBuilder.length() - 1);
              }
        
              // Step 5: Return Indented String
              return indentedBuilder.toString();
          }
        
          public static void main(String[] args) {
              String original = "Line 1\nLine 2\nLine 3";
        
              // Indent each line by 4 spaces using custom method
              String indented = manualIndent(original, 4);
        
              // Print the results
              System.out.println("Original:\n" + original);
              System.out.println("Indented:\n" + indented);
          }
        }
        
        </code></pre>
        
        
        <h2>  public java.lang.String stripIndent();</h2>
        <p>The stripIndent() method in Java is a member of the String class. It was introduced in Java 13 and is used to remove common leading whitespace from each line of a string. This is particularly useful when defining multi-line strings in the source code with consistent indentation.</p>
        <pre><code>
          public class StripIndentExample {
        
            public static void main(String[] args) {
                String indentedString = """
                    Line 1
                    Line 2
                    Line 3
                """;
        
                // Strip common leading whitespace from each line
                String stripped = indentedString.stripIndent();
        
                // Print the results
                System.out.println("Original:\n" + indentedString);
                System.out.println("Stripped Indent:\n" + stripped);
            }
        }
        
        </code></pre>
        
        
        <h2> public java.lang.String translateEscapes();</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2> public <R> R transform(java.util.function.Function<? super java.lang.String, ? extends R>);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2>public java.lang.String toString();</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2> public java.util.stream.IntStream chars();</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2> public java.util.stream.IntStream codePoints();</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        
        <h2> public char[] toCharArray();</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2>public static java.lang.String format(java.lang.String, java.lang.Object...);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2>public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object...);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2>public java.lang.String formatted(java.lang.Object...);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        
        <h2>public static java.lang.String valueOf(java.lang.Object);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public static java.lang.String valueOf(char[]);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        
        <h2>public static java.lang.String valueOf(char[], int, int);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public static java.lang.String copyValueOf(char[], int, int);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        
        <h2>public static java.lang.String copyValueOf(char[]);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public static java.lang.String valueOf(boolean);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public static java.lang.String valueOf(char);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public static java.lang.String valueOf(long);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public static java.lang.String valueOf(float);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public static java.lang.String valueOf(double);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2>public native java.lang.String intern();</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public java.lang.String repeat(int);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public java.util.Optional<java.lang.String> describeConstable();</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        <h2>public java.lang.String resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        
        <h2>public int compareTo(java.lang.Object);</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        <h2>public java.lang.Object resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException;</h2>
        <p></p>
        <pre><code>
        
        </code></pre>
        
        
        
        </div>
            </details>
        
          
           
            <h1>Collection</h1>
               <details>
              <summary>
                <span class="faq-title"> 
                  <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                <img src="plus.svg" class="expand-icon" alt="Plus">
              </summary>        
              <div class="faq-content">
        <pre><code>
          public interface java.util.Collection<E> extends java.lang.Iterable<E> 
            public abstract int size();
            public abstract boolean isEmpty();
            public abstract boolean contains(java.lang.Object);
            public abstract java.util.Iterator<E> iterator();
            public abstract java.lang.Object[] toArray();
            public abstract <T> T[] toArray(T[]);
            public default <T> T[] toArray(java.util.function.IntFunction<T[]>);
            public abstract boolean add(E);
            public abstract boolean remove(java.lang.Object);
            public abstract boolean containsAll(java.util.Collection<?>);
            public abstract boolean addAll(java.util.Collection<? extends E>);
            public abstract boolean removeAll(java.util.Collection<?>);
            public abstract boolean retainAll(java.util.Collection<?>);
            public abstract void clear();
            public abstract boolean equals(java.lang.Object);
            public abstract int hashCode();
            public default java.util.Spliterator<E> spliterator();
            public default java.util.stream.Stream<E> stream();
            public default java.util.stream.Stream<E> parallelStream();
        </code></pre>
            </div>
            </details>
        
        
            
            <h1 style="color: rgb(204, 201, 32);">List</h1>
               <details>
              <summary>
                <span class="faq-title"> 
                  <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                <img src="plus.svg" class="expand-icon" alt="Plus">
              </summary>        
              <div class="faq-content">
        <pre><code>
          LIST
        
        
          public interface java.util.List<E> extends java.util.Collection<E> 
          public abstract int size();
          public abstract boolean isEmpty();
          public abstract boolean contains(java.lang.Object);
          public abstract java.util.Iterator<E> iterator();
          public abstract java.lang.Object[] toArray();
          public abstract <T> T[] toArray(T[]);
          public abstract boolean add(E);
          public abstract boolean remove(java.lang.Object);
          public abstract boolean containsAll(java.util.Collection<?>);
          public abstract boolean addAll(java.util.Collection<? extends E>);
          public abstract boolean addAll(int, java.util.Collection<? extends E>);
          public abstract boolean removeAll(java.util.Collection<?>);
          public abstract boolean retainAll(java.util.Collection<?>);
          public default void replaceAll(java.util.function.UnaryOperator<E>);
          public default void sort(java.util.Comparator<? super E>);
          public abstract void clear();
          public abstract boolean equals(java.lang.Object);
          public abstract int hashCode();
          public abstract E get(int);
          public abstract E set(int, E);
          public abstract void add(int, E);
          public abstract E remove(int);
          public abstract int indexOf(java.lang.Object);
          public abstract int lastIndexOf(java.lang.Object);
          public abstract java.util.ListIterator<E> listIterator();
          public abstract java.util.ListIterator<E> listIterator(int);
          public abstract java.util.List<E> subList(int, int);
          public default java.util.Spliterator<E> spliterator();
          public static <E> java.util.List<E> of();
          public static <E> java.util.List<E> of(E);
          public static <E> java.util.List<E> of(E, E);
          public static <E> java.util.List<E> of(E, E, E);
          public static <E> java.util.List<E> of(E, E, E, E);
          public static <E> java.util.List<E> of(E, E, E, E, E);
          public static <E> java.util.List<E> of(E, E, E, E, E, E);
          public static <E> java.util.List<E> of(E, E, E, E, E, E, E);
          public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E);
          public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E, E);
          public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E, E, E);
          public static <E> java.util.List<E> of(E...);
          public static <E> java.util.List<E> copyOf(java.util.Collection<? extends E>);
        </code></pre>
            </div>
            </details>
        
        
            
            <h1  style="color:rgb(223, 3, 150)">ArrayList</h1>
               <details>
              <summary>
                <span class="faq-title"> 
                  <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                <img src="plus.svg" class="expand-icon" alt="Plus">
              </summary>        
              <div class="faq-content">
        <pre><code>
          ARRAYLIST
          
        
          public class java.util.ArrayList<E> extends java.util.AbstractList<E> implements java.util.List<E>, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
          public java.util.ArrayList(int);
          public java.util.ArrayList();
          public java.util.ArrayList(java.util.Collection<? extends E>);
          public void trimToSize();
          public void ensureCapacity(int);
          public int size();
          public boolean isEmpty();
          public boolean contains(java.lang.Object);
          public int indexOf(java.lang.Object);
          public int lastIndexOf(java.lang.Object);
          public java.lang.Object clone();
          public java.lang.Object[] toArray();
          public <T> T[] toArray(T[]);
          public E get(int);
          public E set(int, E);
          public boolean add(E);
          public void add(int, E);
          public E remove(int);
          public boolean equals(java.lang.Object);
          public int hashCode();
          public boolean remove(java.lang.Object);
          public void clear();
          public boolean addAll(java.util.Collection<? extends E>);
          public boolean addAll(int, java.util.Collection<? extends E>);
          public boolean removeAll(java.util.Collection<?>);
          public boolean retainAll(java.util.Collection<?>);
          public java.util.ListIterator<E> listIterator(int);
          public java.util.ListIterator<E> listIterator();
          public java.util.Iterator<E> iterator();
          public java.util.List<E> subList(int, int);
          public void forEach(java.util.function.Consumer<? super E>);
          public java.util.Spliterator<E> spliterator();
          public boolean removeIf(java.util.function.Predicate<? super E>);
          public void replaceAll(java.util.function.UnaryOperator<E>);
          public void sort(java.util.Comparator<? super E>);
        </code></pre>
            </div>
            </details>
        
        
            <h1  style="color:rgb(223, 3, 150)">LinkedList</h1>
            <details>
           <summary>
             <span class="faq-title"> 
               <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
             <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
        <pre>
          <code>
            LINKEDLIST
          
          
        
            PS D:\APP\all folder\3D Objects\dsa> javap -public java.util.LinkedList
            Compiled from "LinkedList.java"
            public class java.util.LinkedList<E> extends java.util.AbstractSequentialList<E> implements java.util.List<E>, java.util.Deque<E>, java.lang.Cloneable, java.io.Serializable {
              public java.util.LinkedList();
              public java.util.LinkedList(java.util.Collection<? extends E>);
              public E getFirst();
              public E getLast();
              public E removeFirst();
              public E removeLast();
              public void addFirst(E);
              public void addLast(E);
              public boolean contains(java.lang.Object);
              public int size();
              public boolean add(E);
              public boolean remove(java.lang.Object);
              public boolean addAll(java.util.Collection<? extends E>);
              public boolean addAll(int, java.util.Collection<? extends E>);
              public void clear();
              public E get(int);
              public E set(int, E);
              public void add(int, E);
              public E remove(int);
              public int indexOf(java.lang.Object);
              public int lastIndexOf(java.lang.Object);
              public E peek();
              public E element();
              public E poll();
              public E remove();
              public boolean offer(E);
              public boolean offerFirst(E);
              public boolean offerLast(E);
              public E peekFirst();
              public E peekLast();
              public E pollFirst();
              public E pollLast();
              public void push(E);
              public E pop();
              public boolean removeFirstOccurrence(java.lang.Object);
              public boolean removeLastOccurrence(java.lang.Object);
              public java.util.ListIterator<E> listIterator(int);
              public java.util.Iterator<E> descendingIterator();
              public java.lang.Object clone();
              public java.lang.Object[] toArray();
              public <T> T[] toArray(T[]);
              public java.util.Spliterator<E> spliterator();
          </code>
        
        </pre>
        
         </div>
         </details>
        
        
         <h1  style="color:rgb(223, 3, 150)">Stack</h1>
         <details>
        <summary>
          <span class="faq-title"> 
            <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
          <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          public class java.util.Stack<E> extends java.util.Vector<E> 
            private static final long serialVersionUID;
            public java.util.Stack();
            public E push(E);
            public synchronized E pop();
            public synchronized E peek();
            public boolean empty();
            public synchronized int search(java.lang.Object);
        </code></pre>
        </div>
        </details>
        
        
        
        <h1  style="color:rgb(223, 3, 150)">Vector</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
        <code>
          public class java.util.Vector<E> extends java.util.AbstractList<E> implements java.util.List<E>, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
            protected java.lang.Object[] elementData;
            protected int elementCount;
            protected int capacityIncrement;
            private static final long serialVersionUID;
            public java.util.Vector(int, int);
            public java.util.Vector(int);
            public java.util.Vector();
            public java.util.Vector(java.util.Collection<? extends E>);
            public synchronized void copyInto(java.lang.Object[]);
            public synchronized void trimToSize();
            public synchronized void ensureCapacity(int);
            private java.lang.Object[] grow(int);
            private java.lang.Object[] grow();
            public synchronized void setSize(int);
            public synchronized int capacity();
            public synchronized int size();
            public synchronized boolean isEmpty();
            public java.util.Enumeration<E> elements();
            public boolean contains(java.lang.Object);
            public int indexOf(java.lang.Object);
            public synchronized int indexOf(java.lang.Object, int);
            public synchronized int lastIndexOf(java.lang.Object);
            public synchronized int lastIndexOf(java.lang.Object, int);
            public synchronized E elementAt(int);
            public synchronized E firstElement();
            public synchronized E lastElement();
            public synchronized void setElementAt(E, int);
            public synchronized void removeElementAt(int);
            public synchronized void insertElementAt(E, int);
            public synchronized void addElement(E);
            public synchronized boolean removeElement(java.lang.Object);
            public synchronized void removeAllElements();
            public synchronized java.lang.Object clone();
            public synchronized java.lang.Object[] toArray();
            public synchronized <T> T[] toArray(T[]);
            E elementData(int);
            static <E> E elementAt(java.lang.Object[], int);
            public synchronized E get(int);
            public synchronized E set(int, E);
            private void add(E, java.lang.Object[], int);
            public synchronized boolean add(E);
            public boolean remove(java.lang.Object);
            public void add(int, E);
            public synchronized E remove(int);
            public void clear();
            public synchronized boolean containsAll(java.util.Collection<?>);
            public boolean addAll(java.util.Collection<? extends E>);
            public boolean removeAll(java.util.Collection<?>);
            public boolean retainAll(java.util.Collection<?>);
            public boolean removeIf(java.util.function.Predicate<? super E>);
            private static long[] nBits(int);
            private static void setBit(long[], int);
            private static boolean isClear(long[], int);
            private synchronized boolean bulkRemove(java.util.function.Predicate<? super E>);       
            public synchronized boolean addAll(int, java.util.Collection<? extends E>);
            public synchronized boolean equals(java.lang.Object);
            public synchronized int hashCode();
            public synchronized java.lang.String toString();
            public synchronized java.util.List<E> subList(int, int);
            protected synchronized void removeRange(int, int);
            private void shiftTailOverGap(java.lang.Object[], int, int);
            private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
            private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;        
            public synchronized java.util.ListIterator<E> listIterator(int);
            public synchronized java.util.ListIterator<E> listIterator();
            public synchronized java.util.Iterator<E> iterator();
            public synchronized void forEach(java.util.function.Consumer<? super E>);
            public synchronized void replaceAll(java.util.function.UnaryOperator<E>);
            public synchronized void sort(java.util.Comparator<? super E>);
            public java.util.Spliterator<E> spliterator();
            void checkInvariants();
            private static boolean lambda$retainAll$1(java.util.Collection, java.lang.Object);      
            private static boolean lambda$removeAll$0(java.util.Collection, java.lang.Object);  
        </code>
        </pre>
        
        </div>
        </details>
        
        
        <h1  style="color:rgb(223, 3, 150)">Enumeration</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          public interface java.util.Enumeration<E> 
            public abstract boolean hasMoreElements();
            public abstract E nextElement();
            public default java.util.Iterator<E> asIterator();
        </code></pre>
        </div>
        </details>
        
        <h1  style="color: rgb(204, 201, 32);">Queue</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          public interface java.util.Queue<E> extends java.util.Collection<E> 
            public abstract boolean add(E);
            public abstract boolean offer(E);
            public abstract E remove();
            public abstract E poll();
            public abstract E element();
            public abstract E peek();
        </code></pre>
        </div>
        </details>
        
        
        
        <h1 style="color:rgb(223, 3, 150)">PriorityQueue</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          PriorityQueue
        
        
          public class java.util.PriorityQueue<E> extends java.util.AbstractQueue<E> implements java.io.Serializable {
            private static final long serialVersionUID;
            private static final int DEFAULT_INITIAL_CAPACITY;
            transient java.lang.Object[] queue;
            int size;
            private final java.util.Comparator<? super E> comparator;
            transient int modCount;
            public java.util.PriorityQueue();
            public java.util.PriorityQueue(int);
            public java.util.PriorityQueue(java.util.Comparator<? super E>);
            public java.util.PriorityQueue(int, java.util.Comparator<? super E>);
            public java.util.PriorityQueue(java.util.Collection<? extends E>);
            public java.util.PriorityQueue(java.util.PriorityQueue<? extends E>);
            public java.util.PriorityQueue(java.util.SortedSet<? extends E>);
            private static java.lang.Object[] ensureNonEmpty(java.lang.Object[]);
            private void initFromPriorityQueue(java.util.PriorityQueue<? extends E>);
            private void initElementsFromCollection(java.util.Collection<? extends E>);
            private void initFromCollection(java.util.Collection<? extends E>);
            private void grow(int);
            public boolean add(E);
            public boolean offer(E);
            public E peek();
            private int indexOf(java.lang.Object);
            public boolean remove(java.lang.Object);
            void removeEq(java.lang.Object);
            public boolean contains(java.lang.Object);
            public java.lang.Object[] toArray();
            public <T> T[] toArray(T[]);
            public java.util.Iterator<E> iterator();
            public int size();
            public void clear();
            public E poll();
            E removeAt(int);
            private void siftUp(int, E);
            private static <T> void siftUpComparable(int, T, java.lang.Object[]);
            private static <T> void siftUpUsingComparator(int, T, java.lang.Object[], java.util.Comparator<? super T>);
            private void siftDown(int, E);
            private static <T> void siftDownComparable(int, T, java.lang.Object[], int);
            private static <T> void siftDownUsingComparator(int, T, java.lang.Object[], int, java.util.Comparator<? super T>);
            private void heapify();
            public java.util.Comparator<? super E> comparator();
            private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;
            private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
            public final java.util.Spliterator<E> spliterator();
            public boolean removeIf(java.util.function.Predicate<? super E>);
            public boolean removeAll(java.util.Collection<?>);
            public boolean retainAll(java.util.Collection<?>);
            private static long[] nBits(int);
            private static void setBit(long[], int);
            private static boolean isClear(long[], int);
            private boolean bulkRemove(java.util.function.Predicate<? super E>);
            public void forEach(java.util.function.Consumer<? super E>);
            private static boolean lambda$retainAll$1(java.util.Collection, java.lang.Object);      
            private static boolean lambda$removeAll$0(java.util.Collection, java.lang.Object);   
        </code></pre>
        </div>
        </details>
        
        
        
        <h1 style="color:rgb(223, 3, 150)"> Dequeue</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          Dequeue
        
        
          public interface java.util.Deque<E> extends java.util.Queue<E> 
            public abstract void addFirst(E);
            public abstract void addLast(E);
            public abstract boolean offerFirst(E);
            public abstract boolean offerLast(E);
            public abstract E removeFirst();
            public abstract E removeLast();
            public abstract E pollFirst();
            public abstract E pollLast();
            public abstract E getFirst();
            public abstract E getLast();
            public abstract E peekFirst();
            public abstract E peekLast();
            public abstract boolean removeFirstOccurrence(java.lang.Object);
            public abstract boolean removeLastOccurrence(java.lang.Object);
            public abstract boolean add(E);
            public abstract boolean offer(E);
            public abstract E remove();
            public abstract E poll();
            public abstract E element();
            public abstract E peek();
            public abstract boolean addAll(java.util.Collection<? extends E>);
            public abstract void push(E);
            public abstract E pop();
            public abstract boolean remove(java.lang.Object);
            public abstract boolean contains(java.lang.Object);
            public abstract int size();
            public abstract java.util.Iterator<E> iterator();
            public abstract java.util.Iterator<E> descendingIterator();
        </code></pre>
        </div>
        </details>
        
        <h1 style="color:rgb(223, 3, 150)"> ArrayDequeue</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          ArrayDequeue
        
          public class java.util.ArrayDeque<E> extends java.util.AbstractCollection<E> implements java.util.Deque<E>, java.lang.Cloneable, java.io.Serializable {
            transient java.lang.Object[] elements;
            transient int head;
            transient int tail;
            private static final int MAX_ARRAY_SIZE;
            private static final long serialVersionUID;
            private void grow(int);
            private int newCapacity(int, int);
            public java.util.ArrayDeque();
            public java.util.ArrayDeque(int);
            public java.util.ArrayDeque(java.util.Collection<? extends E>);
            static final int inc(int, int);
            static final int dec(int, int);
            static final int inc(int, int, int);
            static final int sub(int, int, int);
            static final <E> E elementAt(java.lang.Object[], int);
            static final <E> E nonNullElementAt(java.lang.Object[], int);
            public void addFirst(E);
            public void addLast(E);
            public boolean addAll(java.util.Collection<? extends E>);
            private void copyElements(java.util.Collection<? extends E>);
            public boolean offerFirst(E);
            public boolean offerLast(E);
            public E removeFirst();
            public E removeLast();
            public E pollFirst();
            public E pollLast();
            public E getFirst();
            public E getLast();
            public E peekFirst();
            public E peekLast();
            public boolean removeFirstOccurrence(java.lang.Object);
            public boolean removeLastOccurrence(java.lang.Object);
            public boolean add(E);
            public boolean offer(E);
            public E remove();
            public E poll();
            public E element();
            public E peek();
            public void push(E);
            public E pop();
            boolean delete(int);
            public int size();
            public boolean isEmpty();
            public java.util.Iterator<E> iterator();
            public java.util.Iterator<E> descendingIterator();
            public java.util.Spliterator<E> spliterator();
            public void forEach(java.util.function.Consumer<? super E>);
            public boolean removeIf(java.util.function.Predicate<? super E>);
            public boolean removeAll(java.util.Collection<?>);
            public boolean retainAll(java.util.Collection<?>);
            private boolean bulkRemove(java.util.function.Predicate<? super E>);
            private static long[] nBits(int);
            private static void setBit(long[], int);
            private static boolean isClear(long[], int);
            private boolean bulkRemoveModified(java.util.function.Predicate<? super E>, int);
            public boolean contains(java.lang.Object);
            public boolean remove(java.lang.Object);
            public void clear();
            private static void circularClear(java.lang.Object[], int, int);
            public java.lang.Object[] toArray();
            private <T> T[] toArray(java.lang.Class<T[]>);
            public <T> T[] toArray(T[]);
            public java.util.ArrayDeque<E> clone();
            private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;        
            private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
            void checkInvariants();
            public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
            private static boolean lambda$retainAll$1(java.util.Collection, java.lang.Object);      
            private static boolean lambda$removeAll$0(java.util.Collection, java.lang.Object); 
        
         
        </code></pre>
        </div>
        </details>
        
        
         
        <h1 style="color: rgb(204, 201, 32);">Set</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          SET
          
          public interface java.util.Set<E> extends java.util.Collection<E> 
          public abstract int size();
          public abstract boolean isEmpty();
          public abstract boolean contains(java.lang.Object);
          public abstract java.util.Iterator<E> iterator();
          public abstract java.lang.Object[] toArray();
          public abstract <T> T[] toArray(T[]);
          public abstract boolean add(E);
          public abstract boolean remove(java.lang.Object);
          public abstract boolean containsAll(java.util.Collection<?>);
          public abstract boolean addAll(java.util.Collection<? extends E>);
          public abstract boolean retainAll(java.util.Collection<?>);
          public abstract boolean removeAll(java.util.Collection<?>);
          public abstract void clear();
          public abstract boolean equals(java.lang.Object);
          public abstract int hashCode();
          public default java.util.Spliterator<E> spliterator();
          public static <E> java.util.Set<E> of();
          public static <E> java.util.Set<E> of(E);
          public static <E> java.util.Set<E> of(E, E);
          public static <E> java.util.Set<E> of(E, E, E);
          public static <E> java.util.Set<E> of(E, E, E, E);
          public static <E> java.util.Set<E> of(E, E, E, E, E);
          public static <E> java.util.Set<E> of(E, E, E, E, E, E);
          public static <E> java.util.Set<E> of(E, E, E, E, E, E, E);
          public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E);
          public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E, E);
          public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E, E, E);
          public static <E> java.util.Set<E> of(E...);
          public static <E> java.util.Set<E> copyOf(java.util.Collection<? extends E>);
          
        </code></pre>
        </div>
        </details>
        
        
        
        <h1 style="color:rgb(223, 3, 150)"> HashSet</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
          HASHSET
          
          public class java.util.HashSet<E> extends java.util.AbstractSet<E> implements java.util.Set<E>, java.lang.Cloneable, java.io.Serializable {
          public java.util.HashSet();
          public java.util.HashSet(java.util.Collection<? extends E>);
          public java.util.HashSet(int, float);
          public java.util.HashSet(int);
          public java.util.Iterator<E> iterator();
          public int size();
          public boolean isEmpty();
          public boolean contains(java.lang.Object);
          public boolean add(E);
          public boolean remove(java.lang.Object);
          public void clear();
          public java.lang.Object clone();
          public java.util.Spliterator<E> spliterator();
          public java.lang.Object[] toArray();
          public <T> T[] toArray(T[]);
          public static <T> java.util.HashSet<T> newHashSet(int);
        </div>
        </details>
        
        
        
        <h1 style="color:rgb(223, 3, 150)"> linkedhashset</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          linkedhashset
        
        
          public class java.util.LinkedHashSet<E> extends java.util.HashSet<E> implements java.util.Set<E>, java.lang.Cloneable, java.io.Serializable {
            private static final long serialVersionUID;
            public java.util.LinkedHashSet(int, float);
            public java.util.LinkedHashSet(int);
            public java.util.LinkedHashSet();
            public java.util.LinkedHashSet(java.util.Collection<? extends E>);
            public java.util.Spliterator<E> spliterator();
            public static <T> java.util.LinkedHashSet<T> newLinkedHashSet(int);
        </code></pre>
        </div>
        </details>
        
        
        <h1 style="color:rgb(223, 3, 150)">TreeSet</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          TREESET
          
          public class java.util.TreeSet<E> extends java.util.AbstractSet<E> implements java.util.NavigableSet<E>, java.lang.Cloneable, java.io.Serializable {
          public java.util.TreeSet();
          public java.util.TreeSet(java.util.Comparator<? super E>);
          public java.util.TreeSet(java.util.Collection<? extends E>);
          public java.util.TreeSet(java.util.SortedSet<E>);
          public java.util.Iterator<E> iterator();
          public java.util.Iterator<E> descendingIterator();
          public java.util.NavigableSet<E> descendingSet();
          public int size();
          public boolean isEmpty();
          public boolean contains(java.lang.Object);
          public boolean add(E);
          public boolean remove(java.lang.Object);
          public void clear();
          public boolean addAll(java.util.Collection<? extends E>);
          public java.util.NavigableSet<E> subSet(E, boolean, E, boolean);
          public java.util.NavigableSet<E> headSet(E, boolean);
          public java.util.NavigableSet<E> tailSet(E, boolean);
          public java.util.SortedSet<E> subSet(E, E);
          public java.util.SortedSet<E> headSet(E);
          public java.util.SortedSet<E> tailSet(E);
          public java.util.Comparator<? super E> comparator();
          public E first();
          public E last();
          public E lower(E);
          public E floor(E);
          public E ceiling(E);
          public E higher(E);
          public E pollFirst();
          public E pollLast();
          public java.lang.Object clone();
          public java.util.Spliterator<E> spliterator();
        </code></pre>
        </div>
        </details>
        
        
        
        <h1>Map</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          MAP
          
          public interface java.util.Map<K, V> {
          public abstract int size();
          public abstract boolean isEmpty();
          public abstract boolean containsKey(java.lang.Object);
          public abstract boolean containsValue(java.lang.Object);
          public abstract V get(java.lang.Object);
          public abstract V put(K, V);
          public abstract V remove(java.lang.Object);
          public abstract void putAll(java.util.Map<? extends K, ? extends V>);
          public abstract void clear();
          public abstract java.util.Set<K> keySet();
          public abstract java.util.Collection<V> values();
          public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();
          public abstract boolean equals(java.lang.Object);
          public abstract int hashCode();
          public default V getOrDefault(java.lang.Object, V);
          public default void forEach(java.util.function.BiConsumer<? super K, ? super V>);
          public default void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public default V putIfAbsent(K, V);
          public default boolean remove(java.lang.Object, java.lang.Object);
          public default boolean replace(K, V, V);
          public default V replace(K, V);
          public default V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
          public default V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public default V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public default V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
          public static <K, V> java.util.Map<K, V> of();
          public static <K, V> java.util.Map<K, V> of(K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V);      
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> ofEntries(java.util.Map$Entry<? extends K, ? extends V>...);
          public static <K, V> java.util.Map$Entry<K, V> entry(K, V);
          public static <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V>);
        </code></pre>
        </div>
        </details>
        
        
        <h1 style="color: rgb(204, 201, 32);">HashMap</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          HASHMAP
          
          public class java.util.HashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.Map<K, V>, java.lang.Cloneable, java.io.Serializable {
          public java.util.HashMap(int, float);
          public java.util.HashMap(int);
          public java.util.HashMap();
          public java.util.HashMap(java.util.Map<? extends K, ? extends V>);
          public int size();
          public boolean isEmpty();
          public V get(java.lang.Object);
          public boolean containsKey(java.lang.Object);
          public V put(K, V);
          public void putAll(java.util.Map<? extends K, ? extends V>);
          public V remove(java.lang.Object);
          public void clear();
          public boolean containsValue(java.lang.Object);
          public java.util.Set<K> keySet();
          public java.util.Collection<V> values();
          public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
          public V getOrDefault(java.lang.Object, V);
          public V putIfAbsent(K, V);
          public boolean remove(java.lang.Object, java.lang.Object);
          public boolean replace(K, V, V);
          public V replace(K, V);
          public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
          public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);      
          public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);     
          public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
          public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);   
          public java.lang.Object clone();
          public static <K, V> java.util.HashMap<K, V> newHashMap(int);
        </code></pre>
        </div>
        </details>
        
        
        
        <h1 style="color: rgb(204, 201, 32);">LinkedHashMap</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          LinkedHashMap
        
        
          public class java.util.LinkedHashMap<K, V> extends java.util.HashMap<K, V> implements java.util.Map<K, V> {
            private static final long serialVersionUID;
            transient java.util.LinkedHashMap$Entry<K, V> head;
            transient java.util.LinkedHashMap$Entry<K, V> tail;
            final boolean accessOrder;
            private void linkNodeLast(java.util.LinkedHashMap$Entry<K, V>);
            private void transferLinks(java.util.LinkedHashMap$Entry<K, V>, java.util.LinkedHashMap$Entry<K, V>);
            void reinitialize();
            java.util.HashMap$Node<K, V> newNode(int, K, V, java.util.HashMap$Node<K, V>);
            java.util.HashMap$Node<K, V> replacementNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);
            java.util.HashMap$TreeNode<K, V> newTreeNode(int, K, V, java.util.HashMap$Node<K, V>);  
            java.util.HashMap$TreeNode<K, V> replacementTreeNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);
            void afterNodeRemoval(java.util.HashMap$Node<K, V>);
            void afterNodeInsertion(boolean);
            void afterNodeAccess(java.util.HashMap$Node<K, V>);
            void internalWriteEntries(java.io.ObjectOutputStream) throws java.io.IOException;       
            public java.util.LinkedHashMap(int, float);
            public java.util.LinkedHashMap(int);
            public java.util.LinkedHashMap();
            public java.util.LinkedHashMap(java.util.Map<? extends K, ? extends V>);
            public java.util.LinkedHashMap(int, float, boolean);
            public boolean containsValue(java.lang.Object);
            public V get(java.lang.Object);
            public V getOrDefault(java.lang.Object, V);
            public void clear();
            protected boolean removeEldestEntry(java.util.Map$Entry<K, V>);
            public java.util.Set<K> keySet();
            final <T> T[] keysToArray(T[]);
            final <T> T[] valuesToArray(T[]);
            public java.util.Collection<V> values();
            public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
            public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
            public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
            public static <K, V> java.util.LinkedHashMap<K, V> newLinkedHashMap(int);
        </code></pre>
        </div>
        </details>
        
        
        
        <h1 style="color: rgb(204, 201, 32);">TreeMap</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          
          TREEMAP
          
          public class java.util.TreeMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.NavigableMap<K, V>, java.lang.Cloneable, java.io.Serializable {
          public java.util.TreeMap();
          public java.util.TreeMap(java.util.Comparator<? super K>);
          public java.util.TreeMap(java.util.Map<? extends K, ? extends V>);
          public java.util.TreeMap(java.util.SortedMap<K, ? extends V>);
          public int size();
          public boolean containsKey(java.lang.Object);
          public boolean containsValue(java.lang.Object);
          public V get(java.lang.Object);
          public java.util.Comparator<? super K> comparator();
          public K firstKey();
          public K lastKey();
          public void putAll(java.util.Map<? extends K, ? extends V>);
          public V put(K, V);
          public V putIfAbsent(K, V);
          public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
          public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);      
          public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
          public V remove(java.lang.Object);
          public void clear();
          public java.lang.Object clone();
          public java.util.Map$Entry<K, V> firstEntry();
          public java.util.Map$Entry<K, V> lastEntry();
          public java.util.Map$Entry<K, V> pollFirstEntry();
          public java.util.Map$Entry<K, V> pollLastEntry();
          public java.util.Map$Entry<K, V> lowerEntry(K);
          public K lowerKey(K);
          public java.util.Map$Entry<K, V> floorEntry(K);
          public K floorKey(K);
          public java.util.Map$Entry<K, V> ceilingEntry(K);
          public K ceilingKey(K);
          public java.util.Map$Entry<K, V> higherEntry(K);
          public K higherKey(K);
          public java.util.Set<K> keySet();
          public java.util.NavigableSet<K> navigableKeySet();
          public java.util.NavigableSet<K> descendingKeySet();
          public java.util.Collection<V> values();
          public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
          public java.util.NavigableMap<K, V> descendingMap();
          public java.util.NavigableMap<K, V> subMap(K, boolean, K, boolean);
          public java.util.NavigableMap<K, V> headMap(K, boolean);
          public java.util.NavigableMap<K, V> tailMap(K, boolean);
          public java.util.SortedMap<K, V> subMap(K, K);
          public java.util.SortedMap<K, V> headMap(K);
          public java.util.SortedMap<K, V> tailMap(K);
          public boolean replace(K, V, V);
          public V replace(K, V);
          public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
          public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);   
        </code></pre>
        </div>
        </details>
        
        
        <h1>Map.Entry</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            Map.Entry
        
            public interface java.util.Map<K, V> 
          public abstract int size();
          public abstract boolean isEmpty();
          public abstract boolean containsKey(java.lang.Object);
          public abstract boolean containsValue(java.lang.Object);
          public abstract V get(java.lang.Object);
          public abstract V put(K, V);
          public abstract V remove(java.lang.Object);
          public abstract void putAll(java.util.Map<? extends K, ? extends V>);
          public abstract void clear();
          public abstract java.util.Set<K> keySet();
          public abstract java.util.Collection<V> values();
          public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();
          public abstract boolean equals(java.lang.Object);
          public abstract int hashCode();
          public default V getOrDefault(java.lang.Object, V);
          public default void forEach(java.util.function.BiConsumer<? super K, ? super V>);       
          public default void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public default V putIfAbsent(K, V);
          public default boolean remove(java.lang.Object, java.lang.Object);
          public default boolean replace(K, V, V);
          public default V replace(K, V);
          public default V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
          public default V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public default V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
          public default V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
          public static <K, V> java.util.Map<K, V> of();
          public static <K, V> java.util.Map<K, V> of(K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V);  
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
          public static <K, V> java.util.Map<K, V> ofEntries(java.util.Map$Entry<? extends K, ? extends V>...);
          public static <K, V> java.util.Map$Entry<K, V> entry(K, V);
          public static <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V>);
          </code>
        </pre>
        </div>
        </details>
        
        
        
        <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            Dictionary
        
              public abstract class java.util.Dictionary<K, V> 
              public java.util.Dictionary();
              public abstract int size();
              public abstract boolean isEmpty();
              public abstract java.util.Enumeration<K> keys();
              public abstract java.util.Enumeration<V> elements();
              public abstract V get(java.lang.Object);
              public abstract V put(K, V);
              public abstract V remove(java.lang.Object);
          </code>
        </pre>
        </div>
        </details>
        
        
        
        
        
        
        <h1 style="color: rgb(204, 201, 32);"> HashTable</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          HashTable
        
          public class java.util.Hashtable<K, V> extends java.util.Dictionary<K, V> implements java.util.Map<K, V>, java.lang.Cloneable, java.io.Serializable {
            private transient java.util.Hashtable$Entry<?, ?>[] table;
            private transient int count;
            private int threshold;
            private float loadFactor;
            private transient int modCount;
            private static final long serialVersionUID;
            private static final int MAX_ARRAY_SIZE;
            private volatile transient java.util.Set<K> keySet;
            private volatile transient java.util.Set<java.util.Map$Entry<K, V>> entrySet;
            private volatile transient java.util.Collection<V> values;
            private static final int KEYS;
            private static final int VALUES;
            private static final int ENTRIES;
            public java.util.Hashtable(int, float);
            public java.util.Hashtable(int);
            public java.util.Hashtable();
            public java.util.Hashtable(java.util.Map<? extends K, ? extends V>);
            java.util.Hashtable(java.lang.Void);
            public synchronized int size();
            public synchronized boolean isEmpty();
            public synchronized java.util.Enumeration<K> keys();
            public synchronized java.util.Enumeration< V> elements();
            public synchronized boolean contains(java.lang.Object);
            public boolean containsValue(java.lang.Object);
            public synchronized boolean containsKey(java.lang.Object);
            public synchronized V get(java.lang.Object);
            protected void rehash();
            private void addEntry(int, K, V, int);
            public synchronized V put(K, V);
            public synchronized V remove(java.lang.Object);
            public synchronized void putAll(java.util.Map<? extends K, ? extends V>);
            public synchronized void clear();
            public synchronized java.lang.Object clone();
            final java.util.Hashtable<?, ?> cloneHashtable();
            public synchronized java.lang.String toString();
            private < T> java.util.Enumeration< T> getEnumeration(int);
            private < T> java.util.Iterator< T> getIterator(int);
            public java.util.Set< K> keySet();
            public java.util.Set< java.util.Map$Entry< K, V>> entrySet();
            public java.util.Collection< V> values();
            public synchronized boolean equals(java.lang.Object);
            public synchronized int hashCode();
            public synchronized V getOrDefault(java.lang.Object, V);
            public synchronized void forEach(java.util.function.BiConsumer<? super K, ? super V>);
            public synchronized void replaceAll(java.util.function.BiFunction<? super K, ? super V, 
          ? extends V>);
            public synchronized V putIfAbsent(K, V);
            public synchronized boolean remove(java.lang.Object, java.lang.Object);
            public synchronized boolean replace(K, V, V);
            public synchronized V replace(K, V);
            public synchronized V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
            public synchronized V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
            public synchronized V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
            public synchronized V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? 
          extends V>);
            private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;
            void writeHashtable(java.io.ObjectOutputStream) throws java.io.IOException;
            final void defaultWriteHashtable(java.io.ObjectOutputStream, int, float) throws java.io.IOException;
            private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
            void readHashtable(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
            private void reconstitutionPut(java.util.Hashtable$Entry<?, ?>[], K, V) throws java.io.StreamCorruptedException;
          }
        </code>
        </pre>
        </div>
        </details>
        
        
        <h1>properties</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           properties
        
           public class java.util.Properties extends java.util.Hashtable< java.lang.Object, java.lang.Object> {
            private static final long serialVersionUID;
            private static final jdk.internal.misc.Unsafe UNSAFE;
            protected volatile java.util.Properties defaults;
            private volatile transient java.util.concurrent.ConcurrentHashMap< java.lang.Object, java.lang.Object> map;
            public java.util.Properties();
            public java.util.Properties(int);
            public java.util.Properties(java.util.Properties);
            private java.util.Properties(java.util.Properties, int);
            public synchronized java.lang.Object setProperty(java.lang.String, java.lang.String);   
            public synchronized void load(java.io.Reader) throws java.io.IOException;
            public synchronized void load(java.io.InputStream) throws java.io.IOException;
            private void load0(java.util.Properties$LineReader) throws java.io.IOException;
            private java.lang.String loadConvert(char[], int, int, java.lang.StringBuilder);
            private java.lang.String saveConvert(java.lang.String, boolean, boolean);
            private static void writeComments(java.io.BufferedWriter, java.lang.String) throws java.io.IOException;
            public void save(java.io.OutputStream, java.lang.String);
            public void store(java.io.Writer, java.lang.String) throws java.io.IOException;
            public void store(java.io.OutputStream, java.lang.String) throws java.io.IOException;
            private void store0(java.io.BufferedWriter, java.lang.String, boolean) throws java.io.IOException;
            private static void writeDateComment(java.io.BufferedWriter) throws java.io.IOException;
            public synchronized void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException;
            public void storeToXML(java.io.OutputStream, java.lang.String) throws java.io.IOException;
            public void storeToXML(java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException;
            public void storeToXML(java.io.OutputStream, java.lang.String, java.nio.charset.Charset) throws java.io.IOException;
            public java.lang.String getProperty(java.lang.String);
            public java.lang.String getProperty(java.lang.String, java.lang.String);
            public java.util.Enumeration<?> propertyNames();
            public java.util.Set< java.lang.String> stringPropertyNames();
            public void list(java.io.PrintStream);
            public void list(java.io.PrintWriter);
            private void enumerate(java.util.Map< java.lang.String, java.lang.Object>);
            private void enumerateStringProperties(java.util.Map< java.lang.String, java.lang.String>);
            public int size();
            public boolean isEmpty();
            public java.util.Enumeration< java.lang.Object> keys();
            public java.util.Enumeration< java.lang.Object> elements();
            public boolean contains(java.lang.Object);
            public boolean containsValue(java.lang.Object);
            public boolean containsKey(java.lang.Object);
            public java.lang.Object get(java.lang.Object);
            public synchronized java.lang.Object put(java.lang.Object, java.lang.Object);
            public synchronized java.lang.Object remove(java.lang.Object);
            public synchronized void putAll(java.util.Map<?, ?>);
            public synchronized void clear();
            public synchronized java.lang.String toString();
            public java.util.Set< java.lang.Object> keySet();
            public java.util.Collection< java.lang.Object> values();
            public java.util.Set< java.util.Map$Entry< java.lang.Object, java.lang.Object>> entrySet();
            public synchronized boolean equals(java.lang.Object);
            public synchronized int hashCode();
            public java.lang.Object getOrDefault(java.lang.Object, java.lang.Object);
            public synchronized void forEach(java.util.function.BiConsumer<? super java.lang.Object, ? super java.lang.Object>);
            public synchronized void replaceAll(java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
            public synchronized java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object);   
            public synchronized boolean remove(java.lang.Object, java.lang.Object);
            public synchronized boolean replace(java.lang.Object, java.lang.Object, java.lang.Object);
            public synchronized java.lang.Object replace(java.lang.Object, java.lang.Object);
            public synchronized java.lang.Object computeIfAbsent(java.lang.Object, java.util.function.Function<? super java.lang.Object, ?>);
            public synchronized java.lang.Object computeIfPresent(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
            public synchronized java.lang.Object compute(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
            public synchronized java.lang.Object merge(java.lang.Object, java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
            protected void rehash();
            public synchronized java.lang.Object clone();
            void writeHashtable(java.io.ObjectOutputStream) throws java.io.IOException;
            void readHashtable(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
            static {};
          </code>
        </pre>
        </div>
        </details>
        
        <h1>Iterator</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            Iterator
        
              public interface java.util.Iterator<E> 
              public abstract boolean hasNext();
              public abstract E next();
              public default void remove();
              public default void forEachRemaining(java.util.function.Consumer<? super E>);
          </code>
        </pre>
        </div>
        </details>
        
        <h1>Other Utility Classes:</h1>
        <pre>
          
        Arrays: Provides utility methods for working with arrays, like sorting and searching.
        Date: Represents a specific instant in time.
        Calendar: Provides methods for manipulating dates and times.
        Random: Generates random numbers.
        Scanner: Allows parsing primitive types and strings using regular expressions.
        TimeZone: Represents a time zone offset, and also figures daylight savings.
        </pre>
        
        <h1>Array</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            ARRAYS 
        
          public class java.util.Arrays 
          public static void sort(int[]);
          public static void sort(int[], int, int);
          public static void sort(long[]);
          public static void sort(long[], int, int);
          public static void sort(short[]);
          public static void sort(short[], int, int);
          public static void sort(char[]);
          public static void sort(char[], int, int);
          public static void sort(byte[]);
          public static void sort(byte[], int, int);
          public static void sort(float[]);
          public static void sort(float[], int, int);
          public static void sort(double[]);
          public static void sort(double[], int, int);
          public static void parallelSort(byte[]);
          public static void parallelSort(byte[], int, int);
          public static void parallelSort(char[]);
          public static void parallelSort(char[], int, int);
          public static void parallelSort(short[]);
          public static void parallelSort(short[], int, int);
          public static void parallelSort(int[]);
          public static void parallelSort(int[], int, int);
          public static void parallelSort(long[]);
          public static void parallelSort(long[], int, int);
          public static void parallelSort(float[]);
          public static void parallelSort(float[], int, int);
          public static void parallelSort(double[]);
          public static void parallelSort(double[], int, int);
          public static <T extends java.lang.Comparable<? super T>> void parallelSort(T[]);
          public static <T extends java.lang.Comparable<? super T>> void parallelSort(T[], int, int);
          public static <T> void parallelSort(T[], java.util.Comparator<? super T>);
          public static <T> void parallelSort(T[], int, int, java.util.Comparator<? super T>);
          public static void sort(java.lang.Object[]);
          public static void sort(java.lang.Object[], int, int);
          public static <T> void sort(T[], java.util.Comparator<? super T>);
          public static <T> void sort(T[], int, int, java.util.Comparator<? super T>);
          public static <T> void parallelPrefix(T[], java.util.function.BinaryOperator<T>);
          public static <T> void parallelPrefix(T[], int, int, java.util.function.BinaryOperator<T>);
          public static void parallelPrefix(long[], java.util.function.LongBinaryOperator);
          public static void parallelPrefix(long[], int, int, java.util.function.LongBinaryOperator); 
          public static void parallelPrefix(double[], java.util.function.DoubleBinaryOperator);
          public static void parallelPrefix(double[], int, int, java.util.function.DoubleBinaryOperator);
          public static void parallelPrefix(int[], java.util.function.IntBinaryOperator);
          public static void parallelPrefix(int[], int, int, java.util.function.IntBinaryOperator);   
          public static int binarySearch(long[], long);
          public static int binarySearch(long[], int, int, long);
          public static int binarySearch(int[], int);
          public static int binarySearch(int[], int, int, int);
          public static int binarySearch(short[], short);
          public static int binarySearch(short[], int, int, short);
          public static int binarySearch(char[], char);
          public static int binarySearch(char[], int, int, char);
          public static int binarySearch(byte[], byte);
          public static int binarySearch(byte[], int, int, byte);
          public static int binarySearch(double[], double);
          public static int binarySearch(double[], int, int, double);
          public static int binarySearch(float[], float);
          public static int binarySearch(float[], int, int, float);
          public static int binarySearch(java.lang.Object[], java.lang.Object);
          public static int binarySearch(java.lang.Object[], int, int, java.lang.Object);
          public static <T> int binarySearch(T[], T, java.util.Comparator<? super T>);
          public static <T> int binarySearch(T[], int, int, T, java.util.Comparator<? super T>);      
          public static boolean equals(long[], long[]);
          public static boolean equals(long[], int, int, long[], int, int);
          public static boolean equals(int[], int[]);
          public static boolean equals(int[], int, int, int[], int, int);
          public static boolean equals(short[], short[]);
          public static boolean equals(short[], int, int, short[], int, int);
          public static boolean equals(char[], char[]);
          public static boolean equals(char[], int, int, char[], int, int);
          public static boolean equals(byte[], byte[]);
          public static boolean equals(byte[], int, int, byte[], int, int);
          public static boolean equals(boolean[], boolean[]);
          public static boolean equals(boolean[], int, int, boolean[], int, int);
          public static boolean equals(double[], double[]);
          public static boolean equals(double[], int, int, double[], int, int);
          public static boolean equals(float[], float[]);
          public static boolean equals(float[], int, int, float[], int, int);
          public static boolean equals(java.lang.Object[], java.lang.Object[]);
          public static boolean equals(java.lang.Object[], int, int, java.lang.Object[], int, int);
          public static <T> boolean equals(T[], T[], java.util.Comparator<? super T>);
          public static <T> boolean equals(T[], int, int, T[], int, int, java.util.Comparator<? super T>);
          public static void fill(long[], long);
          public static void fill(long[], int, int, long);
          public static void fill(int[], int);
          public static void fill(int[], int, int, int);
          public static void fill(short[], short);
          public static void fill(short[], int, int, short);
          public static void fill(char[], char);
          public static void fill(char[], int, int, char);
          public static void fill(byte[], byte);
          public static void fill(byte[], int, int, byte);
          public static void fill(boolean[], boolean);
          public static void fill(boolean[], int, int, boolean);
          public static void fill(double[], double);
          public static void fill(double[], int, int, double);
          public static void fill(float[], float);
          public static void fill(float[], int, int, float);
          public static void fill(java.lang.Object[], java.lang.Object);
          public static void fill(java.lang.Object[], int, int, java.lang.Object);
          public static <T> T[] copyOf(T[], int);
          public static <T, U> T[] copyOf(U[], int, java.lang.Class<? extends T[]>);
          public static byte[] copyOf(byte[], int);
          public static short[] copyOf(short[], int);
          public static int[] copyOf(int[], int);
          public static long[] copyOf(long[], int);
          public static char[] copyOf(char[], int);
          public static float[] copyOf(float[], int);
          public static double[] copyOf(double[], int);
          public static boolean[] copyOf(boolean[], int);
          public static <T> T[] copyOfRange(T[], int, int);
          public static <T, U> T[] copyOfRange(U[], int, int, java.lang.Class<? extends T[]>);        
          public static byte[] copyOfRange(byte[], int, int);
          public static short[] copyOfRange(short[], int, int);
          public static int[] copyOfRange(int[], int, int);
          public static long[] copyOfRange(long[], int, int);
          public static char[] copyOfRange(char[], int, int);
          public static float[] copyOfRange(float[], int, int);
          public static double[] copyOfRange(double[], int, int);
          public static boolean[] copyOfRange(boolean[], int, int);
          public static <T> java.util.List<T> asList(T...);
          public static int hashCode(long[]);
          public static int hashCode(int[]);
          public static int hashCode(short[]);
          public static int hashCode(char[]);
          public static int hashCode(byte[]);
          public static int hashCode(boolean[]);
          public static int hashCode(float[]);
          public static int hashCode(double[]);
          public static int hashCode(java.lang.Object[]);
          public static int deepHashCode(java.lang.Object[]);
          public static boolean deepEquals(java.lang.Object[], java.lang.Object[]);
          public static java.lang.String toString(long[]);
          public static java.lang.String toString(int[]);
          public static java.lang.String toString(short[]);
          public static java.lang.String toString(char[]);
          public static java.lang.String toString(byte[]);
          public static java.lang.String toString(boolean[]);
          public static java.lang.String toString(float[]);
          public static java.lang.String toString(double[]);
          public static java.lang.String toString(java.lang.Object[]);
          public static java.lang.String deepToString(java.lang.Object[]);
          public static <T> void setAll(T[], java.util.function.IntFunction<? extends T>);
          public static <T> void parallelSetAll(T[], java.util.function.IntFunction<? extends T>);    
          public static void setAll(int[], java.util.function.IntUnaryOperator);
          public static void parallelSetAll(int[], java.util.function.IntUnaryOperator);
          public static void setAll(long[], java.util.function.IntToLongFunction);
          public static void parallelSetAll(long[], java.util.function.IntToLongFunction);
          public static void setAll(double[], java.util.function.IntToDoubleFunction);
          public static void parallelSetAll(double[], java.util.function.IntToDoubleFunction);
          public static <T> java.util.Spliterator<T> spliterator(T[]);
          public static <T> java.util.Spliterator<T> spliterator(T[], int, int);
          public static java.util.Spliterator$OfInt spliterator(int[]);
          public static java.util.Spliterator$OfInt spliterator(int[], int, int);
          public static java.util.Spliterator$OfLong spliterator(long[]);
          public static java.util.Spliterator$OfLong spliterator(long[], int, int);
          public static java.util.Spliterator$OfDouble spliterator(double[]);
          public static java.util.Spliterator$OfDouble spliterator(double[], int, int);
          public static <T> java.util.stream.Stream<T> stream(T[]);
          public static <T> java.util.stream.Stream<T> stream(T[], int, int);
          public static java.util.stream.IntStream stream(int[]);
          public static java.util.stream.IntStream stream(int[], int, int);
          public static java.util.stream.LongStream stream(long[]);
          public static java.util.stream.LongStream stream(long[], int, int);
          public static java.util.stream.DoubleStream stream(double[]);
          public static java.util.stream.DoubleStream stream(double[], int, int);
          public static int compare(boolean[], boolean[]);
          public static int compare(boolean[], int, int, boolean[], int, int);
          public static int compare(byte[], byte[]);
          public static int compare(byte[], int, int, byte[], int, int);
          public static int compareUnsigned(byte[], byte[]);
          public static int compareUnsigned(byte[], int, int, byte[], int, int);
          public static int compare(short[], short[]);
          public static int compare(short[], int, int, short[], int, int);
          public static int compareUnsigned(short[], short[]);
          public static int compareUnsigned(short[], int, int, short[], int, int);
          public static int compare(char[], char[]);
          public static int compare(char[], int, int, char[], int, int);
          public static int compare(int[], int[]);
          public static int compare(int[], int, int, int[], int, int);
          public static int compareUnsigned(int[], int[]);
          public static int compareUnsigned(int[], int, int, int[], int, int);
          public static int compare(long[], long[]);
          public static int compare(long[], int, int, long[], int, int);
          public static int compareUnsigned(long[], long[]);
          public static int compareUnsigned(long[], int, int, long[], int, int);
          public static int compare(float[], float[]);
          public static int compare(float[], int, int, float[], int, int);
          public static int compare(double[], double[]);
          public static int compare(double[], int, int, double[], int, int);
          public static <T extends java.lang.Comparable<? super T>> int compare(T[], T[]);
          public static <T extends java.lang.Comparable<? super T>> int compare(T[], int, int, T[], int, int);
          public static <T> int compare(T[], T[], java.util.Comparator<? super T>);
          public static <T> int compare(T[], int, int, T[], int, int, java.util.Comparator<? super T>);
          public static int mismatch(boolean[], boolean[]);
          public static int mismatch(boolean[], int, int, boolean[], int, int);
          public static int mismatch(byte[], byte[]);
          public static int mismatch(byte[], int, int, byte[], int, int);
          public static int mismatch(char[], char[]);
          public static int mismatch(short[], short[]);
          public static int mismatch(short[], int, int, short[], int, int);
          public static int mismatch(int[], int[]);
          public static int mismatch(int[], int, int, int[], int, int);
          public static int mismatch(long[], long[]);
          public static int mismatch(int[], int, int, int[], int, int);
          public static int mismatch(long[], long[]);
          public static int mismatch(float[], float[]);
          public static int mismatch(float[], int, int, float[], int, int);
          public static int mismatch(double[], double[]);
          public static int mismatch(double[], int, int, double[], int, int);
          public static int mismatch(java.lang.Object[], java.lang.Object[]);
          public static int mismatch(java.lang.Object[], int, int, java.lang.Object[], int, int);     
          public static <T> int mismatch(T[], T[], java.util.Comparator<? super T>);
          public static <T> int mismatch(T[], int, int, T[], int, int, java.util.Comparator<? super T>
          </code>
        </pre>
        </div>
        </details>
        
        <h1>Date</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            Date
        
            public class java.util.Date implements java.io.Serializable, java.lang.Cloneable, java.lang.Comparable<java.util.Date> {
              private static final sun.util.calendar.BaseCalendar gcal;
              private static sun.util.calendar.BaseCalendar jcal;
              private transient long fastTime;
              private transient sun.util.calendar.BaseCalendar$Date cdate;
              private static int defaultCenturyStart;
              private static final long serialVersionUID;
              private static final java.lang.String[] wtb;
              private static final int[] ttb;
              public java.util.Date();
              public java.util.Date(long);
              public java.util.Date(int, int, int);
              public java.util.Date(int, int, int, int, int);
              public java.util.Date(int, int, int, int, int, int);
              public java.util.Date(java.lang.String);
              public java.lang.Object clone();
              public static long UTC(int, int, int, int, int, int);
              public static long parse(java.lang.String);
              public int getYear();
              public void setYear(int);
              public int getMonth();
              public void setMonth(int);
              public int getDate();
              public void setDate(int);
              public int getDay();
              public int getHours();
              public void setHours(int);
              public int getMinutes();
              public void setMinutes(int);
              public int getSeconds();
              public void setSeconds(int);
              public long getTime();
              private final long getTimeImpl();
              public void setTime(long);
              public boolean before(java.util.Date);
              public boolean after(java.util.Date);
              public boolean equals(java.lang.Object);
              static final long getMillisOf(java.util.Date);
              public int compareTo(java.util.Date);
              public int hashCode();
              public java.lang.String toString();
              private static final java.lang.StringBuilder convertToAbbr(java.lang.StringBuilder, java.lang.String);
              public java.lang.String toLocaleString();
              public java.lang.String toGMTString();
              public int getTimezoneOffset();
              private final sun.util.calendar.BaseCalendar$Date getCalendarDate();
              private final sun.util.calendar.BaseCalendar$Date normalize();
              private final sun.util.calendar.BaseCalendar$Date normalize(sun.util.calendar.BaseCalendar$Date);
              private static final sun.util.calendar.BaseCalendar getCalendarSystem(int);
              private static final sun.util.calendar.BaseCalendar getCalendarSystem(long);
              private static final sun.util.calendar.BaseCalendar getCalendarSystem(sun.util.calendar.BaseCalendar$Date);
              private static final synchronized sun.util.calendar.BaseCalendar getJulianCalendar();   
              private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;        
              private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
              public static java.util.Date from(java.time.Instant);
              public java.time.Instant toInstant();
              public int compareTo(java.lang.Object);
              static {};
          </code>
        </pre>
        </div>
        </details>
        
        <h1>Random</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            Random
            
            public class java.util.Random implements java.util.random.RandomGenerator,java.io.Serializable 
              static final long serialVersionUID;
              private final java.util.concurrent.atomic.AtomicLong seed;
              private static final long multiplier;
              private static final long addend;
              private static final long mask;
              private static final double DOUBLE_UNIT;
              private static final float FLOAT_UNIT;
              private static final java.util.concurrent.atomic.AtomicLong seedUniquifier;
              private double nextNextGaussian;
              private boolean haveNextNextGaussian;
              private static final java.io.ObjectStreamField[] serialPersistentFields;
              private static final jdk.internal.misc.Unsafe unsafe;
              private static final long seedOffset;
              public java.util.Random();
              private java.util.Random(java.lang.Void);
              private static long seedUniquifier();
              public java.util.Random(long);
              private static long initialScramble(long);
              public static java.util.Random from(java.util.random.RandomGenerator);
              public synchronized void setSeed(long);
              protected int next(int);
              public void nextBytes(byte[]);
              public int nextInt();
              public int nextInt(int);
              public long nextLong();
              public boolean nextBoolean();
              public float nextFloat();
              public double nextDouble();
              public synchronized double nextGaussian();
              private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
              private synchronized void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;
              private void resetSeed(long);
              public java.util.stream.IntStream ints(long);
              public java.util.stream.IntStream ints();
              public java.util.stream.IntStream ints(long, int, int);
              public java.util.stream.IntStream ints(int, int);
              public java.util.stream.LongStream longs(long);
              public java.util.stream.LongStream longs();
              public java.util.stream.LongStream longs(long, long, long);
              public java.util.stream.LongStream longs(long, long);
              public java.util.stream.DoubleStream doubles(long);
              public java.util.stream.DoubleStream doubles();
              public java.util.stream.DoubleStream doubles(long, double, double);
              public java.util.stream.DoubleStream doubles(double, double);
              static {};
          </code>
        </pre>
        </div>
        </details>
        
        
        
        
        <h1>Scanner</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            Scanner
        
            public final class java.util.Scanner implements java.util.Iterator<java.lang.String>, java.io.Closeable {
              private java.nio.CharBuffer buf;
              private static final int BUFFER_SIZE;
              private int position;
              private java.util.regex.Matcher matcher;
              private java.util.regex.Pattern delimPattern;
              private java.util.regex.Pattern hasNextPattern;
              private int hasNextPosition;
              private java.lang.String hasNextResult;
              private java.lang.Readable source;
              private boolean sourceClosed;
              private boolean needInput;
              private boolean skipped;
              private int savedScannerPosition;
              private java.lang.Object typeCache;
              private boolean matchValid;
              private boolean closed;
              private int radix;
              private int defaultRadix;
              private java.util.Locale locale;
              private java.util.Scanner$PatternLRUCache patternCache;
              private java.io.IOException lastException;
              int modCount;
              private static java.util.regex.Pattern WHITESPACE_PATTERN;
              private static java.util.regex.Pattern FIND_ANY_PATTERN;
              private static java.util.regex.Pattern NON_ASCII_DIGIT;
              private java.lang.String groupSeparator;
              private java.lang.String decimalSeparator;
              private java.lang.String nanString;
              private java.lang.String infinityString;
              private java.lang.String positivePrefix;
              private java.lang.String negativePrefix;
              private java.lang.String positiveSuffix;
              private java.lang.String negativeSuffix;
              private static volatile java.util.regex.Pattern boolPattern;
              private static final java.lang.String BOOLEAN_PATTERN;
              private java.util.regex.Pattern integerPattern;
              private java.lang.String digits;
              private java.lang.String non0Digit;
              private int SIMPLE_GROUP_INDEX;
              private static volatile java.util.regex.Pattern separatorPattern;
              private static volatile java.util.regex.Pattern linePattern;
              private static final java.lang.String LINE_SEPARATOR_PATTERN;
              private static final java.lang.String LINE_PATTERN;
              private java.util.regex.Pattern floatPattern;
              private java.util.regex.Pattern decimalPattern;
              static final boolean $assertionsDisabled;
              private static java.util.regex.Pattern boolPattern();
              private java.lang.String buildIntegerPatternString();
              private java.util.regex.Pattern integerPattern();
              private static java.util.regex.Pattern separatorPattern();
              private static java.util.regex.Pattern linePattern();
              private void buildFloatAndDecimalPattern();
              private java.util.regex.Pattern floatPattern();
              private java.util.regex.Pattern decimalPattern();
              private java.util.Scanner(java.lang.Readable, java.util.regex.Pattern);
              public java.util.Scanner(java.lang.Readable);
              public java.util.Scanner(java.io.InputStream);
              public java.util.Scanner(java.io.InputStream, java.lang.String);
              public java.util.Scanner(java.io.InputStream, java.nio.charset.Charset);
              private static java.nio.charset.Charset toCharset(java.lang.String);
              private static java.lang.Readable makeReadable(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
              private static java.lang.Readable makeReadable(java.io.InputStream, java.nio.charset.Charset);
              public java.util.Scanner(java.io.File) throws java.io.FileNotFoundException;
              public java.util.Scanner(java.io.File, java.lang.String) throws java.io.FileNotFoundException;
              public java.util.Scanner(java.io.File, java.nio.charset.Charset) throws java.io.IOException;
              private java.util.Scanner(java.io.File, java.nio.charset.CharsetDecoder) throws java.io.FileNotFoundException;
              private static java.nio.charset.CharsetDecoder toDecoder(java.lang.String);
              private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel, java.nio.charset.CharsetDecoder);
              private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel, java.nio.charset.Charset);
              public java.util.Scanner(java.nio.file.Path) throws java.io.IOException;
              public java.util.Scanner(java.nio.file.Path, java.lang.String) throws java.io.IOException;
              public java.util.Scanner(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
              public java.util.Scanner(java.lang.String);
              public java.util.Scanner(java.nio.channels.ReadableByteChannel);
              private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel);
              public java.util.Scanner(java.nio.channels.ReadableByteChannel, java.lang.String);      
              public java.util.Scanner(java.nio.channels.ReadableByteChannel, java.nio.charset.Charset);
              private void saveState();
              private void revertState();
              private boolean revertState(boolean);
              private void cacheResult();
              private void cacheResult(java.lang.String);
              private void clearCaches();
              private java.lang.String getCachedResult();
              private void useTypeCache();
              private void readInput();
              private boolean makeSpace();
              private void translateSavedIndexes(int);
              private void throwFor();
              private boolean hasTokenInBuffer();
              private java.lang.String getCompleteTokenInBuffer(java.util.regex.Pattern);
              private boolean findPatternInBuffer(java.util.regex.Pattern, int);
              private boolean matchPatternInBuffer(java.util.regex.Pattern);
              private void ensureOpen();
              public void close();
              public java.io.IOException ioException();
              public java.util.regex.Pattern delimiter();
              public java.util.Scanner useDelimiter(java.util.regex.Pattern);
              public java.util.Scanner useDelimiter(java.lang.String);
              public java.util.Locale locale();
              public java.util.Scanner useLocale(java.util.Locale);
              public int radix();
              public java.util.Scanner useRadix(int);
              private void setRadix(int);
              public java.util.regex.MatchResult match();
              public java.lang.String toString();
              public boolean hasNext();
              public java.lang.String next();
              public void remove();
              public boolean hasNext(java.lang.String);
              public java.lang.String next(java.lang.String);
              public boolean hasNext(java.util.regex.Pattern);
              public java.lang.String next(java.util.regex.Pattern);
              public boolean hasNextLine();
              public java.lang.String nextLine();
              public java.lang.String findInLine(java.lang.String);
              public java.lang.String findInLine(java.util.regex.Pattern);
              public java.lang.String findWithinHorizon(java.lang.String, int);
              public java.lang.String findWithinHorizon(java.util.regex.Pattern, int);
              public java.util.Scanner skip(java.util.regex.Pattern);
              public java.util.Scanner skip(java.lang.String);
              public boolean hasNextBoolean();
              public boolean nextBoolean();
              public boolean hasNextByte();
              public boolean hasNextByte(int);
              public byte nextByte();
              public byte nextByte(int);
              public boolean hasNextShort();
              public boolean hasNextShort(int);
              public short nextShort();
              public short nextShort(int);
              public boolean hasNextInt();
              public boolean hasNextInt(int);
              private java.lang.String processIntegerToken(java.lang.String);
              public int nextInt();
              public int nextInt(int);
              public boolean hasNextLong();
              public boolean hasNextLong(int);
              public long nextLong();
              public long nextLong(int);
              private java.lang.String processFloatToken(java.lang.String);
              public boolean hasNextFloat();
              public float nextFloat();
              public boolean hasNextDouble();
              public double nextDouble();
              public boolean hasNextBigInteger();
              public boolean hasNextBigInteger(int);
              public java.math.BigInteger nextBigInteger();
              public java.math.BigInteger nextBigInteger(int);
              public boolean hasNextBigDecimal();
              public java.math.BigDecimal nextBigDecimal();
              public java.util.Scanner reset();
              public java.util.stream.Stream<java.lang.String> tokens();
              public java.util.stream.Stream<java.util.regex.MatchResult> findAll(java.util.regex.Pattern);
              public java.util.stream.Stream<java.util.regex.MatchResult> findAll(java.lang.String);  
              public java.lang.Object next();
              static {};
        
          </code>
        </pre>
        </div>
        </details>
        
        
        <h1>TimeZone:</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
            public abstract class java.util.TimeZone implements java.io.Serializable,java.lang.Cloneable {
              public static final int SHORT;
              public static final int LONG;
              private static final int ONE_MINUTE;
              private static final int ONE_HOUR;
              private static final int ONE_DAY;
              static final long serialVersionUID;
              static final java.util.TimeZone NO_TIMEZONE;
              private java.lang.String ID;
              private transient java.time.ZoneId zoneId;
              private static volatile java.util.TimeZone defaultTimeZone;
              static final java.lang.String GMT_ID;
              private static final int GMT_ID_LENGTH;
              static final boolean $assertionsDisabled;
              public java.util.TimeZone();
              public abstract int getOffset(int, int, int, int, int, int);
              public int getOffset(long);
              int getOffsets(long, int[]);
              public abstract void setRawOffset(int);
              public abstract int getRawOffset();
              public java.lang.String getID();
              public void setID(java.lang.String);
              public final java.lang.String getDisplayName();
              public final java.lang.String getDisplayName(java.util.Locale);
              public final java.lang.String getDisplayName(boolean, int);
              public java.lang.String getDisplayName(boolean, int, java.util.Locale);
              private static java.lang.String[] getDisplayNames(java.lang.String, java.util.Locale);
              public int getDSTSavings();
              public abstract boolean useDaylightTime();
              public boolean observesDaylightTime();
              public abstract boolean inDaylightTime(java.util.Date);
              public static synchronized java.util.TimeZone getTimeZone(java.lang.String);
              public static java.util.TimeZone getTimeZone(java.time.ZoneId);
              public java.time.ZoneId toZoneId();
              private java.time.ZoneId toZoneId0();
              private static java.util.TimeZone getTimeZone(java.lang.String, boolean);
              public static synchronized java.lang.String[] getAvailableIDs(int);
              public static synchronized java.lang.String[] getAvailableIDs();
              private static native java.lang.String getSystemTimeZoneID(java.lang.String);
              private static native java.lang.String getSystemGMTOffsetID();
              public static java.util.TimeZone getDefault();
              static java.util.TimeZone getDefaultRef();
              private static synchronized java.util.TimeZone setDefaultZone();
              public static void setDefault(java.util.TimeZone);
              public boolean hasSameRules(java.util.TimeZone);
              public java.lang.Object clone();
              private static final java.util.TimeZone parseCustomTimeZone(java.lang.String);
              static {};
        
          </code>
        </pre>
        </div>
        </details>
        
        
        
        <div class="Topic" id="io"> 
        <br><br>
          <h1 style="color:white">Input/Output Operations</h1> </div>
        <div class="io">
          <br><br>
        
          <h1>java.io</h1>
          <pre>
          Classes:
          File: Represents a file or directory pathname.
          FileInputStream: Reads data from a file as a stream of bytes.
          FileOutputStream: Writes data to a file as a stream of bytes.
          BufferedInputStream: Adds buffering to an input stream to improve efficiency.
          BufferedOutputStream: Adds buffering to an output stream to improve efficiency.
          ObjectInputStream: Reads objects from an input stream.
          ObjectOutputStream: Writes objects to an output stream.
          FileReader: Reads character files.
          FileWriter: Writes character files.
          BufferedReader: Reads text from a character-input stream with buffering.
          BufferedWriter: Writes text to a character-output stream with buffering.
          PrintStream: Provides methods to print data values as text.
          PrintWriter: Provides methods to print formatted text.
          DataInputStream: Reads primitive data types from an input stream.
          DataOutputStream: Writes primitive data types to an output stream.
          PipedInputStream: Implements piped input streams.
          PipedOutputStream: Implements piped output streams.
          CharArrayReader: Reads characters from an in-memory character array.
          CharArrayWriter: Writes characters to an in-memory character array.
          StringBufferInputStream: Reads from a StringBuffer as if it were an input stream (deprecated).
          StringReader: Reads characters from a string.
          StringWriter: Writes characters to a string.
          
          Interfaces:
          Serializable: Marker interface that indicates a class is serializable, allowing objects of the class to be converted to a byte stream.
          Externalizable: Interface that provides custom serialization and deserialization logic.
          </pre>
        
          
          
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        
        
        <div class="Topic"  id="network"> 
          <br><br>
          <h1 style="color:white">Networking</h1> </div>
        
        <div class="network">
          <br><br>
          <h1>  java.net</h1>
          <pre>
            Classes:
            URL: Represents a Uniform Resource Locator, used to specify the location of a resource on the web.
            URLConnection: Represents a connection to a URL for reading or writing data.
            URLConnection: Represents a connection to a URL for reading or writing data.
            URLDecoder: Decodes a URL-encoded string into a regular string.
            URLEncoder: Encodes a string into a URL-encoded format.
            URI: Represents a Uniform Resource Identifier, used to identify resources.
            InetAddress: Represents an IP address.
            Socket: Represents a client-side socket that communicates with a server over the network.
            ServerSocket: Represents a server-side socket that listens for incoming client connections.
            SocketException: Represents an exception related to sockets.
            MulticastSocket: Represents a socket for sending and receiving multicast packets.
            DatagramSocket: Represents a socket for sending and receiving datagram packets.
            DatagramPacket: Represents a packet of data to be sent via DatagramSocket.
            Proxy: Represents a proxy server.
            URLConnection: Represents a connection to a URL for reading or writing data.
            URLStreamHandler: Provides a mechanism for creating a custom protocol handler for URLs.
            CookieManager: Manages storage, retrieval, and policy for HTTP cookies.
            HttpURLConnection: Provides HTTP-specific functionality for URLConnection.
            SocketTimeoutException: Indicates a timeout while connecting to a socket.
            
            Interfaces:
            URLStreamHandlerFactory: Allows applications to specify a factory for creating protocol handlers.
            CookieStore: Represents a storage for cookies.
            CookiePolicy: Represents a strategy for determining the policy to accept and reject cookies.
            FileNameMap: Maps between a file extension and a MIME type.
            SocketImplFactory: Factory for creating socket implementation objects.
            
          </pre>
        
          
          
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        <div class="Topic"  id="Concurrency"> 
          <br><br>
          <h1 style="color:white">MultiThreading|Concurrency </h1> </div>
        
        <div class="Concurrency">
          <br><br>
          <h1> java.util.concurrent</h1>
        
          <pre>
        java.util.concurrent
        
        Classes:
        Executor: An interface for objects that execute submitted Runnable tasks.
        ExecutorService: A subinterface of Executor that provides a more complete framework for managing asynchronous tasks and their results.
        Executors: A utility class that provides factory methods for creating different types of thread pools.
        ScheduledExecutorService: A subinterface of ExecutorService that supports scheduling tasks for future execution.
        ScheduledThreadPoolExecutor: A class that extends ThreadPoolExecutor and provides support for delayed and periodic task execution.
        Future: An interface representing the result of an asynchronous computation.
        FutureTask: A class that implements RunnableFuture, providing a convenient way to wrap a Callable or Runnable task for asynchronous execution.
        CompletableFuture: A class that represents a computation that may not have completed yet, allowing further processing when the computation is done.
        CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.
        CyclicBarrier: A synchronization aid that allows a set of threads to wait until they reach a common barrier point.
        Semaphore: A synchronization aid that restricts the number of threads that can access a resource concurrently.
        Exchanger: A synchronization point at which threads can pair and swap elements.
        BlockingQueue: An interface representing a queue that supports operations for waiting until space is available or an element is available for removal.
        LinkedBlockingQueue: An implementation of BlockingQueue with linked nodes.
        ArrayBlockingQueue: An implementation of BlockingQueue with an array.
        PriorityBlockingQueue: An implementation of BlockingQueue that uses a priority heap.
        DelayQueue: An implementation of BlockingQueue where elements are taken only after a specified delay.
        SynchronousQueue: An implementation of BlockingQueue that acts as a simple channel between producers and consumers.
        TransferQueue: An extension of BlockingQueue that supports the transfer of elements between producers and consumers.
        Phaser: A reusable synchronization barrier, similar to CountDownLatch and CyclicBarrier, but more flexible.
        CompletableFuture: A class that represents a computation that may not have completed yet, allowing further processing when the computation is done.
        
        
        Interfaces:
        RunnableFuture: An extension of Runnable that represents a Runnable with a result.
        Callable: An interface representing a task that returns a result and may throw an exception.
        FutureTask: An implementation of both RunnableFuture and Future.
          </pre>
          <h1>java.lang.Thread</h1>
          <pre>
            public class java.lang.Thread implements java.lang.Runnable 
              private long eetop;
              private final long tid;
              private volatile java.lang.String name;
              volatile boolean interrupted;
              private volatile java.lang.ClassLoader contextClassLoader;
              private java.security.AccessControlContext inheritedAccessControlContext;
              private final java.lang.Thread$FieldHolder holder;
              java.lang.ThreadLocal$ThreadLocalMap threadLocals;
              java.lang.ThreadLocal$ThreadLocalMap inheritableThreadLocals;
              private java.lang.Object scopedValueBindings;
              private static final java.lang.Object NEW_THREAD_BINDINGS;
              final java.lang.Object interruptLock;
              private volatile java.lang.Object parkBlocker;
              volatile sun.nio.ch.Interruptible nioBlocker;
              public static final int MIN_PRIORITY;
              public static final int NORM_PRIORITY;
              public static final int MAX_PRIORITY;
              private jdk.internal.vm.Continuation cont;
              static final int NO_THREAD_LOCALS;
              static final int NO_INHERIT_THREAD_LOCALS;
              private static final java.lang.StackTraceElement[] EMPTY_STACK_TRACE;
              private volatile java.lang.Thread$UncaughtExceptionHandler uncaughtExceptionHandler;
              private static volatile java.lang.Thread$UncaughtExceptionHandler defaultUncaughtExceptionHandler;
              long threadLocalRandomSeed;
              int threadLocalRandomProbe;
              int threadLocalRandomSecondarySeed;
              private volatile jdk.internal.vm.ThreadContainer container;
              private volatile jdk.internal.vm.StackableScope headStackableScopes;
              private static native void registerNatives();
              static java.lang.Object scopedValueBindings();
              static void setScopedValueBindings(java.lang.Object);
              static native java.lang.Object findScopedValueBindings();
              void inheritScopedValueBindings(jdk.internal.vm.ThreadContainer);
              static void blockedOn(sun.nio.ch.Interruptible);
              jdk.internal.vm.Continuation getContinuation();
              void setContinuation(jdk.internal.vm.Continuation);
              static native java.lang.Thread currentCarrierThread();
              public static native java.lang.Thread currentThread();
              native void setCurrentThread(java.lang.Thread);
              static native java.lang.Object[] scopedValueCache();
              static native void setScopedValueCache(java.lang.Object[]);
              static native void ensureMaterializedForStackWalk(java.lang.Object);
              public static void yield();
              private static native void yield0();
              public static void sleep(long) throws java.lang.InterruptedException;
              private static native void sleep0(long) throws java.lang.InterruptedException;
              public static void sleep(long, int) throws java.lang.InterruptedException;
              public static void sleep(java.time.Duration) throws java.lang.InterruptedException;     
              public static void onSpinWait();
              private static java.lang.ClassLoader contextClassLoader(java.lang.Thread);
              java.lang.Thread(java.lang.ThreadGroup, java.lang.String, int, java.lang.Runnable, long, java.security.AccessControlContext);
              java.lang.Thread(java.lang.String, int, boolean);
              public static java.lang.Thread$Builder$OfPlatform ofPlatform();
              public static java.lang.Thread$Builder$OfVirtual ofVirtual();
              protected java.lang.Object clone() throws java.lang.CloneNotSupportedException;
              static java.lang.String genThreadName();
              private static java.lang.String checkName(java.lang.String);
              public java.lang.Thread();
              public java.lang.Thread(java.lang.Runnable);
              java.lang.Thread(java.lang.Runnable, java.security.AccessControlContext);
              public java.lang.Thread(java.lang.ThreadGroup, java.lang.Runnable);
              public java.lang.Thread(java.lang.String);
              public java.lang.Thread(java.lang.ThreadGroup, java.lang.String);
              public java.lang.Thread(java.lang.Runnable, java.lang.String);
              public java.lang.Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String);   
              public java.lang.Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long);
              public java.lang.Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long, boolean);
              public static java.lang.Thread startVirtualThread(java.lang.Runnable);
              public final boolean isVirtual();
              public void start();
              void start(jdk.internal.vm.ThreadContainer);
              private native void start0();
              public void run();
              private void runWith(java.lang.Object, java.lang.Runnable);
              void clearReferences();
              private void exit();
              public final void stop();
              public void interrupt();
              public static boolean interrupted();
              public boolean isInterrupted();
              final void setInterrupt();
              final void clearInterrupt();
              boolean getAndClearInterrupt();
              public final boolean isAlive();
              boolean alive();
              private native boolean isAlive0();
              public final void suspend();
              public final void resume();
              public final void setPriority(int);
              void priority(int);
              public final int getPriority();
              public final synchronized void setName(java.lang.String);
              public final java.lang.String getName();
              public final java.lang.ThreadGroup getThreadGroup();
              public static int activeCount();
              public static int enumerate(java.lang.Thread[]);
              public int countStackFrames();
              public final void join(long) throws java.lang.InterruptedException;
              public final void join(long, int) throws java.lang.InterruptedException;
              public final void join() throws java.lang.InterruptedException;
              public final boolean join(java.time.Duration) throws java.lang.InterruptedException;
              public static void dumpStack();
              public final void setDaemon(boolean);
              void daemon(boolean);
              public final boolean isDaemon();
              public final void checkAccess();
              public java.lang.String toString();
              public java.lang.ClassLoader getContextClassLoader();
              public void setContextClassLoader(java.lang.ClassLoader);
              private static boolean isSupportedClassLoader(java.lang.ClassLoader);
              public static native boolean holdsLock(java.lang.Object);
              public java.lang.StackTraceElement[] getStackTrace();
              java.lang.StackTraceElement[] asyncGetStackTrace();
              private native java.lang.Object getStackTrace0();
              public static java.util.Map<java.lang.Thread, java.lang.StackTraceElement[]> getAllStackTraces();
              private static boolean isCCLOverridden(java.lang.Class<?>);
              private static boolean auditSubclass(java.lang.Class<?>);
              static java.lang.Thread[] getAllThreads();
              private static native java.lang.StackTraceElement[][] dumpThreads(java.lang.Thread[]);
              private static native java.lang.Thread[] getThreads();
              public long getId();
              public final long threadId();
              public java.lang.Thread$State getState();
              java.lang.Thread$State threadState();
              boolean isTerminated();
              public static void setDefaultUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler);
              public static java.lang.Thread$UncaughtExceptionHandler getDefaultUncaughtExceptionHandler();
              public java.lang.Thread$UncaughtExceptionHandler getUncaughtExceptionHandler();
              public void setUncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler);
              void uncaughtExceptionHandler(java.lang.Thread$UncaughtExceptionHandler);
              void dispatchUncaughtException(java.lang.Throwable);
              static java.lang.ThreadGroup virtualThreadGroup();
              jdk.internal.vm.ThreadContainer threadContainer();
              void setThreadContainer(jdk.internal.vm.ThreadContainer);
              jdk.internal.vm.StackableScope headStackableScopes();
              static void setHeadStackableScope(jdk.internal.vm.StackableScope);
              private native void setPriority0(int);
              private native void interrupt0();
              private static native void clearInterruptEvent();
              private native void setNativeName(java.lang.String);
              private static native long getNextThreadIdOffset();
              private static java.lang.Thread[] lambda$getAllThreads$0(int);
              static {};
            
          </pre>
        
          
          
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        <h1>java.lang.Runnable</h1>
        <pre>
          public interface java.lang.Runnable {
            public abstract void run();
          }
        </pre>
        
          
        <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        
        
        <h1>java.util.concurrent.Executor</h1>
        <pre>
          public interface java.util.concurrent.Executor {
            public abstract void execute(java.lang.Runnable);
          }
        </pre>
        
          
        <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        
        <h1>java.util.concurrent.ExecutorService</h1>
        <pre>
          public interface java.util.concurrent.ExecutorService extends java.util.concurrent.Executor,java.lang.AutoCloseable {
            public abstract void shutdown();
            public abstract java.util.List<java.lang.Runnable> shutdownNow();
            public abstract boolean isShutdown();
            public abstract boolean isTerminated();
            public abstract boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;
            public abstract <T> java.util.concurrent.Future<T> submit(java.util.concurrent.Callable<T>);
            public abstract <T> java.util.concurrent.Future<T> submit(java.lang.Runnable, T);
            public abstract java.util.concurrent.Future<?> submit(java.lang.Runnable);
            public abstract <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.lang.InterruptedException;
            public abstract <T> java.util.List<java.util.concurrent.Future<T>> invokeAll(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;      
            public abstract <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException;
            public abstract <T> T invokeAny(java.util.Collection<? extends java.util.concurrent.Callable<T>>, long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException;
            public default void close();
          }
        </pre>
        
          
        <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        
        <h1>java.util.concurrent.ThreadPoolExecutor</h1>
        <pre>
          public class java.util.concurrent.ThreadPoolExecutor extends java.util.concurrent.AbstractExecutorService {
            private final java.util.concurrent.atomic.AtomicInteger ctl;
            private static final int COUNT_BITS;
            private static final int COUNT_MASK;
            private static final int RUNNING;
            private static final int SHUTDOWN;
            private static final int STOP;
            private static final int TIDYING;
            private static final int TERMINATED;
            private final java.util.concurrent.BlockingQueue<java.lang.Runnable> workQueue;
            private final java.util.concurrent.locks.ReentrantLock mainLock;
            private final java.util.HashSet<java.util.concurrent.ThreadPoolExecutor$Worker> workers;
            private final java.util.concurrent.locks.Condition termination;
            private final jdk.internal.vm.SharedThreadContainer container;
            private int largestPoolSize;
            private long completedTaskCount;
            private volatile java.util.concurrent.ThreadFactory threadFactory;
            private volatile java.util.concurrent.RejectedExecutionHandler handler;
            private volatile long keepAliveTime;
            private volatile boolean allowCoreThreadTimeOut;
            private volatile int corePoolSize;
            private volatile int maximumPoolSize;
            private static final java.util.concurrent.RejectedExecutionHandler defaultHandler;
            private static final java.lang.RuntimePermission shutdownPerm;
            private static final boolean ONLY_ONE;
            private static int runStateOf(int);
            private static int workerCountOf(int);
            private static int ctlOf(int, int);
            private static boolean runStateLessThan(int, int);
            private static boolean runStateAtLeast(int, int);
            private static boolean isRunning(int);
            private boolean compareAndIncrementWorkerCount(int);
            private boolean compareAndDecrementWorkerCount(int);
            private void decrementWorkerCount();
            private void advanceRunState(int);
            final void tryTerminate();
            private void checkShutdownAccess();
            private void interruptWorkers();
            private void interruptIdleWorkers(boolean);
            private void interruptIdleWorkers();
            final void reject(java.lang.Runnable);
            void onShutdown();
            private java.util.List<java.lang.Runnable> drainQueue();
            private boolean addWorker(java.lang.Runnable, boolean);
            private void addWorkerFailed(java.util.concurrent.ThreadPoolExecutor$Worker);
            private void processWorkerExit(java.util.concurrent.ThreadPoolExecutor$Worker, boolean);
            private java.lang.Runnable getTask();
            final void runWorker(java.util.concurrent.ThreadPoolExecutor$Worker);
            public java.util.concurrent.ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>);
            public java.util.concurrent.ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>, java.util.concurrent.ThreadFactory);
            public java.util.concurrent.ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>, java.util.concurrent.RejectedExecutionHandler);
            public java.util.concurrent.ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue<java.lang.Runnable>, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler);
            public void execute(java.lang.Runnable);
            public void shutdown();
            public java.util.List<java.lang.Runnable> shutdownNow();
            public boolean isShutdown();
            boolean isStopped();
            public boolean isTerminating();
            public boolean isTerminated();
            public boolean awaitTermination(long, java.util.concurrent.TimeUnit) throws java.lang.InterruptedException;    
            protected void finalize();
            public void setThreadFactory(java.util.concurrent.ThreadFactory);
            public java.util.concurrent.ThreadFactory getThreadFactory();
            public void setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler);
            public java.util.concurrent.RejectedExecutionHandler getRejectedExecutionHandler();
            public void setCorePoolSize(int);
            public int getCorePoolSize();
            public boolean prestartCoreThread();
            void ensurePrestart();
            public int prestartAllCoreThreads();
            public boolean allowsCoreThreadTimeOut();
            public void allowCoreThreadTimeOut(boolean);
            public void setMaximumPoolSize(int);
            public int getMaximumPoolSize();
            public void setKeepAliveTime(long, java.util.concurrent.TimeUnit);
            public long getKeepAliveTime(java.util.concurrent.TimeUnit);
            public java.util.concurrent.BlockingQueue<java.lang.Runnable> getQueue();
            public boolean remove(java.lang.Runnable);
            public void purge();
            public int getPoolSize();
            public int getActiveCount();
            public int getLargestPoolSize();
            public long getTaskCount();
            public long getCompletedTaskCount();
            public java.lang.String toString();
            protected void beforeExecute(java.lang.Thread, java.lang.Runnable);
            protected void afterExecute(java.lang.Runnable, java.lang.Throwable);
            protected void terminated();
            static {};
          }
        </pre>
        
          
        <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        <div class="Topic" id="gui"> 
          <br><br>
          <h1 style="color:white">GUI Development</h1> </div>
        
        <div class="gui" >
          <br><br>
          <h1>  java.Swing</h1>
          <pre>
            java swing
        
            Classes:
            JButton: A button component.
            JCheckBox: A checkbox component.
            JCheckBoxMenuItem: A menu item that can be checked or unchecked.
            JColorChooser: A dialog for choosing colors.
            JComboBox: A component that combines a button and a dropdown list.
            JDialog: A top-level window with a title and a border.
            JEditorPane: A text component that can display HTML and other text formats.
            JFileChooser: A file chooser dialog.
            JFormattedTextField: A text field that allows formatting of the input.
            JFrame: A top-level window with a title and a border.
            JLabel: A label component for displaying text or an image.
            JList: A component that displays a list of items.
            JMenuBar: A bar that contains menus.
            JMenuItem: An item in a menu.
            JOptionPane: A dialog for displaying messages or requesting input.
            JPanel: A generic container.
            JPasswordField: A text field for password input.
            JProgressBar: A component that displays progress visually.
            JRadioButton: A radio button component.
            JRadioButtonMenuItem: A menu item that represents a radio button.
            JScrollPane: A scrollable view of a component.
            JSeparator: A separator line for menus and toolbars.
            JSlider: A component for selecting a numeric value within a range.
            JSpinner: A component for selecting a numeric or date/time value.
            JSplitPane: A container with two components separated by a divider.
            JTabbedPane: A component that allows switching between multiple components using tabs.
            JTable: A component for displaying data in a table format.
            JTextArea: A multi-line area for displaying text.
            JTextField: A single-line text field.
            JTextPane: A text component that supports styled text.
            JToolBar: A bar that contains buttons and other controls.
            JToolTip: A tooltip component.
            JTree: A component for displaying hierarchical data in a tree format.
            JViewport: A view for a JScrollPane component.
            JWindow: A top-level window without a title and border.
            
            Interfaces:
            ListModel: Interface for providing data for a JList component.
            ListSelectionModel: Interface for handling selection in a list-based component.
            TableCellRenderer: Interface for rendering table cells.
            TreeModel: Interface for providing data for a JTree component.
            TreeSelectionModel: Interface for handling selection in a tree-based component.
            
            
            <h1>java.awt</h1>
            
        java.awt
        
        Classes:
        Component: The base class for all graphical components.
        Container: A component that can contain other components.
        Window: A top-level window with no borders and no menubar.
        Frame: A top-level window with a title and a border.
        Dialog: A top-level window with a title and a border that is typically used for user input.
        Button: A component that represents a button.
        Label: A component for displaying a single line of read-only text or an image.
        TextField: A component that allows the editing of a single line of text.
        TextArea: A multi-line area that displays text.
        Checkbox: A component that represents a check box.
        CheckboxGroup: A grouping of checkbox components.
        CheckboxMenuItem: A menu item that can be checked or unchecked.
        Choice: A drop-down menu of choices.
        List: A scrolling list of text items.
        MenuBar: A bar that contains menus.
        Menu: A popup menu of items.
        MenuItem: An item in a menu.
        Panel: A generic container.
        ScrollPane: A scrollable view of a component.
        Scrollbar: A component that represents a scroll bar.
        Canvas: A blank rectangular area for drawing graphics.
        Graphics: The abstract base class for all graphics contexts.
        Font: A representation of a font.
        Color: A representation of color in RGB.
        
        Interfaces:
        LayoutMananger: Interface for objects that lay out components in a container.
        ImageObserver: Interface for objects that want to be notified when an image has information available yet not all of the data has been delivered.
        MenuContainer: Interface for menu-based components.
        ImageProducer: Interface for objects that produce data for images.
        
        
         <h1>javafx.scene</h1>
        
         Classes:
        
         Parent: An abstract base class for all nodes that have children in the scene graph.
         Scene: Represents the top-level container for content in a stage.
         Group: A container for managing and transforming a set of nodes.
         Region: A base class for all UI controls in JavaFX.
         Control: The base class for all user interface controls.
         Canvas: A drawable area that supports rendering shapes, images, and text.
         Text: A node that represents a run of text in the scene graph.
         ImageView: A node used to display an image loaded with Image.
         Button: A common button control.
         Label: A non-editable text control.
        
         Interfaces:
        
         LayoutX: Interface for nodes that have an X layout position.
         LayoutY: Interface for nodes that have a Y layout position.
         Styleable: Interface for nodes that can be styled using CSS.
        
        <h1>javafx.scene.control</h1>
        
        Classes:
        
        Button: A standard button.
        CheckBox: A box that can be selected or deselected.
        ChoiceBox: A selection control that allows users to choose from a list of items.
        ColorPicker: A control for selecting a color.
        ComboBox: A combination of a text field and a drop-down list.
        Hyperlink: An HTML-style hyperlink.
        Label: A non-editable text control.
        ListView: A control for displaying a scrollable list of items.
        MenuBar: A horizontal menu bar.
        Menu: A vertical menu that can be included in a menu bar or a context menu.
        MenuItem: An item in a menu.
        Pagination: A control for handling pagination of content.
        PasswordField: A text input field that hides the entered characters.
        ProgressBar: A horizontal bar that indicates the progress of an operation.
        ProgressIndicator: A circular indicator that visualizes the progress of an operation.
        RadioButton: A radio button, which is a toggle button that represents a choice.
        ScrollPane: A container for displaying content that is larger than its viewable area.
        Separator: A visual separator for controls.
        Slider: A control for selecting a value within a range.
        Spinner: A control for selecting a numeric value from a range.
        SplitMenuButton: A button that can be split into two parts: the action part and the menu part.
        Tab: A tab that can be placed in a TabPane.
        TabPane: A container for a set of tabs.
        TableView: A control for displaying a table of items.
        TextField: A text input field.
        ToggleButton: A button that can be toggled between selected and unselected states.
        ToolBar: A horizontal bar for placing controls, typically used for toolbars.
        ToolTip: A popup control that provides additional information for another control.
        TreeItem: An item that can be placed in a TreeView.
        TreeView: A control for displaying hierarchical data.
        Interfaces:
        
        Cell: Interface for controls that are designed to show a single "cell" of information.
        Skin: Interface for providing the visuals for a control.
        
        
        <h1>javafx.fxml</h1>
        Classes:
        FXMLLoader:Loads an object hierarchy from an FXML document.
        FXMLDocumentController:The base class for FXML controllers.
        
        Interfaces:
        Initializable:Interface to be implemented by FXML controllers if they need to perform initialization after the FXML file has been loaded.
         
        <h1>javax.swing.text</h1>
        Classes:
        
        AbstractDocument:A partial implementation of the Document interface that can be used as a starting point for creating a simple Document.
        DefaultCaret:A simple caret implementation that renders as a vertical line.
        DefaultStyledDocument:A default implementation of the StyledDocument interface.
        Document:The interface for an object that can be used as a document model for text components.
        EditorKit:A set of methods for managing text components that interact with a text model.
        Element:An interface for an element of a content model.
        PlainDocument:A plain text document that can be used as a document model for text components.
        Segment:A mutable version of the String class.
        SimpleAttributeSet:A set of unique attributes.
        StyledDocument:An extension of the Document interface for supporting styled text.
        TextAction:An action that assumes it's being fired as a text action.
        Utilities:A collection of utility methods for Swing text components.
        
        Interfaces:
        
        AttributeSet:An interface that represents a collection of attributes.
        DocumentFilter:An interface that can be used to filter insertions, removals, and changes.
        EditorKit:An interface for the creation and management of text components to be used with JTextComponent.
        Highlighter:An interface for an object that allows text to be marked with attributes.
        Position:An interface for a position within a document.
        TabableView:An interface for views that can be placed in a JTabbedPane.
        
        
        <h1>javax.swing.event</h1>
        Classes:
        
        ChangeEvent:An event that indicates a change in state has occurred.
        DocumentEvent:An event that describes changes made to a Document.
        ListDataEvent:An event that encapsulates changes to a ListDataModel.
        ListSelectionEvent:An event that characterizes a change in selection.
        MenuDragMouseEvent:An event used to track mouse drag events over a menu item.
        MenuEvent:An event indicating that a menu-related action occurred.
        PopupMenuEvent:An event that indicates a change to a PopupMenu.
        RowSorterEvent:An event that characterizes a change to a RowSorter.
        TableModelEvent:An event that describes changes to a TableModel.
        TreeExpansionEvent:An event that indicates a change to a TreeExpansion.
        TreeModelEvent:An event that describes changes to a TreeModel.
        TreeSelectionEvent:An event that characterizes a change to the current selection.
        UndoableEditEvent:An event indicating that an operation which can be undone has occurred.
        
        Interfaces:
        
        AncestorListener:An event listener for changes in the hierarchy of a component.
        CaretListener:An event listener for changes in the caret of a text component.
        ChangeListener:An event listener for state changes.
        DocumentListener:An event listener for changes in a Document.
        HyperlinkListener:An event listener for hyperlink events.
        InternalFrameListener:An event listener for changes in internal frames.
        ListDataListener:An event listener for changes in a ListDataModel.
        ListSelectionListener:An event listener for changes in ListSelection.
        MenuKeyListener:An event listener for menu key events.
        MenuListener:An event listener for menu-related events.
        MouseInputListener:An interface for receiving mouse input events.
        PopupMenuListener:An event listener for changes to PopupMenu.
        RowSorterListener:An event listener for changes to a RowSorter.
        TableModelListener:An event listener for changes in a TableModel.
        TreeExpansionListener:An event listener for changes to a TreeExpansion.
        TreeModelListener:An event listener for changes in a TreeModel.
        TreeSelectionListener:An event listener for changes in TreeSelection.
        TreeWillExpandListener:An event listener for changes in a TreeExpansion, before they occur.
        UndoableEditListener:An event listener for changes in undoable edits.
        
        <h1>java.awt.event</h1>
        
        Classes:
        ActionEvent:An event representing an action, typically generated by a user interface component like a button.
        ActionListener:The interface for receiving action events.
        AdjustmentEvent:An event generated when a scrollbar or a slider is moved.
        AdjustmentListener:The interface for receiving adjustment events.
        ComponentEvent:An event representing various component-related events.
        ComponentAdapter:An abstract adapter class for receiving component events.
        ContainerEvent:An event representing container-related events.
        ContainerAdapter:An abstract adapter class for receiving container events.
        FocusEvent:An event representing focus-related events.
        FocusAdapter:An abstract adapter class for receiving focus events.
        InputEvent:The base class for input events.
        ItemEvent:An event representing item events, typically used by components like checkboxes and list items.
        ItemListener:The interface for receiving item events.
        KeyEvent:An event representing key events, such as key presses and key releases.
        KeyListener:The interface for receiving key events.
        MouseEvent:An event representing mouse events, such as clicks, movements, and button presses.
        MouseListener:The interface for receiving mouse events.
        MouseMotionListener:The interface for receiving mouse motion events.
        MouseWheelEvent:An event representing mouse wheel events.
        MouseWheelListener:The interface for receiving mouse wheel events.
        TextEvent:An event representing text-related events.
        TextListener:The interface for receiving text events.
        
        Interfaces:
        Action:An interface for defining an action, typically used with buttons and menu items.
        AdjustmentListener:The interface for receiving adjustment events (used with scrollbars and sliders).
        AWTEventListener:The interface for objects that can receive AWT events.
        ComponentListener:The interface for receiving component events.
        ContainerListener:The interface for receiving container events.
        FocusListener:The interface for receiving focus events.
        InputMethodListener:The interface for receiving input method events.
        InputMethodTextChangedListener:The interface for receiving input method text changed events.
        KeyListener:The interface for receiving key events.
        MouseListener:The interface for receiving mouse events.
        MouseMotionListener:The interface for receiving mouse motion events.
        MouseWheelListener:The interface for receiving mouse wheel events.
        TextListener:The interface for receiving text events.
        
        <h1>javax.swing.table</h1>
        
        Classes:
        AbstractTableModel:An abstract implementation of the TableModel interface.
        DefaultTableCellRenderer:The default cell renderer for rendering table cells.
        DefaultTableCellEditor:The default cell editor for editing table cells.
        DefaultTableModel:A default implementation of the TableModel interface.
        JTable:A component for displaying and editing data in a two-dimensional table.
        TableColumn:A table column model that represents a column in a JTable.
        TableColumnModel:The model for a JTable's columns.
        TableModel:An interface for the model behind a JTable.
        
        Interfaces:
        TableCellEditor:An interface for editing cells in a JTable.
        TableCellRenderer:An interface for rendering cells in a JTable.
        TableColumnModelListener:An interface for listening to changes in a TableColumnModel.
        TableModelListener:An interface for listening to changes in a TableModel.
        <h1> java.awt.image</h1>
        
        Classes:
        BufferedImage:A class representing an image with an accessible buffer of image dataColorModel:An abstract class describing pixel values in an image.
        DirectColorModel:A ColorModel class representing pixel values with a direct mapping to RGB values.
        ImageFilter:An abstract class that implements a filter for an image producer.
        PixelGrabber:A class that retrieves pixel data from an image.
        ImageObserver:An interface for objects that want to be notified about image information.
        RenderedImage:An interface for objects that represent image data that can be rendered.
        RescaleOp:A class for scaling the brightness and contrast of an image.
        AffineTransformOp:A class for applying an affine transform to an image.
        BufferStrategy:A strategy for multi-buffering in a Canvas or Window.
        
        Interfaces:
        ImageConsumer:An interface for objects that receive asynchronous updates from an image producer.
        ImageProducer:An interface for objects that produce asynchronous updates of an image.
        RasterOp:An interface for operations that transform Rasters.
        RenderedImage:An interface for objects that represent image data that can be rendered.
        TileObserver:An interface for objects that want to be notified when tiles of a WritableRenderedImage are checked out for writing.
        
        <h1>javax.swing.border</h1>
        
        Classes:
        AbstractBorder:An abstract class that implements portions of the Border interface.
        BevelBorder:A border with a raised or lowered beveled edge.
        CompoundBorder:A composite border that is composed of two other borders.
        EmptyBorder:A border with no size.
        EtchedBorder:A border with an etched appearance.
        LineBorder:A border with a single line.
        MatteBorder:A border with a solid color and a defined thickness.
        SoftBevelBorder:A border with a softer beveled edge than BevelBorder.
        TitledBorder:A border with a title.
        
        Interfaces:
        Border:The interface for an object that defines a border around a Swing component.
        </pre>
        
          
          
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        <div class="Topic" id="sql">
          <br><br>
           <h1 style="color:white">Database Connectivity|Java Database Connectivity (JDBC).</h1> </div>
        
        <div class="sql" >
          <br><br>
          <h1>  java.sql</h1>
          <pre>
         
        java.sql
        
        Classes:
        DriverManager: Manages a list of database drivers and establishes database connections.
        Connection: Represents a connection to a database.
        Statement: Represents a SQL statement.
        PreparedStatement: Extends Statement and represents a precompiled SQL statement.
        CallableStatement: Extends PreparedStatement and represents a precompiled SQL statement with placeholders for input/output parameters.
        ResultSet: Represents a table of data resulting from a query.
        ResultSetMetaData: Provides information about the columns in a ResultSet.
        DatabaseMetaData: Provides information about the database.
        Blob: Represents a binary large object.
        Clob: Represents a character large object.
        SQLData: Interface for custom mapping between Java objects and SQL structured types.
        SQLInput: Interface for reading values from a custom mapping of an SQL structured type.
        SQLOutput: Interface for writing values to a custom mapping of an SQL structured type.
        
        Interfaces:
        DataSource: Provides an alternative way to establish a connection to a database, allowing the use of connection pooling.
        ConnectionPoolDataSource: Interface for a factory of PooledConnection objects.
        PooledConnection: Represents a connection that can be pooled.
        RowSet: An extension of ResultSet that provides a more convenient way to handle database data.
        RowSetMetaData: Provides information about the columns in a RowSet.
        CachedRowSet: A RowSet implementation that caches its data in memory.
        FilteredRowSet: A RowSet implementation that filters its contents based on criteria.
        JoinRowSet: A RowSet implementation that performs SQL-style joins between multiple RowSet objects.
        JdbcRowSet: A RowSet implementation that is connected to a database and provides a convenient way to interact with it.
        WebRowSet: A RowSet implementation that can be serialized and deserialized as XML.
        XAConnection: Represents a connection that supports XA transactions.
        XADataSource: Provides an alternative way to establish an XA connection to a database.
          </pre>
        
          
          
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        <div class="Topic"  id="security">
          <br> <br>
           <h1 style="color:white">Security</h1> </div>
        <div class="security">
          <br><br>
          <h1>  java.security</h1>
        
          <pre>
            java.security
        
            Classes:
            MessageDigest: Provides algorithms for hashing messages, such as MD5 and SHA.
            KeyPairGenerator: Generates public/private key pairs for asymmetric algorithms.
            KeyGenerator: Generates secret keys for symmetric algorithms.
            Cipher: Provides encryption and decryption functionalities.
            Signature: Provides classes for generating and verifying digital signatures.
            SecureRandom: Provides cryptographically strong random number generation.
            KeyStore: Manages a collection of keys and certificates.
            KeyFactory: Converts keys between their external and internal representations.
            AlgorithmParameters: Provides a way to manage configuration parameters for algorithms.
            AlgorithmParameterGenerator: Generates a set of algorithm parameters.
            SecureClassLoader: A class loader that loads classes from a secure source.
            Policy: Represents the system-wide security policy.
            ProtectionDomain: Represents the domain for which a permission is granted.
            Permissions: Manages the set of permissions granted to code.
            Permission: Represents an abstract permission class.
            AccessController: Provides static methods for performing access control checks.
            Security: Provides methods for querying and setting the security properties of the system.
            SecurityManager: Provides management of the security policy for applications.
            DigestInputStream: An input stream filter that computes a message digest.
            DigestOutputStream: An output stream filter that computes a message digest.
            KeyPair: Represents a public/private key pair.
            PublicKey: Represents a public key.
            PrivateKey: Represents a private key.
            Certificate: Represents a public key certificate.
            X509Certificate: Represents an X.509 certificate.
            SignedObject: A signed version of an object.
            Signer: A signer object for signing data and verifying signatures.
            Identity: Represents an identity, typically for a user.
            IdentityScope: Manages a scope of identities.
            PolicySpi: A service provider interface for policy implementations.
            Provider: Represents a security provider (e.g., Sun, BouncyCastle).
            CodeSource: Represents the source of a piece of trusted code.
            
            
            Interfaces:
            PublicKey: The interface to a public key.
            PrivateKey: The interface to a private key.
            Key: The common interface to all keys.
            KeyFactorySpi: The service provider interface for KeyFactory implementations.
            SignatureSpi: The service provider interface for Signature implementations.
            MessageDigestSpi: The service provider interface for MessageDigest implementations.
            SecureRandomSpi: The service provider interface for SecureRandom implementations.
            PermissionCollection: A collection of Permission objects.
            Guard: The interface for objects that have access control checks.
            PolicyProvider: The interface for security policy providers.
            CertificateFactorySpi: The service provider interface for CertificateFactory implementations.
            Certificate: The common interface for certificates.
            X509Extension: The interface for X.509 certificate extensions.
            Principal: The interface for principals (e.g., users, groups).
            
            
            
          </pre>
        
          
          
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        <div class="Topic" id="ut">
          <br><br>
           <h1 style="color:white">Utilities and tools</h1> </div>
        
        <div class="ut">
          <br><br>
          <h1>java.lang package:</h1>
          <pre>
        
        Utility Classes
        Arrays:  java.util.Arrays
        Collections: java.util.Collections
        Objects: java.util.Objects
        BitSet:  java.util.BitSet
        Random:  java.util.Random
        Scanner:  java.util.Scanner
        Date and Time :  java.util.Date , java.util.Calendar ,java.util.GregorianCalendar
        Properties: java.util.Properties
        
        Utility Interfaces:
        Comparator: java.util.Comparator
        Iterable: java.lang.Iterable
        Collection: java.util.Collection
        List: java.util.List
        Set: java.util.Set
        Map: java.util.Map
        Queue: java.util.Queue
        Deque: java.util.Deque
        Observer and Observable: java.util.Observer , java.util.Observable
        
        
        Tools:
        
        Integrated Development Environment (IDE): Eclipse, IntelliJ IDEA, Visual Studio Code
        Version Control System (VCS) Tool: Git, SVN, Mercurial
        Build Automation Tool:Apache Maven, Gradle, Ant
        Testing Tools:JUnit, TestNG, Selenium
        Continuous Integration/Continuous Deployment (CI/CD) Tools:Jenkins, Travis CI, CircleCI
        Static Code Analysis Tools: SonarQube, FindBugs, ESLint
        Dependency Management Tool:Apache Maven, Gradle, npm
        Containerization Tools: Docker, Kubernetes
        Code Profiling Tools: YourKit, VisualVM
        Documentation Tools:Javadoc, Doxygen, Sphinx
        
        
          </pre>
        
          <h1>Math:</h1>
          <pre>
        java.math
        
        Classes:
        BigInteger: Represents an arbitrarily large integer.
        BigDecimal: Represents an arbitrarily large floating-point number.
        MathContext: Encapsulates the context settings for numerical operations performed on BigDecimal.
        RoundingMode: Enum that specifies the rounding behavior for numerical operations in BigDecimal.
        
        Interfaces:
        BigDecimalOperations: Interface providing arithmetic operations for BigDecimal instances.
        BigDecimalConst: Interface providing constants for BigDecimal instances.
          </pre>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        <h1>System:</h1>
        <details>
          <summary>
           <span class="faq-title"> 
             <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
           <img src="plus.svg" class="expand-icon" alt="Plus">
          </summary>        
          <div class="faq-content">
          <pre>
            <code>
             
            </code>
          </pre>
          </div>
          </details>
        
        
          <h1>java.nio.file </h1>
          <pre>
            java.nio
        
            Buffer: An abstract class that represents a buffer for data. There are specific buffer classes like ByteBuffer, CharBuffer, ShortBuffer, IntBuffer, LongBuffer, FloatBuffer, and DoubleBuffer for different data types.
            ByteBuffer: A buffer for bytes.
            CharBuffer: A buffer for characters.
            ShortBuffer: A buffer for shorts.
            IntBuffer: A buffer for integers.
            LongBuffer: A buffer for longs.
            FloatBuffer: A buffer for floats.
            DoubleBuffer: A buffer for doubles.
            Channel: An interface representing an open connection to an I/O device, such as a file or a socket.
            FileChannel: A channel for reading, writing, and manipulating a file.
            SocketChannel: A channel for TCP network sockets.
            ServerSocketChannel: A channel for TCP server sockets.
            DatagramChannel: A channel for UDP network sockets.
            Selector: A multiplexor of SelectableChannel objects, which can be used for non-blocking I/O operations.
            SelectionKey: A token representing the registration of a channel with a selector.
            FileLock: A token representing a lock on a region of a file.
            Path: An interface representing a path on the file system.
            Paths: A utility class for working with Path objects.
            FileSystem: An interface representing a file system, providing access to file stores, file attributes, and file type detectors.
            FileSystems: A utility class for working with FileSystem objects.
            FileVisitOption: An enum representing options for file tree traversal.
            FileVisitResult: An enum representing the result of a file visit during tree traversal.
            Files: A utility class for working with files and directories.
            FileStore: An interface representing a storage pool, device, partition, volume, concrete file system, or other implementation-specific means of file storage.
            WatchEvent: An interface representing an event or a repeated event for an object that is registered with a WatchService.
            WatchKey: An object representing the registration of a directory with a WatchService.
            
            
            Interfaces:
            Channel: An interface representing a channel for I/O operations.
            FileChannel.MapMode: An enum representing the mapping mode for a mapped byte buffer.
            ByteChannel: An interface representing a channel that can read and write bytes.
            WritableByteChannel: An interface representing a channel that can write bytes.
            ReadableByteChannel: An interface representing a channel that can read bytes.
            ScatteringByteChannel: An interface representing a channel that can read data into multiple buffers in a single read operation.
            GatheringByteChannel: An interface representing a channel that can write data from multiple buffers in a single write operation.
            SelectableChannel: An interface representing a channel that can be registered with a selector for non-blocking I/O operations.
            InterruptibleChannel: An interface representing a channel that can be asynchronously closed and interrupted.
            SeekableByteChannel: An interface representing a channel with a current file position that can be manipulated.
          </pre>
        
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        <h1>java.text</h1>
        <pre>
        
          java.text
        
          Classes:
          DateFormat: Abstract class for date/time formatting.
          SimpleDateFormat: A concrete class for formatting and parsing dates in a locale-sensitive manner.
          DecimalFormat: A concrete class for formatting and parsing decimal numbers.
          ChoiceFormat: A class for defining ranges of numbers to be mapped to strings.
          MessageFormat: A class for formatting and parsing messages that are parameterized.
          NumberFormat: Abstract class for number formatting.
          CollationKey: A utility class for text sorting and comparison.
          Collator: Abstract class for locale-sensitive text comparison.
          RuleBasedCollator: A concrete subclass of Collator that allows customization of text sorting behavior.
          DateFormatSymbols: A class for encapsulating localizable date-time formatting data.
          FieldPosition: A class for working with fields in formatted strings.
          ParseException: An exception indicating a parse error during formatting or parsing.
          
          Interfaces:
          AttributedCharacterIterator: Represents text that includes attributes, such as font and color.
          CharacterIterator: Interface for iterating over a sequence of characters.
          Format: Interface for formatting and parsing values.
          ParsePosition: A class for working with the position in a text string during parsing.
          AttributedCharacterIterator.Attribute: Represents an attribute key.
        </pre>
          <h1>Dictionary</h1>
          <details>
            <summary>
             <span class="faq-title"> 
               <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
             <img src="plus.svg" class="expand-icon" alt="Plus">
            </summary>        
            <div class="faq-content">
            <pre>
              <code>
               
              </code>
            </pre>
            </div>
            </details>
        
        
        
        <div class="Topic" id="xml">
          <br><br>
           <h1 style="color:white">XML and JSON Pocessing</h1> </div>
        
        <div class="xml">
          <br><br>
          <h1> </h1>
          <pre>
            XML Processing (Using Java API for XML Processing - JAXP):
        
           1. javax.xml Package:
            Transformer: An interface for transformations from XML to other formats.
            TransformerFactory: A factory class for creating Transformer instances.
            TransformException: An exception representing a transformation error.
        
          2.javax.xml.parsers Package:
            DocumentBuilder: An interface for parsing XML documents.
            DocumentBuilderFactory: A factory class for creating DocumentBuilder instances.
            SAXParser: An interface for parsing XML using the Simple API for XML (SAX).
            SAXParserFactory: A factory class for creating SAXParser instances.
            ParserConfigurationException: An exception representing a configuration error in the XML parser.
            SAXException: A general SAX exception.
        
           3. org.w3c.dom Package:
            Document: The root of the XML document object model (DOM).
            Element: An interface representing an element in an XML document.
            Node: The base interface for all nodes in an XML document.
            NodeList: An ordered collection of nodes.
            Attr: An interface representing an attribute in an XML element.
            Text: An interface representing text in an XML document.
        
        
        
        
            JSON Processing (Using Java API for JSON Processing - JSON-P):
        
           1. javax.json Package:  
            Json: A class providing methods for creating JSON data structures.
            JsonValue: The base interface for representing JSON values.
            JsonObject: An interface representing a JSON object.
            JsonArray: An interface representing a JSON array.
            JsonString: An interface representing a JSON string.
            JsonNumber: An interface representing a JSON number.
            JsonReader: An interface for reading JSON data.
            JsonWriter: An interface for writing JSON data.
            JsonException: An exception representing a JSON processing error.
        
          2.  javax.json.stream Package:
            JsonParser: An interface for parsing JSON data using a streaming approach.
            JsonGenerator: An interface for generating JSON data using a streaming approach.
           
          3. javax.json.spi Package:
            JsonProvider: An interface for JSON-P providers.
            JsonBuilderFactory: A factory for creating JsonObjectBuilder instances.
            JsonArrayBuilder: An interface for building JSON arrays.
            JsonObjectBuilder: An interface for building JSON objects
          </pre>
        
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        
        
        <div class="Topic" id="webS">
          <br><br>
           <h1 style="color:white">webS</h1> </div>
        
        <div class="webS" >
          <br><br>
          <h1>Web Services </h1>
          <pre>
            Web services in Java are typically implemented using Java API for XML Web Services (JAX-WS) or Java API for RESTful Web Services (JAX-RS).
         
            
            Java API for XML Web Services (JAX-WS):
        
          1.  javax.jws Package:
            WebService: An annotation that defines a class as a web service endpoint.
        
          2. javax.xml.ws Package:
            Endpoint: A class for publishing web service endpoints.
            Service: A class representing a web service.
            WebEndpoint: An annotation representing a web endpoint.
            WebFault: An annotation representing a web fault.
        
          3. javax.jws.soap Package:
            SOAPBinding: An annotation that specifies the SOAP protocol details for a web service.
            SOAPBinding.Style: Enum that defines the SOAP binding style.
            SOAPBinding.Use: Enum that defines the SOAP binding use.
        
          4. javax.xml.ws.handler Package:
            Handler: An interface for message handlers in a web service.
        
          5.  javax.xml.ws.soap Package:
            SOAPFaultException: An exception for SOAP faults.
        
          6.  javax.xml.ws.spi Package:
            ServiceDelegate: An abstract class that provides a delegate for the creation of web service instances
          
        
        
        
            Java API for RESTful Web Services (JAX-RS):
          
          1.  javax.ws.rs Package: 
            Path: An annotation to define a URI path template.
            GET, POST, PUT, DELETE, etc.: Annotations for HTTP methods.
            Produces: An annotation to define the media types a resource method can produce.
            Consumes: An annotation to define the media types a resource method can consume.
            PathParam: An annotation to inject values from URI path parameters into resource method parameters.
            QueryParam: An annotation to inject values from query parameters into resource method parameters.
            FormParam: An annotation to inject values from form parameters into resource method parameters.
            HeaderParam: An annotation to inject values from HTTP headers into resource method parameters.
            Context: An annotation to inject instances of various JAX-RS context interfaces.
           
          2. javax.ws.rs.client Package: 
            Client: A class for building and executing HTTP requests.
            WebTarget: An abstraction for the resource targeted by a web resource.
           
          3.  javax.ws.rs.core Package:
            Application: An interface for configuring and managing JAX-RS resources.
            UriInfo: An interface for accessing URI information.
            Response: A class representing an HTTP response.
        
           4. javax.ws.rs.ext Package:
            ContextResolver: An interface for resolving context information.
            ExceptionMapper: An interface for mapping exceptions to HTTP responses.
            MessageBodyReader, MessageBodyWriter: Interfaces for reading and writing message bodies.
          </pre>
        
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        <div class="Topic" id="il">
          <br><br>
           <h1 style="color:white">Internationalization and Localization</h1> </div>
        
        <div class="il" >
          <br><br>
          <h1>i18n and l10n </h1>
          <pre>
            Internationalization is about Design:
            It involves designing software from the ground up to be adaptable to various languages and regions.
            
            Localization is about Content:
            It involves translating and adapting the software for a specific language and cultural context.
         
         
         
         
            Internationalization (i18n):
            Internationalization is the process of designing and preparing software so that it can be easily adapted to different languages and regions without engineering changes. The goal is to create a codebase that is flexible and able to support multiple languages and cultural conventions.
            
            Key Aspects of Internationalization: 
            Externalizing Text:Separating text and other locale-specific elements from the source code. This typically involves using resource files to store language-specific content.
            Unicode Support: Ensuring that the application handles character encoding properly, often by using Unicode throughout the codebase.
            Date and Time Formatting: Designing the application to support different date and time formats used in various regions.
            Number Formatting:  Making sure that numeric values are formatted according to the conventions of different locales (e.g., using commas or periods as decimal separators).
          
        
            Localization (l10n):
            Localization is the process of adapting an internationalized application to a specific language and culture. It involves translating user interfaces, messages, and other content into the desired language and adapting the application to the specific cultural norms and expectations of a target locale.
            
            Key Aspects of Localization:
            
            Translation:Converting all text elements of the application, including user interfaces, messages, and documentation, into the target language.
            Cultural Adaptation: Adapting the application to conform to the cultural expectations of the target audience, including date and time formats, currency symbols, and other region-specific conventions.
            Images and Icons: Replacing images and icons with culturally appropriate alternatives when necessary.
            Regional Regulations: Ensuring compliance with any regional regulations or legal requirements that may affect the application.
          </pre>
          <pre>
            java.util Package:
            Locale Class:
            
            Represents a specific geographical, political, or cultural region.
            Provides methods to get information about the language, country, and variant.
            ResourceBundle Class:
            
            A mechanism for handling program messages in different languages.
            ResourceBundle.Control: An abstract class for controlling the loading of resources.
            TimeZone Class:
            
            Represents a time zone, used for date and time formatting.
            java.text Package:
            MessageFormat Class:
            
            Formats and parses messages with parameters in a locale-sensitive manner.
            DateFormat Class:
            
            Abstract class for date/time formatting.
            SimpleDateFormat: A concrete implementation for localized date/time formatting.
            NumberFormat Class:
            
            Abstract class for number formatting.
            DecimalFormat: A concrete implementation for localized number formatting.
            Collator Class:
            
            Performs locale-sensitive string comparison.
            ChoiceFormat Class:
            
            Formats a message differently based on the values of an associated double.
            DateFormatSymbols Class:
            
            Encapsulates localized date-time formatting data, such as month names and day-of-week names.
            DecimalFormatSymbols Class:
            
            Encapsulates the set of symbols (such as the decimal separator) needed by DecimalFormat.
            java.util.spi Package:
            LocaleServiceProvider Interface:
            An interface for locale-sensitive service providers.
          </pre>
        
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        <div class="Topic" id="rlf">
          <br><br>
           <h1 style="color:white">Reflection</h1> </div>
        
        <div class="rlf" >
          <br><br>
          <h1>   java.lang.reflect Package:</h1>
          <pre>
            Field Class:
            Represents a field of a class.
            Provides methods to get and set the value of a field.
        
            Method Class:
            Represents a method of a class.
            Provides methods to invoke a method on an object.
        
            Constructor Class:
            Represents a constructor of a class.
            Provides methods to create a new instance of the class.
        
        
            Modifier Class:
            Provides static methods and constants for class and member access modifiers.
        
            Array Class:
            Provides static methods to dynamically create and access Java arrays.
        
            Executable Interface:
            A common interface for Method and Constructor.
            Provides methods for parameter reflection.
        
            Type Interface:
            A root interface for all types in the Java programming language.
        
            Parameter Class:
            Represents a formal parameter of a method or constructor.
            Provides methods to get information about the parameter.
        
            AnnotatedElement Interface:
            An interface for an element that can have annotations.
          </pre>
        
          <h1>Dictionary</h1>
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        <div class="Topic" id="jmx">
          <br><br>
           <h1 style="color:white">Java Management Extensions (JMX)</h1> </div>
        
        <div class="jmx" >
          <br><br>
          <h1>Java Management Extensions (JMX) </h1>
          <pre>
            Java Management Extensions (JMX) is a Java technology that provides a set of APIs and tools for managing and monitoring Java applications. The primary packages for JMX are part of the javax.management and javax.management.remote packages. 
        
            javax.management Package:
        
            MBeanServer Interface:
            Represents the MBean server, which is responsible for managing and exposing MBeans.
            Provides methods for registering, unregistering, and querying MBeans.
           
            ObjectName Class:
            Represents the name of an MBean.
            Consists of a domain, a list of key properties, and a list of key values.
           
            MBeanServerFactory Class: A factory class for creating and managing MBeanServer instances.
            MBeanServerInvocationHandler Class:  A proxy class for handling invocations on MBean servers.
            MBeanRegistration Interface: An interface that MBeans can implement to receive callbacks during their registration and unregistration.
            Notification Class:  Represents a notification emitted by an MBean.
            NotificationListener Interface: An interface implemented by objects interested in receiving notifications from MBeans.
            NotificationBroadcaster Interface: An interface implemented by MBeans that can emit notifications.
            ModelMBean Class: An implementation of the DynamicMBean interface that provides a generic way to expose Java objects as manageable resources.
            Attribute Class: Represents an attribute name and its value.
        
            javax.management.remote Package:
            JMXConnector Interface:  Represents a connector for connecting to an MBean server remotely.
            JMXServiceURL Class:  Represents a URL for a JMX service.
            JMXConnectorFactory Class:  A factory class for creating JMX connectors.
            JMXConnectorServer Interface:  Represents a connector server, which listens for incoming connections.
            JMXConnectorServerFactory Class: A factory class for creating JMX connector servers.
        
          </pre>
        
          <h1>Dictionary</h1>
        
        <details>
        <summary>
         <span class="faq-title"> 
           <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
         <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre>
          <code>
           
          </code>
        </pre>
        </div>
        </details>
        
        
        </div>
        
        
        </div>




            


            <footer>
                <div class="content">
                  <div class="top">
                    <div class="logo-details">
                      <!-- <i class="fab fa-slack"></i> -->
                      <span class="logo_name">Keesite</span>
                    </div>
                    <!-- <div class="media-icons">
                      <a href="#"><i class="fab fa-facebook-f"></i></a>
                      <a href="#"><i class="fab fa-twitter"></i></a>
                      <a href="#"><i class="fab fa-instagram"></i></a>
                      <a href="#"><i class="fab fa-linkedin-in"></i></a>
                      <a href="#"><i class="fab fa-youtube"></i></a>
                    </div> -->
                  </div>
                  <div class="link-boxes">
                    <ul class="box">
                      <li class="link_name">Accont</li>
                      <li><a href="#">Profile</a></li>
                      <li><a href="#">Todo list</a></li>
                      <li><a href="#">Roadmap</a></li>
                      <li><a href="#">feedback</a></li>
                    </ul>
                    <ul class="box">
                      <li class="link_name">100 Q/A challenge</li>
                      <li><a href="#">Python</a><a href="#"></a></li>
                      <li><a href="#"> javascript</a></li>
                      <li><a href="#"> java</a></li>
                      <li><a href="#"> sql</a></li>
                    </ul>
                    <ul class="box">
                      <li class="link_name">frontend</li>
                      <li><a href="#">HTML</a></li>
                      <li><a href="#">CSS </a></li>
                      <li><a href="#">JAVASCRIPT </a></li>
                      <!-- <li><a href="#">dsa</a></li>
                      <li><a href="#">jjjj</a></li> -->
                     
                    </ul>
                    <ul class="box">
                      <li class="link_name">courses</li>
                      <li><a href="#">DSA(java and python)</a></li>
                      <li><a href="#">github</a></li>
                      <li><a href="#">Database</a></li>
                      <li><a href="#">Machine Learning</a></li>
                    </ul>
                    <!-- <ul class="box input-box">
                      <li class="link_name">Subscribe</li>
                      <li><input type="text" placeholder="Enter your email"></li>
                      <li><input type="button" value="Subscribe"></li>
                    </ul> -->
                  </div>
                </div>
                <div class="bottom-details">
                  <div class="bottom_text">
                     <span class="copyright_text">copyright @ keesite 2023  </span><!-- <a href="#">CodingLab.</a>All rights reserved-->
                    <span class="policy_terms">
                      <span>&#128187 keesitelearn@gmail.com</span>
                      <!-- <a href="#">Privacy policy</a>
                      <a href="#">Terms & condition</a> -->
                    </span>
                  </div>
                </div>
              </footer>    
            


    <script>
        const canvas = document.getElementById('Canvas');
        const ctx = canvas.getContext('2d');
        // ctx.clearRect(0, 0, canvas.width, canvas.height);
      
        const cubeWidth = 26;
        const cubeHeight =20;
        const cubeDepth = 20;
      
        // Set cube position
        const cubeX = (canvas.width - cubeWidth) / 2;
        const cubeY = (canvas.height - cubeHeight) / 2;
      
        
        function drawCube() {
      
          ctx.beginPath();// Front face
          ctx.moveTo(cubeX, cubeY);
          ctx.lineTo(cubeX + cubeWidth, cubeY);
          ctx.lineTo(cubeX + cubeWidth, cubeY + cubeHeight);
          ctx.lineTo(cubeX, cubeY + cubeHeight);
          ctx.closePath();
          ctx.fillStyle = '#8d8f84';
          ctx.fill();
      
      
          ctx.beginPath();//top face
          ctx.moveTo(cubeX, cubeY);
          ctx.lineTo(cubeX + cubeWidth / 2, cubeY - cubeDepth / 2);
          ctx.lineTo(cubeX + cubeWidth / 2 + cubeWidth, cubeY - cubeDepth / 2);
          ctx.lineTo(cubeX + cubeWidth, cubeY);
          ctx.closePath();
          ctx.fillStyle = 'white';
          ctx.fill();
      
         
          ctx.beginPath();//side face
          ctx.moveTo(cubeX + cubeWidth, cubeY);
          ctx.lineTo(cubeX + cubeWidth / 2 + cubeWidth, cubeY - cubeDepth / 2);
          ctx.lineTo(cubeX + cubeWidth / 2 + cubeWidth, cubeY + cubeHeight - cubeDepth / 2);
          ctx.lineTo(cubeX + cubeWidth, cubeY + cubeHeight);
          ctx.closePath();
          ctx.fillStyle = '#8d8f84';
          ctx.fill();
        }
      
        setTimeout( function() {
      
          ctx.fillStyle = '#f54500';
          ctx.font = '10px FontAwesome';  
          ctx.fillText("\uf084",25,9);
        },1000);
        drawCube();
      
      
      </script> 

<script>
    function openForm() {
  document.getElementById("myForm").style.display = "block";
  
  }
  function closeForm() {
  document.getElementById("myForm").style.display = "none";
  }
  </script>  



<script src="https://smtpjs.com/v3/smtp.js"></script>

<script>
const submit=document.getElementsByClassName('container')[0];

submit.addEventListener('submit',(e)=>
{
    e.preventDefault();

// console.log(fname.value);
// console.log(fphone.value);
// console.log(fmessage.value);

console.log("clicked");
})

 function sendEmail(){

const fname=document.getElementById('name');
console.log(name);
const femail=document.getElementById('email');
const fphone=document.getElementById('phone');
const fmessage=document.getElementById('message');

let ebody= ` 
<b>Name: </b>${fname.value}<br>
<b>Email: </b>${femail.value}<br>
<b>phone NO: </b>${fphone.value}<br>
<b>query:</b> ${fmessage.value} `

            Email.send({
                Host:"smtp.elasticemail.com",
                Username:"keerthikaravi1405@gmail.com",
                Password: "882FE9E23494C1F767E8347592F3DBBA1364",
                To:'keesitelearn@gmail.com',
                From:document.getElementById('email').value,
                Subject:"New Contact Form Enquiry" + email.value,
                Body: ebody
            }).then(
                message => alert("your query send successfully")
            );
           

        };
    </script> 


<script>

  const body = document.querySelector("body"),
        nav = document.querySelector("nav"),
        modeToggle = document.querySelector(".dark-light");
        // imageContainer = document.querySelector(".image-container");
  
        let getMode = localStorage.getItem("mode");
            if(getMode && getMode === "dark-mode"){
              body.classList.add("dark");
            //   updateImage("dark");
            }
  
  
       modeToggle.addEventListener("click" , () =>{
          modeToggle.classList.toggle("active");
          body.classList.toggle("dark");
          // js code to keep user selected mode even page refresh or file reopen

          if(!body.classList.contains("dark")){
              localStorage.setItem("mode" , "light-mode");
            //   updateImage("light");

          }
          else{
              localStorage.setItem("mode" , "dark-mode");
            //   updateImage("dark");
          }
        });

//         function updateImage(mode) {
  
//     const lightImagePath = "river.gif";
//     const darkImagePath = "night.gif";

 
//     imageContainer.src = mode === "dark" ? darkImagePath : lightImagePath;
//   }
    </script>
<script>
  function view() {
document.getElementById("wrapper").style.display = "block";

}
function nonview() {
document.getElementById("wrapper").style.display = "none";
}
</script>  



<script>
     
  var codeBlocks = document.querySelectorAll("pre");
  console.log(codeBlocks);
  codeBlocks.forEach(function(t)
  {
      var o = document.createElement("button");
 
      o.className="at_copy",
      o.type="button",
      o.ariaLabel="Copy code to clipboard",
      o.innerHTML="Copy",
      t.append(o),
      o.addEventListener("click",function()
      {
      var e =t.querySelector("code").innerText.trim();
      window.navigator.clipboard.writeText(e),
 
      o.innerHTML="Copied";
 
      setTimeout(function(){
       o.innerHTML="Copy"
     },1e3)
  })
 });
  /*]]>*/
       </script>
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script> 
 <script>hljs.highlightAll();</script>  


<!-- <script>
      
  document.addEventListener("scroll", function () {
    var threshold = 50;

    // document.getElementById("test").innerHTML = window.scrollY; //show the count
    
    var sidebar = document.getElementById("navbar");
    var content = document.getElementById("bgcontent");

    if (window.scrollY >= threshold) {
      sidebar.classList.add("fixed");
    } 
    else {
      sidebar.classList.remove("fixed");
    }

    var check = content.offsetHeight - sidebar.offsetHeight - 21;
    console.log(check);//679

    if (window.scrollY >= check) {
      sidebar.classList.add("bottom");
    } else {
      sidebar.classList.remove("bottom");
    }
  });
</script> -->
</body>
</html>