<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>keesite/nonlinear</title>
    <link rel="icon" href="awskey.jpg" type="image/x-icon">
    <!-- <link rel="stylesheet" href="awservice.css"> -->
    <link href='https://unpkg.com/boxicons@2.1.1/css/boxicons.min.css' rel='stylesheet'>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="nonlinears.css">
  <link rel="stylesheet" href="nonlinearaccordance.css">
  
  <style>
   @media (min-width: 1024px) {
    #recommend {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        display: none; 
        z-index: 100;
        background: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
    }
    .recompopup {
        position: relative;
        background-color: #ffffff;
        border: 1px solid #8d67cf;
        width: 1000px;
        height: 550px;
        padding: 20px;
        z-index: 101; /* Ensure popup appears above the overlay */
        border-radius:2%;
        margin-top: 50px;
        margin-left: 170px;
    }
.recompopup h2{
width: fit-content;
margin-left: 300px;

}
.recompopup h1{
width: fit-content;
margin-left: 330px;

}
.popup ul{
border: 1px solid black;
margin-left: 70px;
}
.recompopup ul li{
border-radius: 2%;
padding: 0px 20px;
display:inline-block;
list-style: none;

}
.recompopup ul a{
text-decoration: none;
color: black;
}

.course1, 
.course2,
.course3{
width: 280px;
height: 320px;
border: 1px solid black;
border-radius: 4%;
}
.course1 h2, 
.course2 h2,
.course3 h2{
color:#8d67cf;
margin-left: 10px;

}
.course1 p, 
.course2 p,
.course3 p{
font-size: 15.5px;

}

.recompopup ul li img{
border-radius: 4%;
width: 280px;
height: 180px;
}
.recompopup button{
margin-left: 450px;
border-radius: 15%;
border-color: #8d67cf;
padding: 10px 20px;
color: #8d67cf;
font-weight: bolder;
cursor: pointer;
}
.recompopup button:hover,
.recompopup svg:hover{
box-shadow: 0 4px 8px rgba(35, 34, 35, 0.1);
}

    .close {
        font-size: 50px;
        cursor: pointer;
        position: absolute;
        top: 20px;
        right: 20px; /* Adjusted position for the close button */
        color: rgb(0, 0, 0); /* Set the close button color to white */
        z-index: 102; /* Ensure close button appears above the popup */
    }
  }
  @media (max-width: 767px) {

    #recommend {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        display: none; 
        z-index: 100;
        background: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
    }
    .recompopup {
        position: relative;
        background-color: #ffffff;
        border: 1px solid black;
        width: 300px;
        height: 270px;
        padding: 20px;
        z-index: 101; /* Ensure popup appears above the overlay */
        border-bottom-right-radius: 20px;
        margin-top: 100px;
        margin-left: 25px;
    }
.recompopup h2{
width: fit-content;
margin-left: 30px;
font-size: 11px;

}
.recompopup h1{
width: fit-content;
margin-left: 33px;
font-size: 13px;

}
/* .popup ul{
border: 1px solid black;
} */
.recompopup ul li{
border-radius: 2%;
padding: 10px 7px;
display:inline-block;
list-style: none;

}
.recompopup ul a{
text-decoration: none;
color: black;
}

.course1, 
.course2,
.course3{
width: 80px;
height: 80px;
border: 1px solid black;
border-radius: 4%;
}
.course1 h2, 
.course2 h2,
.course3 h2{
color:#8d67cf;
margin-left: 22px;

}
.course1 p, 
.course2 p,
.course3 p{
display: none;

}

.recompopup ul li img{
border-radius: 4%;
width: 80px;
height: 80px;
}
.recompopup button{
  margin-top:-30px;
margin-left: 110px;
border-radius: 15%;
border-color: #8d67cf;
padding: 1px 2px;
color: #8d67cf;
font-weight: bolder;
cursor: pointer;
}
.recompopup button:hover,
.recompopup svg:hover{
box-shadow: 0 4px 8px rgba(35, 34, 35, 0.1);;
}

    .close {
        font-size: 30px;
        cursor: pointer;
        position: absolute;
        top: 3px;
        right: 10px; /* Adjusted position for the close button */
        color: rgb(0, 0, 0); /* Set the close button color to white */
        z-index: 102; /* Ensure close button appears above the popup */
    }
  }
    
  

  
</style>
 



 
    
<style>

:root{
  --body-color: rgb(253, 253, 253);
  --list-color:black;
  /* --text-color:rgb(244, 245, 211);
  --list-color: white;
  --list-text-color:black;
  --hover:grey;
  --tab-content:white;
  --containerprofile:white; */
}


body.dark{
  --body-color:rgb(0, 0, 0,0.7);
  --list-color:white;
  /* --hover:grey;
  --list-text-color:white;
 --list-color: rgb(48, 46, 46);
 
  --text-color:rgb(255, 255, 255);
  --gry-color:rgba(0, 0, 0);
  --tab-content: rgb(48, 46, 46);
  --containerprofile:rgb(48, 46, 46); */
 
}
body {
	background: var(--body-color);
	height: 100%;
}


.nav-bar .darkLight-searchBox{
  display: flex;
  align-items: center;
}
.darkLight-searchBox .dark-light
{
  color:rgb(255, 255, 255);
  position: fixed;
  height: 40px;
  width: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
 
}
@media (min-width: 1024px) {
  .darkLight-searchBox .dark-light{
  position: fixed;
  margin-left: 1120px;
  margin-top: 13px;
  width: 50px;
z-index: 100;
  }
}
@media (min-width:768px )and (max-width: 1023px) {
  .darkLight-searchBox .dark-light{
  margin-left: 780px;
  margin-top: 15px;
  }
}
@media (max-width: 767px) {
  .darkLight-searchBox .dark-light{
    position: fixed;
    width: 50px;
    margin-top: 60px;
   margin-left: 0px;
  z-index: 1;
  }
}


.dark-light i{
  position: absolute;
  color: var(--text-color);
  font-size: 22px;
  cursor: pointer;
  transition: all 0.3s ease;

}
.dark-light i.sun{
  opacity: 0;
  pointer-events: none;
}
.dark-light.active i.sun{
  opacity: 1;
  pointer-events: auto;
}
.dark-light.active i.moon{

  opacity: 0;
  pointer-events: none;
}
.dark-light i.moon:hover{
  color: rgb(0, 0, 0);
}
.dark-light i.sun:hover{
  color: rgb(255, 255, 0);

} 
    </style>
    
      <style>
  
      
       .navbar{
               justify-content: space-around;
             }
           
       @media (min-width: 1024px) {
      
             .nav-menu{
              display: block;
              position: static;
               width: 28%;
              
               margin-top: 20px;
               margin-left: 70px;
               background: none;
               /* border: 1px solid black; */
             }
             .nav-menu a{
              font-size: 15px;
              font-weight: bolder;
               color: rgb(255, 255, 255);
               display: inline-block;
               text-decoration: none;
               text-align: center;
              /* padding: 20px 0; */
             padding: 0px 10px;
             cursor: pointer;
             }
             .hamburger-menu{
               display: none;
             }
       }
           /* for Desktop view */
           @media (max-width: 767px) {

            .nav-menu{
           z-index: -100;
              display: block ;
              position: static;
               width: 350px;
               margin-top: 10px;
               margin-left: 10px;
               background: none;
               background-color: #8d67cf;
               z-index: 400;
               /* border: 1px solid rgb(194, 8, 8); */
             }
             .nav-menu a{
          
              color:white;
              text-decoration: none;
               display:inline-block ;
             padding: 10px 10px;
             cursor: pointer;
             border-radius: 2%;
             }
             /* .hamburger-menu{
               display:contents;
             } */
             .hide{
         display: none;
       }

       .hamburger-menu{
         padding-right: 1.5rem;
         cursor: pointer;
       }
       .hamburger-menu .line{
       display:  block ; 
       width:25px;
       height: 20px; 
       margin-top: 120px;
       margin-left: 10px;
       color: rgb(255, 255, 255);
       cursor: pointer;
       }
  }      
    </style>

     <style type="text/css">
 @media (min-width: 1024px) { 
      #stage{
      position: fixed;
      margin-left: 1280px;
      top:15px;
      cursor: pointer;
      z-index: 200;
  
      }
    }
    @media (max-width: 1023px) {
   

    }
    @media (max-width: 767px) {
      #stage{
  
        position: fixed;
      margin-left: 280px;
      top:60px;
      cursor: pointer;
      z-index: 1;
      }
    }
          @font-face {
           font-family: 'FontAwesome';
           src: url('fontawesome/fonts/fontawesome-webfont.ttf');
           font-weight: normal;
           font-style: normal;
       
          }
          #stage{
            font-family:FontAwesome;
          }

          </style> 



 <style>
.bg{
position: fixed;
height: 160px;
width: 100%;
top:-10px;

}

.bg h1{
color: rgb(251, 251, 251);
 position: absolute;
font-size: 30px;
top:500px;
z-index: 100;
margin-left: 100px;

    }
 .bg img{
  z-index: -1;
  height: 160px;
 } 


@media (min-width: 1024px) {
  .bg {
width: 100%;

  }
  .search-box{
  
    width: 450px;
    margin-top:10px;
    margin-left: 10px;
  }
  .search-box  button{
  left: 380px;
  }
  .outer_searchbox{
    position: fixed;
    margin-left: 450px;
width: 460px;
height: 50px;
padding: 5px 5px;
z-index: 100;
   }
} 

@media (max-width: 1023px) {
  .bg {
    width: 1000px;
    
  }
  .search-box{
    
    width: 550px;
    margin-top: 15px;
    left: 150px;
  }
  .search-box  button{
    left: 500px;
    
  }
  

}

@media (max-width: 767px) {
  .bg {
width:750px;

  }
  .search-box{
  
    width: 300px;
    margin-top: 10px;
    left: -20px;
    z-index: 1;
  }
  .search-box  button{
   
    left: 240px; 
  }
   
  .outer_searchbox{
    
    position: fixed;
    margin-left: 60px;
    width: 300px;
    height: 50px;
    padding: 5px 5px;
    z-index: 100;
   }
}

.search-box{
    position: absolute;
    /* width:  450px; */
    height: 40px;
    color: white;
    background-color: rgba(0, 0, 0,0.3);
    /* margin-top: -30px; */
    /* padding: 10px 10px; */
  
    z-index: 2;
    border-radius: 5px;
   
   }

         </style> 

<link href='https://unpkg.com/boxicons@2.1.1/css/boxicons.min.css' rel='stylesheet'>
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@10.1.0/swiper-bundle.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> -->
    <link href='https://unpkg.com/boxicons@2.1.1/css/boxicons.min.css' rel='stylesheet'>
    <script src="https://code.jquery.com/jquery-3.4.1.js"></script>


    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"> -->
  
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>


    
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<body id="mode">

  

        <!-- <div class="loader">
          <h1>keesite</h1>
        </div> -->
        
        
        
        
              <nav class="navbar" id="navbar">
                <div class="content-area">    
               <div class="hamburger-menu" >
                 <span class="line"><svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-align-center"><line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line></svg></span><!--☰-->
               </div> 
             
               <div class="nav-menu hide">
              <a onclick="view()" target="_top" > <svg fill="#ffffff" width="24px" height="24px" viewBox="0 0 256 256" id="Flat" xmlns="http://www.w3.org/2000/svg">
                <g opacity="0.2">
                  <path d="M73.87573,111.39355l-.009-.03369L42.51636,148.98047a7.99958,7.99958,0,0,0-1.66358,6.85693l12.3628,55.63281a8,8,0,0,0,12.80713,4.51172L96,192C78.36523,161.44922,72.74268,134.47656,73.87573,111.39355Z"/>
                </g>
                <g opacity="0.2">
                  <path d="M181.52239,110.6714l.009-.03369,31.35034,37.6206a7.99958,7.99958,0,0,1,1.66358,6.85693l-12.3628,55.63282a8,8,0,0,1-12.80712,4.51172l-29.9773-23.98194C177.03289,160.72706,182.65544,133.75441,181.52239,110.6714Z"/>
                </g>
                <g>
                  <path d="M144,216H112a8,8,0,0,0,0,16h32a8,8,0,0,0,0-16Z"/>
                  <circle cx="128" cy="96" r="12"/>
                  <path d="M219.62891,143.85889l-30.23658-36.28418a124.52267,124.52267,0,0,0-7.98022-34.8833c-11.61719-30.21192-32.15625-49.999-43.36523-59.10547a16.07708,16.07708,0,0,0-20.07813-.0669C106.61328,22.61621,85.81055,42.38867,74.07617,72.605A122.76188,122.76188,0,0,0,65.979,108.32861L36.37109,143.85889A16.10066,16.10066,0,0,0,33.043,157.57275l12.36328,55.63282a15.98523,15.98523,0,0,0,25.61328,9.023L98.80566,200h58.38868l27.78515,22.22852a15.91184,15.91184,0,0,0,9.96485,3.51709,16.0905,16.0905,0,0,0,5.34668-.91944,15.90581,15.90581,0,0,0,10.30273-11.62012L222.957,157.57373A16.102,16.102,0,0,0,219.62891,143.85889ZM127.9668,26.01074C198.25391,83.126,169.43359,157.01074,155.25,184H100.67871C52.6709,96.27734,109.22559,41.02637,127.9668,26.01074ZM61.02539,209.73486l-12.36328-55.6333,17.92651-21.5122q3.40906,28.0371,19.14038,57.38281Zm133.94922,0-24.74976-19.7998q15.53064-29.55175,18.74341-57.87695l18.36963,22.04345Z"/>
                </g>
              </svg>Explore </a>
             <a href="https://github.com/keerthika1405" target="_top" >     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg> Github</a>
             <a href="https://github.com/keerthika1405/keesite/discussions" target="_top" ><svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-message-circle"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>Community</a>

             <!-- <a href="#">About</a> -->
             </div>
            </div>     
          </nav>
        
        
           
             
           
   
     

        <div class="outer_searchbox">
            <div class="search-box">
              <div class="row">
                <form id="search"  method="post" >
                   <input type="text" id="input-box" placeholder="search here" autocomplete="off">
                   <button type="submit"><i class='bx bx-search bx-sm'  id="input-box"></i></button>
              </form>
            </div>
  
                   <form id="css" action="explore.html" methode="get"></form>
                   <form id="HTML" action="chrome.html" methode="get"></form>
                   <form id="javascript" action="about.html" methode="get"></form>
                     
              <div class="result-box"></div>      
              </div>
            </div>
            
            <div class="darkLight-searchBox">
              <div class="dark-light">
                  <i class='bx bx-moon moon'></i>
                  <i class='bx bx-sun sun'></i>
              </div>
              </div>
        
            <div class="webname">
            <h2>keesite </h2>
            </div> 
   
            <button class="open-button" onclick="openForm()"><svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-help-circle"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></button>
            <div class="container" id="myForm">
            <form  onsubmit="sendEmail(); reset(); " >
            <h3>Let's Solve</h3>
            <input type="text" id="name" placeholder="Your Name" autocomplete="off"  required>
            <input type="email" id="email" placeholder="Your Email Id" autocomplete="off" required>
            <input type="text" id="phone" placeholder="phone no" autocomplete="off" >
            <textarea  id="message" name="" id="message" cols="30" rows="5" placeholder="Write Your Query Here We Will Reach You Soon ?"  required></textarea>
            <button type="submit">send</button>
            <button type="button" class="btn cancel" onclick="closeForm()">Close</button>
            </form>
            </div> 


            <div   class="bg" id="bgcontent">
                <img  id="bg" class="image-container" src="bgimg16.avif" height="100px" width=" 100%" alt="">
                <!-- <h1>welcome  <script> document.write(localStorage.getItem("name").toUpperCase());</script> </h1> -->
            </div>



            <div class="menu__wrapper"  id="wrapper">
    
              <div class="menu__bar">
            
                <nav class="navi">
                   
                  <div class="navigation hide">
                  <ul class="naviul">
                   
                      <li>
                        
                          <button>
                              JAVA
                            
                            
                                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                                  <path
                                      d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                                  </path>
                              </svg>
                          </button>
            
            
            
            
                          <div class="dropdown__wrapper">
                              <div class="dropdown">
                                  <ul class="list-items-with-description">
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3" y2="6"></line>
                                          <line x1="3" y1="12" x2="3" y2="12"></line><line x1="3" y1="18" x2="3" y2="18"></line></svg>
                                     
            
                                          <div class="item-title">
                                              <h3>java</h3>
                                              <p>list of java Topic</p>
                                          </div>
                                      </li>
                                  
                                     
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline></svg>
                                          </svg>
                                          <div class="item-title">
                                              <h3>Java_Practice_Q/A</h3>
                                              <p>100 Q/A Challenge</p>
                                          </div>
                                      </li>
                                      <li>
                                        <svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tool"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path></svg>
                                         
                                          <div class="item-title">
                                              <h3>Java Error | Exception</h3>
                                              <p>meet java buggy</p>
                                          </div>
                                      </li>
                                      <!-- <li>
                                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                              <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                              <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>Storage</h3>
                                              <p>Serverless storage for frontend</p>
                                          </div>
                                      </li> -->
                                  </ul>
                              </div>
                          </div>
                      </li>
            
            
            
            
            
                      <li>
                         <button>
                              FRONT_END
                              <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                                  <path
                                      d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                                  </path>
                              </svg>
                          </button>
            
            
            
            
                          <div class="dropdown__wrapper">
                              <div class="dropdown">
                                  <ul class="list-items-with-description">
                                      <li>
                                        <svg width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                                          <g id="icomoon-ignore">
                                          </g>
                                          <path d="M27.78 4.198c-0.312-0.312-0.722-0.468-1.131-0.468s-0.819 0.156-1.131 0.468l-4.706 4.705v-0.891h-17.060v20.259h20.259v-17.060h-0.981l4.75-4.751c0.625-0.624 0.625-1.637 0-2.262zM22.944 27.204h-18.126v-18.126h15.819l-8.356 8.355v2.307h2.219l8.444-8.445v15.908zM27.026 5.706l-12.967 12.968h-0.711v-0.8l12.924-12.924c0.135-0.135 0.294-0.155 0.376-0.155s0.242 0.020 0.377 0.156c0.136 0.136 0.157 0.295 0.157 0.377s-0.020 0.24-0.157 0.377z" fill="#000000">
                                          
                                          </path>
                                          </svg>
                                          
                                          <div class="item-title">
                                              <h3>HTML</h3>
                                              <p>Way to create Content</p>
                                          </div>
                                      </li>

                                      <li>
                                        <svg width="800px" height="800px" viewBox="-2 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                                          <g id="icomoon-ignore">
                                          </g>
                                          <path d="M22.347 14.827v0l-10.4-10.453-0.213 0.16v-0.267c0-1.76-1.44-3.2-3.2-3.2s-3.2 1.44-3.2 3.2v6.667l-4.427 4.427c-1.227 1.227-1.227 3.2 0 4.427l6.027 6.027c0.587 0.64 1.44 0.907 2.24 0.907s1.6-0.32 2.24-0.907l7.627-7.68h6.56l-3.253-3.307zM6.4 4.267c0-1.173 0.96-2.133 2.133-2.133s2.133 0.96 2.133 2.133v1.333l-4.267 4.267v-5.6zM18.613 17.067l-8 8c-0.373 0.373-0.907 0.587-1.493 0.587-0.533 0-1.067-0.213-1.44-0.587l-6.027-6.027c-0.8-0.8-0.8-2.133 0-2.933l9.013-8.96v6.72h1.067v-7.787l0.16-0.16 11.147 11.147h-4.427z" fill="#000000">
                                          
                                          </path>
                                          <path d="M28.213 26.987c-0.32-2.88-3.413-6.72-3.413-6.72s-3.147 3.893-3.413 6.773c0 0.16 0 0.267 0 0.427 0 1.92 1.547 3.467 3.467 3.467s3.467-1.547 3.467-3.467c-0.053-0.16-0.053-0.32-0.107-0.48zM24.8 29.867c-1.333 0-2.4-1.067-2.4-2.4 0-0.107 0-0.16 0-0.267v0 0c0.16-1.6 1.387-3.68 2.347-5.12 0.96 1.387 2.187 3.52 2.4 5.067 0 0.107 0 0.213 0 0.32 0.053 1.333-1.013 2.4-2.347 2.4z" fill="#000000">
                                          
                                          </path>
                                          </svg>
                              
                                       
                                          <div class="item-title">
                                              <h3>CSS</h3>
                                              <p>add some Bueaty</p>
                                          </div>
                                      </li>
                                      <li>
                                        <!-- <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                        viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                        stroke-linecap="round" stroke-linejoin="round">
                                        <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                        <path d="M12 4l-8 4l8 4l8 -4l-8 -4" />
                                        <path d="M4 12l8 4l8 -4" />
                                        <path d="M4 16l8 4l8 -4" />
                                    </svg> -->
<!--                       dislike 
  <svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path opacity="0.15" d="M4.3314 12.0474L12 20L19.6686 12.0474C20.5211 11.1633 21 9.96429 21 8.71405C21 6.11055 18.9648 4 16.4543 4C15.2487 4 14.0925 4.49666 13.24 5.38071L12 6.66667L10.76 5.38071C9.90749 4.49666 8.75128 4 7.54569 4C5.03517 4 3 6.11055 3 8.71405C3 9.96429 3.47892 11.1633 4.3314 12.0474Z" fill="#000000"/>
<path d="M4.76786 12.5L12 20L19.2321 12.5M4.76786 12.5L4.3314 12.0474C3.47892 11.1633 3 9.96429 3 8.71405C3 6.11055 5.03517 4 7.54569 4C8.75128 4 9.90749 4.49666 10.76 5.38071L12 6.66667L13.24 5.38071C14.0925 4.49666 15.2487 4 16.4543 4C18.9648 4 21 6.11055 21 8.71405C21 9.96429 20.5211 11.1633 19.6686 12.0474L19.2321 12.5M4.76786 12.5H7.99997L8.99997 10.5L11 14.5L14 8L16 12.5H19.2321" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
                         home           <svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>
                          heart          <svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-heart"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                           facebook         <svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg>
                         image          <svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-image"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                       linkedin             <svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-linkedin"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg> -->
                       <!-- square             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>

                       -->
  <svg width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="icomoon-ignore">
</g>
<path d="M7.47 6.661l16.010 9.339-16.010 9.339v-18.678zM6.404 4.804v22.391l19.192-11.196-19.192-11.196z" fill="#000000">

</path>
</svg>
                                          <div class="item-title">
                                              <h3>Javascript</h3>
                                              <p>Create some magic with this</p>
                                          </div>
                                      </li>
                                      <li>
                                        
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline></svg>
                                          <div class="item-title">
                                              <h3>javascript_practice_Q/A</h3>
                                              <p>100 Q/A Challenge of js</p>
                                          </div>
                                      </li>
                                     
                                  </ul>
                              </div>
                          </div>
                          <!-- <a href="#docs" title="Docs">
                              Docs
                          </a> -->
                      </li>
                      <li>
                        <button>
                          DSA
                          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                              <path
                                  d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                              </path>
                          </svg>
                      </button>
            
            
            
            
                      <div class="dropdown__wrapper">
                          <div class="dropdown">
                              <ul class="list-items-with-description">
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><path d="M12.89 1.45l8 4A2 2 0 0 1 22 7.24v9.53a2 2 0 0 1-1.11 1.79l-8 4a2 2 0 0 1-1.79 0l-8-4a2 2 0 0 1-1.1-1.8V7.24a2 2 0 0 1 1.11-1.79l8-4a2 2 0 0 1 1.78 0z"></path><polyline points="2.32 6.16 12 11 21.68 6.16"></polyline>
                                      <line x1="12" y1="22.76" x2="12" y2="11"></line><line x1="7" y1="3.5" x2="17" y2="8.5"></line></svg>
                                   
                                      
                                      <div class="item-title">
                                          <h3>DSA</h3>
                                          <p>Learn Basic Structure </p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path></svg>
                                    <!-- <svg aria-hidden="true" width="24" height="24" viewBox="0 0 24 24"
                                    stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M3 20l1.3 -3.9a9 8 0 1 1 3.4 2.9l-4.7 1" />
                                </svg> -->
                                      <div class="item-title">
                                          <h3>Algorithms</h3>
                                          <p>Reduce the Complex</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>
                                      <!-- <svg xmlns="http://www.w3.org/2000/svg"
                                          class="icon icon-tabler icon-tabler-brand-nextjs" width="24" height="24"
                                          viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                          stroke-linecap="round" stroke-linejoin="round">
                                          <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                          <path d="M9 15v-6l7.745 10.65a9 9 0 1 1 2.255 -1.993" />
                                          <path d="M15 12v-3" />
                                      </svg> -->
                                      <div class="item-title">
                                          <h3>java API</h3>
                                          <p>The native Next.js platform</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M3 12h4l3 8l4 -16l3 8h4" />
                                </svg>
                                      <div class="item-title">
                                          <h3>Non_Lineas DS</h3>
                                          <p>Complexity speak</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                      <path d="M21 7L13 15L9 11L3 17M21 7H15M21 7V13" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                                      </svg>
                                      <div class="item-title">
                                          <h3>Linear DS</h3>
                                          <p>dividend of Structure</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                                      <g id="icomoon-ignore">
                                      </g>
                                      <path d="M6.937 21.865c-1.766 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM6.937 27.195c-1.176 0-2.132-0.956-2.132-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      <path d="M6.937 3.738c-1.766 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM6.937 9.069c-1.176 0-2.132-0.956-2.132-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      <path d="M6.937 12.779c-1.766 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM6.937 18.11c-1.176 0-2.132-0.957-2.132-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      <path d="M16 21.865c-1.767 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM16 27.195c-1.176 0-2.133-0.956-2.133-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      <path d="M16 3.738c-1.767 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM16 9.069c-1.176 0-2.133-0.956-2.133-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      <path d="M16 12.779c-1.767 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM16 18.11c-1.176 0-2.133-0.957-2.133-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      <path d="M25.063 21.865c-1.767 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM25.063 27.195c-1.176 0-2.133-0.956-2.133-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      <path d="M25.063 10.135c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198c-1.767 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199zM25.063 4.805c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133c-1.176 0-2.133-0.956-2.133-2.133s0.956-2.132 2.133-2.132z" fill="#000000">
                                      
                                      </path>
                                      <path d="M25.063 12.779c-1.767 0-3.199 1.432-3.199 3.198s1.432 3.199 3.199 3.199c1.766 0 3.199-1.432 3.199-3.199s-1.433-3.198-3.199-3.198zM25.063 18.11c-1.176 0-2.133-0.957-2.133-2.133s0.956-2.132 2.133-2.132c1.176 0 2.133 0.956 2.133 2.132s-0.956 2.133-2.133 2.133z" fill="#000000">
                                      
                                      </path>
                                      </svg>

                                      <div class="item-title">
                                          <h3>Pattern</h3>
                                          <p> Find Pattern on group</p>
                                          </div>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                           </li> 
                           <li>
            
                              <button>
                              Database
                              <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                                  <path
                                      d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                                  </path>
                              </svg>
                          </button>
            
            
                        
                         
            
                          <div class="dropdown__wrapper">
                              <div class="dropdown">
                                  <ul class="list-items-with-description">
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>
                                          
                                          <div class="item-title">
                                              <h3>AWS Services</h3>
                                              <p>Bunch of service </p>
                                          </div>
                                      </li>
                                      <li>
                                        <svg width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                                          <g id="icomoon-ignore">
                                          </g>
                                          <path d="M17.894 6.945c3.969 0 7.197 3.228 7.197 7.197 0 0.022-0.003 0.045-0.004 0.067-0.003 0.053-0.007 0.106-0.008 0.16l-0.027 1.088 1.090 0.004c2.637 0.007 4.783 2.16 4.783 4.797 0 2.63-2.141 4.782-4.773 4.796l-0.233 0.001h-19.517c-2.937-0.003-5.327-2.394-5.327-5.33 0-2.275 1.448-4.3 3.603-5.040l0.6-0.205 0.106-0.625c0.261-1.542 1.586-2.661 3.149-2.661 0.498 0 0.98 0.116 1.431 0.343l0.972 0.488 0.469-0.981c1.192-2.491 3.739-4.1 6.488-4.1zM17.894 5.878c-3.288 0-6.12 1.925-7.45 4.705-0.575-0.29-1.223-0.456-1.911-0.456-2.111 0-3.859 1.536-4.2 3.55-2.514 0.862-4.324 3.24-4.324 6.048 0 3.531 2.862 6.393 6.392 6.396l19.756-0.001c3.225-0.017 5.834-2.634 5.834-5.862 0-3.233-2.615-5.854-5.846-5.863 0.002-0.085 0.012-0.168 0.012-0.253 0-4.564-3.7-8.263-8.263-8.263v0z" fill="#000000">
                                          
                                          </path>
                                          </svg>
                                          <div class="item-title">
                                              <h3>Cloud Computing</h3>
                                              <p>Always fast always online</p>
                                          </div>
                                      </li>
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                              viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                              stroke-linecap="round" stroke-linejoin="round">
                                              <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                              <path d="M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0" />
                                              <path d="M4 6v6a8 3 0 0 0 16 0v-6" />
                                              <path d="M4 12v6a8 3 0 0 0 16 0v-6" />
                                          </svg>
                                          <div class="item-title">
                                              <h3>SQL</h3>
                                              <p>Play With Database</p>
                                          </div>
                                      </li>
                                      <li>
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline></svg>
                                          <div class="item-title">
                                              <h3>sql_practice_Q/A</h3>
                                              <p>100 Q/A Challenge of sql</p>
                                          </div>
                                      </li>
                                    
                                  </ul>
                              </div>
                          </div>
                       </li>
                          <!-- <a href="#templates" title="Templates">
                              font-end
                          </a> -->
                     
            
                      <li>
                       
                        <button>
                          SDLC/Networking
                          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                              <path
                                  d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                              </path>
                          </svg>
                      </button>
            
            
            
            
                      <div class="dropdown__wrapper">
                          <div class="dropdown">
                              <ul class="list-items-with-description">
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                                    viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none"
                                    stroke-linecap="round" stroke-linejoin="round">
                                    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
                                    <path d="M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0" />
                                    <path d="M3.6 9h16.8" />
                                    <path d="M3.6 15h16.8" />
                                    <path d="M11.5 3a17 17 0 0 0 0 18" />
                                    <path d="M12.5 3a17 17 0 0 1 0 18" />
                                </svg>
                                      
                                      <div class="item-title">
                                          <h3>Networking</h3>
                                          <p>Zero config, more innovation</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg width="800px" height="800px" viewBox="-2.5 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                                      <g id="icomoon-ignore">
                                      </g>
                                      <path d="M20.48 18.613l-1.12 7.84 7.627-1.173-2.987-3.040c1.013-1.867 1.6-3.947 1.6-6.24 0-7.093-5.707-12.8-12.8-12.8v1.067c6.453 0 11.733 5.28 11.733 11.733 0 1.973-0.48 3.787-1.333 5.44l-2.72-2.827zM20.587 25.173l0.64-4.267 3.52 3.627-4.16 0.64z" fill="#000000">
                                      
                                      </path>
                                      <path d="M1.067 16c0-2.827 1.013-5.387 2.667-7.413l3.253 3.307 1.12-7.84-7.627 1.227 2.453 2.56c-1.813 2.187-2.933 5.067-2.933 8.16 0 7.093 5.707 12.8 12.8 12.8v-1.067c-6.453 0-11.733-5.28-11.733-11.733zM6.827 5.387l-0.64 4.267-3.52-3.627 4.16-0.64z" fill="#000000">
                                      
                                      </path>
                                      </svg>
                                      <div class="item-title">
                                          <h3>SDLC</h3>
                                          <p>Principle| Design</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg width="800px" height="800px" viewBox="-1 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                                      <g id="icomoon-ignore">
                                      </g>
                                      <path d="M25.6 18.453l4.267-0.427v-4l-4.267-0.427c-0.267-1.28-0.8-2.453-1.44-3.467l2.4-3.2-2.453-2.453-3.2 2.4c-1.013-0.64-2.187-1.173-3.413-1.44l-0.48-4.267h-4l-0.48 4.267c-1.227 0.267-2.347 0.747-3.36 1.387l-3.307-2.347-2.453 2.453 2.347 3.307c-0.64 1.013-1.12 2.133-1.387 3.36l-4.267 0.48v4l4.267 0.48c0.267 1.227 0.8 2.4 1.44 3.467l-2.4 3.2 2.453 2.453 3.2-2.4c1.013 0.64 2.187 1.173 3.413 1.44l0.533 4.267h4l0.533-4.267c1.227-0.267 2.347-0.747 3.36-1.387l3.253 2.347 2.453-2.453-2.4-3.36c0.64-1.067 1.12-2.187 1.387-3.413zM28.8 14.933v2.080l-3.2 0.32c0.053-0.427 0.107-0.907 0.107-1.387s-0.053-0.907-0.107-1.387l3.2 0.373zM23.947 5.76l1.173 1.173-1.76 2.4c-0.533-0.693-1.12-1.28-1.813-1.813l2.4-1.76zM13.867 2.133h2.133l0.373 3.2c-0.48-0.053-0.96-0.107-1.387-0.107-0.48 0-0.96 0.053-1.387 0.107l0.267-3.2zM4.693 6.987l1.227-1.227 2.453 1.707c-0.373 0.267-0.693 0.587-1.013 0.907s-0.64 0.64-0.907 1.013l-1.76-2.4zM1.067 17.067v-2.133l3.2-0.373c-0.053 0.48-0.107 0.96-0.107 1.44s0.053 0.96 0.107 1.387l-3.2-0.32zM5.92 26.187l-1.173-1.12 1.76-2.4c0.533 0.64 1.12 1.28 1.76 1.76l-2.347 1.76zM16 29.867h-2.133l-0.373-3.2c0.48 0.053 0.96 0.107 1.44 0.107v0 0c0.48 0 0.96-0.053 1.44-0.107l-0.373 3.2zM14.933 25.653c-5.333 0-9.653-4.32-9.653-9.653 0-2.56 1.013-5.013 2.827-6.827s4.267-2.827 6.827-2.827v0c5.333 0 9.653 4.32 9.653 9.653 0 2.56-1.013 5.013-2.827 6.827s-4.213 2.827-6.827 2.827zM25.173 25.013l-1.173 1.173-2.453-1.76c0.373-0.267 0.693-0.587 1.013-0.907s0.587-0.64 0.907-1.013l1.707 2.507z" fill="#000000">
                                      
                                      </path>
                                      </svg>
                                      <div class="item-title">
                                          <h3>API</h3>
                                          <p>Understanding about Waiter</p>
                                      </div>
                                  </li>
                                
                              </ul>
                          </div>
                      </div>
            
                      </li>


                      <li>
                           
                        <button>
                          GitHub
                          <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
                              <path
                                  d="M12.78 5.22a.749.749 0 0 1 0 1.06l-4.25 4.25a.749.749 0 0 1-1.06 0L3.22 6.28a.749.749 0 1 1 1.06-1.06L8 8.939l3.72-3.719a.749.749 0 0 1 1.06 0Z">
                              </path>
                          </svg>
                      </button>
            
            
            
            
                      <div class="dropdown__wrapper">
                          <div class="dropdown">
                              <ul class="list-items-with-description">
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-activity"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
                                      
                                      <div class="item-title">
                                          <h3>github</h3>
                                          <p>Basics of Version Control</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M6 3v12"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/></g></svg>
                                      <div class="item-title">
                                          <h3>git command</h3>
                                          <p>work on local</p>
                                      </div>
                                  </li>
                                  <li>
                                    <svg width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                                      <g id="icomoon-ignore">
                                      </g>
                                      <path d="M27.18 22.949h-22.497l4.492-4.494-0.754-0.754-5.743 5.744 5.743 5.743 0.754-0.754-4.419-4.42h23.491v-9.596h-1.066z" fill="#000000">
                                      
                                      </path>
                                      <path d="M4.793 9.088h22.488l-4.456 4.457 0.754 0.754 5.742-5.742-5.743-5.744-0.754 0.754 4.454 4.456h-23.552v9.596h1.066z" fill="#000000">
                                      
                                      </path>
                                      </svg>
                                      <div class="item-title">
                                          <h3>git Action</h3>
                                          <p>CI/CD Pipeline</p>
                                      </div>
                                  </li>
                                 
                              </ul>
                          </div>
                      </div>
            
                      </li>
                      <li>
                        <button type="button" class="btn cancel" onclick="nonview()">
                          <svg width="20px" height="20px" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.32129 2.32363C2.72582 1.9191 3.38168 1.9191 3.78621 2.32363L25.6966 24.234C26.1011 24.6385 26.1011 25.2944 25.6966 25.6989C25.2921 26.1035 24.6362 26.1035 24.2317 25.6989L2.32129 3.78854C1.91676 3.38402 1.91676 2.72815 2.32129 2.32363Z" fill="#ffffff"/>
                            <path d="M25.6787 2.30339C25.2742 1.89887 24.6183 1.89887 24.2138 2.30339L2.30339 24.2138C1.89887 24.6183 1.89887 25.2742 2.30339 25.6787C2.70792 26.0832 3.36379 26.0832 3.76831 25.6787L25.6787 3.76831C26.0832 3.36379 26.0832 2.70792 25.6787 2.30339Z" fill="#ffffff"/></svg>
                      </button>
                    </li>
                      
                  </ul>
                </div>
            
              </nav>
            </div>
            </div>
            



 <div class="text">
    <pre>
            
        
        Classes:
        Collections: Provides utility methods for working with collections, like sorting and searching.
        ArrayList: Implements a resizable array.
        LinkedList: Implements a doubly-linked list.
        HashMap: Implements a hash table for key-value pairs.
        HashSet: Implements a set using a hash table.
        Hashtable: An obsolete class representing a hash table (use HashMap instead).
        LinkedHashMap: Extends HashMap to maintain the order of insertion.
        LinkedHashSet: Extends HashSet to maintain the order of insertion.
        PriorityQueue: Implements a priority queue using a heap.
        Properties: Represents a persistent set of properties (key-value pairs).
        Stack: Represents a last-in, first-out stack of objects.
        TreeMap: Implements a map using a red-black tree.
        TreeSet: Implements a set using a red-black tree.
        Vector: An obsolete class representing a growable array of objects (use ArrayList instead).
        
        Interfaces:
        Collection: The root interface for all collection classes.
        List: Extends Collection to represent an ordered collection (allows duplicate elements).
        Set: Extends Collection to represent a collection with no duplicate elements.
        Map: Represents a collection of key-value pairs.
        Queue: Represents a collection used to hold multiple elements before processing.
        Deque: Extends Queue to represent a double-ended queue.
        Iterator: Allows iterating over elements in a collection.
        ListIterator: Extends Iterator to allow bidirectional iteration of a list.
        Map.Entry: Represents a key-value pair in a Map.
        Enumeration: Represents a series of elements (used in legacy classes like Vector).
          </pre>
        
 </div>


 <div class="text1">
    <h1>String</h1>
    <details>
        <summary>
          <span class="faq-title"> 
            <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
          <img src="plus.svg" class="expand-icon" alt="Plus">
        </summary>        
        <div class="faq-content">
        <pre><code>
          STRING 
    
          public static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;
          public java.lang.String();
          public java.lang.String(java.lang.String);
          public java.lang.String(char[]);
          public java.lang.String(char[], int, int);
          public java.lang.String(int[], int, int);
          public java.lang.String(byte[], int, int, int);
          public java.lang.String(byte[], int);
          public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
          public java.lang.String(byte[], int, int, java.nio.charset.Charset);
          public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException;
          public java.lang.String(byte[], java.nio.charset.Charset);
          public java.lang.String(byte[], int, int);
          public java.lang.String(byte[]);
          public java.lang.String(java.lang.StringBuffer);
          public java.lang.String(java.lang.StringBuilder);
          public int length();
          public boolean isEmpty();
          public char charAt(int);
          public int codePointAt(int);
          public int codePointBefore(int);
          public int codePointCount(int, int);
          public int offsetByCodePoints(int, int);
          public void getChars(int, int, char[], int);
          public void getBytes(int, int, byte[], int);
          public byte[] getBytes(java.lang.String) throws java.io.UnsupportedEncodingException;
          public byte[] getBytes(java.nio.charset.Charset);
          public byte[] getBytes();
          public boolean equals(java.lang.Object);
          public boolean contentEquals(java.lang.StringBuffer);
          public boolean contentEquals(java.lang.CharSequence);
          public boolean equalsIgnoreCase(java.lang.String);
          public int compareTo(java.lang.String);
          public int compareToIgnoreCase(java.lang.String);
          public boolean regionMatches(int, java.lang.String, int, int);
          public boolean regionMatches(boolean, int, java.lang.String, int, int);
          public boolean startsWith(java.lang.String, int);
          public boolean startsWith(java.lang.String);
          public boolean endsWith(java.lang.String);
          public int hashCode();
          public int indexOf(int);
          public int indexOf(int, int);
          public int lastIndexOf(int);
          public int lastIndexOf(int, int);
          public int indexOf(java.lang.String);
          public int indexOf(java.lang.String, int);
          public int lastIndexOf(java.lang.String);
          public int lastIndexOf(java.lang.String, int);
          public java.lang.String substring(int);
          public java.lang.String substring(int, int);
          public java.lang.CharSequence subSequence(int, int);
          public java.lang.String concat(java.lang.String);
          public java.lang.String replace(char, char);
          public boolean matches(java.lang.String);
          public boolean contains(java.lang.CharSequence);
          public java.lang.String replaceFirst(java.lang.String, java.lang.String);
          public java.lang.String replaceAll(java.lang.String, java.lang.String);
          public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);
          public java.lang.String[] split(java.lang.String, int);
          public java.lang.String[] split(java.lang.String);
          public static java.lang.String join(java.lang.CharSequence, java.lang.CharSequence...);
          public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable<? extends java.lang.CharSequence>);
          public java.lang.String toLowerCase(java.util.Locale);
          public java.lang.String toLowerCase();
          public java.lang.String toUpperCase(java.util.Locale);
          public java.lang.String toUpperCase();
          public java.lang.String trim();
          public java.lang.String strip();
          public java.lang.String stripLeading();
          public java.lang.String stripTrailing();
          public boolean isBlank();
          public java.util.stream.Stream<java.lang.String> lines();
          public java.lang.String indent(int);
          public java.lang.String stripIndent();
          public java.lang.String translateEscapes();
          public <R> R transform(java.util.function.Function<? super java.lang.String, ? extends R>);
          public java.lang.String toString();
          public java.util.stream.IntStream chars();
          public java.util.stream.IntStream codePoints();
          public char[] toCharArray();
          public static java.lang.String format(java.lang.String, java.lang.Object...);
          public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object...);
          public java.lang.String formatted(java.lang.Object...);
          public static java.lang.String valueOf(java.lang.Object);
          public static java.lang.String valueOf(char[]);
          public static java.lang.String valueOf(char[], int, int);
          public static java.lang.String copyValueOf(char[], int, int);
          public static java.lang.String copyValueOf(char[]);
          public static java.lang.String valueOf(boolean);
          public static java.lang.String valueOf(char);
          public static java.lang.String valueOf(long);
          public static java.lang.String valueOf(float);
          public static java.lang.String valueOf(double);
          public native java.lang.String intern();
          public java.lang.String repeat(int);
          public java.util.Optional<java.lang.String> describeConstable();
          public java.lang.String resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);
          public int compareTo(java.lang.Object);
          public java.lang.Object resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException;
        </code></pre>
  
        <h2> public static final java.util.Comparator<java.lang.String> CASE_INSENSITIVE_ORDER;</h2>
          <p>the stringList is sorted using the CASE_INSENSITIVE_ORDER comparator, which ensures that the strings are sorted in a case-insensitive manner</p>
  
  <pre><code>
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.List;
    
    public class stringbuildin {
        public static void main(String[] args) {
            List<String> stringList = new ArrayList<>();
            stringList.add("apple");
            stringList.add("Banana");
            stringList.add("Orange");
            stringList.add("grapes");
    
            // Sorting the list using CASE_SENSITIVE_ORDER comparator
            Collections.sort(stringList);
              for (String str : stringList) {
                System.out.println(str);
            }
      //output      // Banana
                    // Orange
                    // apple
                    // grapes
    
            Collections.sort(stringList, String.CASE_INSENSITIVE_ORDER);
            System.out.println();
            for (String str : stringList) {
                System.out.println(str);
            }
       //output      // apple
                    // Banana
                    // grapes
                    // Orange
    
        }
    }
  </code></pre>
       
  <h2> 
    public java.lang.String(); <br>
    public java.lang.String(java.lang.String); <br>
    public java.lang.String(char[]); <br>
    public java.lang.String(char[], int, int); <br>
    public java.lang.String(int[], int, int); <br>
    public java.lang.String(byte[], int, int, int); <br>
    public java.lang.String(byte[], int); <br>
    public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException; <br>
    public java.lang.String(byte[], int, int, java.nio.charset.Charset); <br>
    public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException; <br>
    public java.lang.String(byte[], java.nio.charset.Charset); <br>
    public java.lang.String(byte[], int, int); <br>
    public java.lang.String(byte[]); <br>
    public java.lang.String(java.lang.StringBuffer); <br>
    public java.lang.String(java.lang.StringBuilder); <br>
  </h2>
  <p> public java.lang.String();, appears to be a constructor declaration for the String class in Java. constructors are not explicitly declared like this in the source code. Constructors are special methods used for initializing objects when they are created. The String class in Java has several constructors, but they are not declared using the public java.lang.String(); syntax.</p>
  <pre><code>
    import java.io.UnsupportedEncodingException;
  
  public class createstring {
      public static void main(String[]args) throws UnsupportedEncodingException{
  
          String str1 = "Hello"; // Using a string literal
  
          String originalString1 = "Hello";
          String str5 = new String(originalString1); // String created from another string object
  
          String originalString = "Hello, World!";
          String substring = new String(originalString.substring(0, 5)); // Using a substring
  
          String str8 = new String("Hello".getBytes()); // String created from byte array using the platform's default charset
  
          String str = "Hello, World!";//(A-Z==65-91) (a-z==97-123)
          byte[] byteArray = str.getBytes();//output - 72 101 108 108 111 44 32 87 111 114 108 100 33 
  
  
          //public java.lang.String(); 
           String emptyString = new String(); // Creates an empty string
  
          //public java.lang.String(java.lang.String);
           String originalString = "Hello, World!";
           String newString = new String(originalString); 
  
          //public java.lang.String(byte[], int);
           byte[] byteArray = {72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33};
           String strFromBytes = new String(byteArray, 0);
      
          //public java.lang.String(char[]);
          char[] charArray = {'H', 'e', 'l', 'l', 'o'};
          String str2 = new String(charArray); // Using a character array
  
          //public java.lang.String(char[], int, int);
          char[] charArray1 = {'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd'};
          String str3 = new String(charArray1, 0, 5); // Creates a string from charArray starting from index 0 with length 5
         
          //public java.lang.String(int[], int, int);
          int[] codePoints = {72, 101, 108, 108, 111};
          String strFromCodePoints = new String(codePoints, 0,5);
       
          //public java.lang.String(byte[], int, int, int);
          byte[] byteArray = {72, 101, 108, 108, 111};
          String strFromBytes = new String(byteArray, 0, 5, StandardCharsets.UTF_8);
  
  
          //public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
          byte[] byteArray = {-50, -77, -48, -68, 44, 32, -48, -71, -48, -65, -48, -66, -48, -64, -48, -65, -48, -72, -48, -69, -48, -68, -48, -70, 33};
          try {
              String strFromBytes = new String(byteArray, 0, 24, "UTF-8");
              System.out.println("String from bytes: " + strFromBytes);
          } 
          catch (UnsupportedEncodingException e) {
              // Handle the exception (e.g., print an error message)
              e.printStackTrace();
          }
  
          //public java.lang.String(byte[], java.lang.String) throws java.io.UnsupportedEncodingException;
          byte[] byteArray = {-50, -77, -48, -68, 44, 32, -48, -71, -48, -65, -48, -66, -48, -64, -48, -65, -48, -72, -48, -69, -48, -68, -48, -70, 33};
          try {
              String strFromBytes = new String(byteArray, "UTF-8");
              System.out.println("String from bytes: " + strFromBytes);
          } 
          catch (UnsupportedEncodingException e) {
              // Handle the exception (e.g., print an error message)
              e.printStackTrace();
          }
  
  
          //public java.lang.String(java.lang.StringBuilder);
          StringBuilder stringBuilder = new StringBuilder("Hello");
          String str6 = new String(stringBuilder); // String created from StringBuilder
  
          //public java.lang.String(java.lang.StringBuffer);
          StringBuffer stringBuffer = new StringBuffer("Hello");
          String str7 = new String(stringBuffer); // String created from StringBuffer
  
          //import java.io.UnsupportedEncodingException;
          //public java.lang.String(byte[], int, int, java.lang.String) throws java.io.UnsupportedEncodingException;
          byte[] byteArray2 = str.getBytes("UTF-8"); (unicode transformation formate) //throw unsupportedexception 
          byte[] byteArray3 = str.getBytes(java.nio.charset.StandardCharsets.UTF_8);
  
          //public java.lang.String(byte[], int, int, java.nio.charset.Charset);
          byte[] byteArray = {72, 101, 108, 108, 111};
          String byteArray4 = new String(byteArray,0,3,StandardCharsets.UTF_8);
       
  
          //public java.lang.String(byte[], java.nio.charset.Charset);
          byte[] byteArray = {72, 101, 108, 108, 111};
          String byteArray4 = new String(byteArray,StandardCharsets.UTF_8);
  
          //public java.lang.String(byte[], int, int);
          byte[] byteArray = {72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33}; //hello world
          String strFromBytes = new String(byteArray, 0, 5);
  
          //public java.lang.String(byte[]);
          byte[] byteArray = {72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33}; // ASCII values for "Hello, World!"
          String strFromBytes = new String(byteArray);
  
          //In Java, the getBytes() method in the String class is used to encode the string into a sequence of bytes using the platform's default charset and returns the resulting byte array. 
  
  
      }
  }
  </code></pre>
  <h2> public int length();</h2>
  <p>The length() method in Java is a member of the String class. It returns the length (the number of characters) of the string</p>
        <pre>
          <code>
          1. //.length();
            public class StringLengthExample {
              public static void main(String[] args) {
                  String str = "Hello, World!";
                  int length = str.length();         
                  System.out.println("Length of the string: " + length);
              }
          }
  
         2. //without inbuild function
          public class StringLengthWithoutLengthMethod {
            public static void main(String[] args) {
              String str = "Hello, World!";
              int length = calculateStringLength(str);
              System.out.println("Length of the string: " + length);
          }
  
            public static int calculateStringLength(String str) {
                int length = 0;
                char[] charArray = str.toCharArray();
                for (char ch : charArray) {
                    length++;
                }
                return length;
            }
        }
      </code>
        </pre>
  
        <h2> public boolean isEmpty();</h2>
  <p>The isEmpty() method in Java is a member of the String class. It returns true if the string length is 0 (i.e., the string does not contain any characters), and false </p>
  <pre>
    <code>
      1.//isEmpty()
      public class StringIsEmptyExample {
  
        public static void main(String[] args) {
            String str1 = ""; 
            String str2 = "Hello, World!";
           
            boolean isEmpty1 = str1.isEmpty();
            boolean isEmpty2 = str2.isEmpty();
          
            System.out.println("Is str1 empty? " + isEmpty1); // Output: Is str1 empty? true
            System.out.println("Is str2 empty? " + isEmpty2); // Output: Is str2 empty? false
        }
    }
  
    2.//without buildin 
    public class StringIsEmptyWithoutBuiltInExample {
  
      public static void main(String[] args) {
        String str1 = ""; 
        String str2 = "Hello, World!"; 
      
        boolean isEmpty1 = isEmptyString(str1);
        boolean isEmpty2 = isEmptyString(str2);
  
        System.out.println("Is str1 empty? " + isEmpty1); // Output: Is str1 empty? true
        System.out.println("Is str2 empty? " + isEmpty2); // Output: Is str2 empty? false
    }
  
      public static boolean isEmptyString(String str) {
         1. //return str.length() == 0;
  
         2. // for (int i = 0; i < str.length(); i++) {
          //  if (str.charAt(i) != ' ') {
          //      return false;  }
          // } return true;  
  
         3. //return str.equals("");
          }
  }
  
    
    </code>
  </pre>
  <h2>public char charAt(int);</h2>
  <p>The charAt(int index) method in Java is a member of the String class. It returns the character at the specified index within the string. </p>
     
  <pre>
   <code>
    1.//.charAt()
    public class CharAtExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
        
          char character = str.charAt(7);
          System.out.println("Character at index 7: " + character); // Output: Character at index 7: W
      }
  }
  
    2.//without buildin
  
    public class GetCharacterWithoutBuiltInExample {
  
      public static void main(String[] args) {
        String str = "Hello, World!";
        int index = 7;
        char character = getCharacterAtIndex(str, index);
        System.out.println("Character at index " + index + ": " + character); // Output: Character at index 7: W
    }
  
      public static char getCharacterAtIndex(String str, int index) {
          if (index >= 0 && index < str.length()) {
              return str.toCharArray()[index];
          }
          else {
              return '\0'; 
          }  
      }
  }
   </code>
  </pre>
  <h2>public int codePointAt(int);</h2>
  <p>
    The codePointAt(int index) method in Java is a member of the String class. It returns the Unicode code point of the character at the specified index within the string. </p>
  <pre><code>
  1.//.codePointAt()
    public class CodePointAtExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
        
          int codePoint = str.codePointAt(7); //w
          System.out.println("Unicode code point at index 7: " + codePoint); // Output: Unicode code point at index 7: 87
      }
  }
  
  
  2.//without buildin 
    public class highorlowsurrogate {
      public static void main(String[] args) {
            String str = "Hello, World!";
            int index = 7; 
    
            int unicodeCodePoint = getUnicodeCodeAtPosition(str, index);
            System.out.println(  "Unicode code point at index " + index +" of character is "+str.charAt(index)+ ": " + unicodeCodePoint); // Output: Unicode code point at index 7: 87
        }
  
        public static int getUnicodeCodeAtPosition(String str, int index) {
            // Check if the index is valid
            if (index >= 0 && index < str.length()) {
                char charAtIndex = str.charAt(index);
            //UTF-16
                if (Character.isHighSurrogate(charAtIndex) && index + 1 < str.length()) {    // If the character is a surrogate pair (UTF-16 supplementary character)
                    char lowSurrogate = str.charAt(index + 1);
                    if (Character.isLowSurrogate(lowSurrogate)) {
                      
                        return Character.toCodePoint(charAtIndex, lowSurrogate);  // Calculate and return the Unicode code point for the surrogate pair
                    }
                }
                //The Unicode code point values for  high surrogates range from '\uD800' to '\uDBFF'. In decimal, these values are from 55296 to 56319.
                //The Unicode code point values for low surrogates range from '\uDC00' to '\uDFFF'. In decimal, these values are from 56320 to 57343.
              
                // If the character is not a surrogate pair, return its Unicode code point
                return (int) charAtIndex;
            } 
            else {
                return -1;
            }
        }
   }
  </code></pre>
  
  
  <h2>  public int codePointBefore(int);</h2>
  <p>The codePointBefore(int index) method in Java is a member of the String class. It returns the Unicode code point of the character preceding(before) the specified index within the string. </p>
  <pre><code>
    1.//.codePointBefore()
    public class codebefore {
      public static void main(String[] args) {
          String str = "Hello, World!";
          int index = 8; 
  
          int codePoint = str.codePointBefore(index);
  
          System.out.println("Unicode code point before index " + index + ": " + codePoint); // Output: Unicode code point before index 8: 32
      //current index is 8 : o (but it will print  before the index of 8, character is W :87)
      }
  }
  
  
  2.//without buildin
  public class codebefore {
    public static void main(String[] args) {
          String str = "Hello, World!";
          int index = 8; 
  
          int unicodeCodePoint = codePointBefore(str, index);
          System.out.println("Unicode code point before index " + index + ": " + unicodeCodePoint); // Output: Unicode code point before index 8: 32
      }
  
      public static int codePointBefore(String str, int index) {
          if (index > 0 && index < str.length()) {
              char currentChar = str.charAt(index-1);
             
              if (Character.isLowSurrogate(currentChar)) {
                  char lowSurrogate = currentChar;
                  char highSurrogate = str.charAt(index - 1);
                
                  if (Character.isHighSurrogate(highSurrogate)) {
                      return Character.toCodePoint(highSurrogate, lowSurrogate);
                  }
              }
              return (int) currentChar;
          }
          return -1;
      }
  }
  </code></pre>
  
  <h2> public int codePointCount(int, int);</h2>
  <p>The codePointCount(int beginIndex, int endIndex) method in Java is a member of the String class. It returns the number of Unicode code points in the specified text range of the string.</p>
  <pre><code>
    1.//.codePointCount()
    public class codepointCount {
      public static void main(String[] args) {
          String str = "Hello,😊😊World!."; // String with Unicode and non-Unicode characters
          String str1 = "Hello,World!."; 
            System.out.println(str.length());   
       
          int codePointCount = str.codePointCount(0, 8); //index(0-8)=>(Hello,😊😊) surrogate pair of emoji represent single unicode character
          int codePointCount1 = str1.codePointCount(0, 8);// index (0-8)=>(Hello,Wo) 
  
  
          System.out.println("Number of Unicode code points: " + codePointCount); // Output: Number of Unicode code points: 7
         System.out.println("Number of Unicode code points: " + codePointCount1);//Output: Number of Unicode code points: 8
      }       
  }
  </code></pre>
  
  
  <h2>public int offsetByCodePoints(int, int);</h2>
  <p>The offsetByCodePoints(int index, int codePointOffset) method in Java is a member of the String class. It calculates the index that is offset from a given index by a specified number of Unicode code points. <br> <br>
    <br>
    Text Processing: When processing natural language text, especially in languages with complex scripts or when dealing with emojis and other symbols, offsetByCodePoints helps in iterating through text characters regardless of whether they are within the BMP or outside it.
  <br>
  Cursor Movement in User Interfaces: In graphical user interfaces, when users are allowed to navigate through text using arrow keys, offsetByCodePoints can help move the cursor position accurately within the text, even if it contains characters represented by surrogate pairs
  </p>
  <pre><code>
    public static void main(String[] args) {
      String text = "Hello,😊World!";
      int index = 0;
  
      while (index < text.length()) {
          int codePoint = text.codePointAt(index);
          System.out.println("Code Point at index " + index + ": " + codePoint);
          index = text.offsetByCodePoints(index, 1);
      }
  }
  </code></pre>
  
  
  <h2>  public void getChars(int, int, char[], int);</h2>
  <p> The getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) method is a member of the String class in Java. It allows you to copy characters from a portion of the string (from srcBegin index to srcEnd - 1 index) into a character array dst, starting at the specified dstBegin index.</p>
  <ol>
    <li>  srcBegin: The starting index of the substring within the string.</li>
    <li>srcEnd: The ending index of the substring within the string (exclusive, i.e., the character at srcEnd index is not included).</li>
    <li>dst: The destination character array where the characters will be copied.</li>
    <li>dstBegin: The starting index in the destination character array where the characters will be placed.</li>
  </ol>
  
  <pre><code>
    public class get {
      public static void main(String[] args) {
          String str = "Hello, World!";
          char[] charArray = new char[10]; // Destination character array
  
          str.getChars(7, 13, charArray, 0);
  
          for (char c : charArray) {
              System.out.print(c); // Output: World!
          }
      }
  }
  </code></pre>
  
  
  <h2>public void getBytes(int, int, byte[], int);</h2>
  <p>The getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) method in Java is a member of the String class. It allows you to encode characters from a portion of the string (from srcBegin index to srcEnd - 1 index) into a byte array dst, starting at the specified dstBegin index.</p>
  <p>use: <br>"UTF-8" is a string literal representing the name of the UTF-8 character encoding. <br>when creating a BufferedReader or PrintWriter with UTF-8 encoding, you can use this string literal</p>
  <pre><code>
    public class GetBytesExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
          byte[] byteArray = new byte[10]; // Destination byte array
  
          str.getBytes(7, 16, byteArray, 0);
  
          System.out.println("Encoded bytes in the byteArray:");
          for (byte b : byteArray) {
              System.out.print(b + " "); // Output: 87 111 114 108 100 33 32 32 32 32
          }
      }
  }
  
  </code></pre>
  
  <h2>public byte[] getBytes(java.lang.String) throws java.io.UnsupportedEncodingException;</h2>
  <p>The getBytes(String charsetName) method in Java is a member of the String class. It allows you to encode the string into a sequence of bytes using the specified character encoding,</p>
  <p> use : <br>when using the getBytes(Charset charset) method of the String class or when working with classes from the java.nio.charset package.</p>
  <pre><code>
    import java.io.UnsupportedEncodingException;
  public class get {
      public static void main(String[] args) {
          String str = "Hello, World!";
      
          try {
              byte[] byteArray = str.getBytes("UTF-8");
  
              for (byte b : byteArray) {
                  System.out.print(b + " ");
              }
          } 
          catch (UnsupportedEncodingException e) {
              System.out.println("Unsupported encoding: " );
          }
      }
  }
  </code></pre>
  
  
  <h2>public byte[] getBytes();</h2>
  <p>The getBytes() method in Java is a member of the String class. It encodes the string into a sequence of bytes using the platform's default character encoding and returns the resulting byte array.</p>
  <pre><code>
  public class get {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          byte[] byteArray = str.getBytes();
  
          for (byte b : byteArray) {
              System.out.print(b + " ");
          }
      }
  }
  </code></pre>
  
  
  <h2> public boolean equals(java.lang.Object);</h2>
  <p>When you use the equals method to compare instances of your custom class, it will use the overridden logic for equality comparison. This allows you to define equality based on the specific attributes or criteria that are meaningful for your class.</p>
  <pre><code>
  
    public class Person {
  
      public static void main(String[] args) {
        Person person1 = new Person("Alice", 30);
        Person person2 = new Person("Bob", 25);
        Person person3 = new Person("Alice", 30);
  
        // Compare persons for equality
        System.out.println("person1 equals person2: " + person1.equals(person2)); // Output: false
        System.out.println("person1 equals person3: " + person1.equals(person3)); // Output: true
    }
  
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
  
      // Getters and other methods...
      @Override
      public boolean equals(Object obj) {
          if (this == obj) {
              return true;
          }
          if (obj == null || getClass() != obj.getClass()) {
              return false;
          }
          Person person = (Person) obj;
          return age == person.age && name.equals(person.name);
      }
  }
  
  </code></pre>
  
  <h2>public boolean contentEquals(java.lang.StringBuffer);</h2>
  <p>The contentEquals(StringBuffer sb) method in Java is a member of the String class. It checks whether the content of the current string is equal to the content of the specified StringBuffer object sb.</p>
  <p>This method is specific to the String class and checks if the content of the current String object is equal to the content of the specified StringBuffer object sb.</p>
  
  <pre><code>
    public class ContentEqualsExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
          StringBuffer stringBuffer = new StringBuffer("Hello, World!");
  
          boolean isEqual = str.contentEquals(stringBuffer);
  
          System.out.println("Content is equal: " + isEqual); // Output: Content is equal: true
      }
  }
  </code></pre>
  
  
  
  <h2>public boolean contentEquals(java.lang.CharSequence);</h2>
  <p>This method is also specific to the String class, but it accepts any object that implements the CharSequence interface, such as String, StringBuilder, and StringBuffer.</p>
  <pre><code>
    public class ContentEqualsExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
          StringBuilder stringBuilder = new StringBuilder("Hello, World!");
  
          boolean isEqual = str.contentEquals(stringBuilder);
  
          System.out.println("Content is equal: " + isEqual); // Output: Content is equal: true
      }
  }
  </code></pre>
  
  
  
  <h2>public boolean equalsIgnoreCase(java.lang.String);</h2>
  <p>The equalsIgnoreCase(String anotherString) method in Java is a member of the String class. It compares the current string with another string (specified by anotherString) without considering their case. It checks if the characters in both strings are equal when converted to lowercase (or uppercase) characters.</p>
  <pre><code>
    public class EqualsIgnoreCaseExample {
      public static void main(String[] args) {
          String str1 = "Hello, World!";
          String str2 = "hello, world!";
  
          boolean isEqual = str1.equalsIgnoreCase(str2);
  
          System.out.println("Strings are equal ignoring case: " + isEqual); // Output: Strings are equal ignoring case: true
      }
  }
  </code></pre>
  
  
  <h2>public int compareTo(java.lang.String);</h2>
  <p>The compareTo(String anotherString) method in Java is a member of the String class. It compares the current string lexicographically (based on the Unicode values of characters) with another string (anotherString). The comparison is case-sensitive, meaning uppercase and lowercase characters are treated differently.</p>
  <pre><code>
    public class get {
      public static void main(String[] args) {
          String str1 = "apple";
          String str2 = "orange";
  
          // Compare strings lexicographically
          int result = str1.compareTo(str2);
  
        //Since 'a' (97) comes before 'o' (111) in Unicode order, the result of the comparison is negative.
        //Specifically, the difference between the Unicode values of 'o' and 'a' is 111 - 97 = -14.
          if (result < 0) {    //negative
              System.out.println("str1 comes before str2");
          } 
          else if (result > 0) {  //positive
              System.out.println("str1 comes after str2");
          } 
          else { //equal
              System.out.println("str1 and str2 are equal");
          }
      }
  }
  </code></pre>
  
  <h2>public int compareToIgnoreCase(java.lang.String);</h2>
  <p>The compareToIgnoreCase(String anotherString) method in Java is a member of the String class. It compares the current string lexicographically (based on Unicode values of characters) with another string (anotherString), ignoring case differences. The comparison is case-insensitive, meaning uppercase and lowercase characters are treated the same way.</p>
  <pre><code>
    public class get {
      public static void main(String[] args) {
          String str1 = "apple";
          String str2 = "Orange";
  
          // Compare strings lexicographically ignoring case differences
          int result = str1.compareToIgnoreCase(str2);
  
          if (result < 0) {
              System.out.println("str1 comes before str2");
          } else if (result > 0) {
              System.out.println("str1 comes after str2");
          } else {
              System.out.println("str1 and str2 are equal ignoring case");
          }
      }
      // In this example, str1 and str2 are compared lexicographically ignoring case differences. Since "apple" comes before "Orange" in dictionary order (when ignoring case), 
      // result will be a negative integer, indicating that str1 comes before str2. If the two strings were equal ignoring case, result would be 0. If str1 came after str2 ignoring case, result would be a positive integer.
  }
  </code></pre>
  
  
  <h2>public boolean regionMatches(int, java.lang.String, int, int);</h2>
  <p>The regionMatches(int toffset, String other, int ooffset, int length) method in Java is a member of the String class. It checks whether a specific region of the current string matches the specified region of another string (other).</p>
  <ol>
    <li>toffset: The starting index of the region in the current string.</li>
    <li>other: The string to be compared with.</li>
    <li>ooffset: The starting index of the region in the other string.</li>
    <li>length: The number of characters to compare in both strings.</li>
  </ol>
  <pre><code>
    public class RegionMatchesExample {
      public static void main(String[] args) {
          String str1 = "Hello, World!";
          String str2 = "World";
  
          boolean matches = str1.regionMatches(7, str2, 0, 5);
  
          System.out.println("Region matches: " + matches); // Output: Region matches: true
      }
  }
  
  </code></pre>
  
  
  <h2>public boolean regionMatches(boolean, int, java.lang.String, int, int);</h2>
  <p>The Java String regionMatches() method checks whether the two strings regions are equivalent or not. It compares a substring of the current object to a substring of the given String.</p>
  <ol>
    <li>ignoreCase : If true, ignore case, when comparing characters. # second syntax</li>
    <li>toffset : The starting offset of the subregion in this string.</li>
    <li>other : The string argument.</li>
    <li>ooffset : The starting offset of the subregion in the string argument.</li>
    <li>len : The number of characters to compare.</li>
  </ol>
  <pre><code>
    public class get {
      public static void main(String[] args) {
          String str1 = "Collection of tutorials";
          String str2 = "Consists of different tutorials";
          /* matches characters from index 14 in str1 to characters from  index 22 in str2 considering same case of the letters */
          
          boolean match1 = str1.regionMatches(14, str2, 22, 9);
          System.out.println("region matched = " + match1); //true 
  
          /* considering different case, "true" is set which will ignore   case when matched */
          str2 = "Consists of different Tutorials";
          match1 = str1.regionMatches(true, 14, str2, 22, 9); 
          System.out.println("region matched = " + match1);   //true 
       }
      }
  </code></pre>
  
  
  <h2>public boolean startsWith(java.lang.String, int);</h2>
  <p>The startsWith(String prefix, int toffset) method in Java is a member of the String class. It checks whether a substring of the current string, starting from the specified index toffset, starts with the specified prefix.</p>
  <ol>
    <li>prefix: The prefix to be checked.</li>
    <li>toffset: The starting index in the current string where the comparison should begin.</li>
  </ol>
  <pre><code>
    public class StartsWithExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
          String prefix = "World";
  
          boolean startsWith = str.startsWith(prefix, 7)
  
          System.out.println("Substring starts with prefix: " + startsWith); // Output: Substring starts with prefix: true
      }
  }
  
  </code></pre>
  
  
  <h2>public boolean startsWith(java.lang.String);</h2>
  <p> The startsWith(String prefix) method in Java is a member of the String class. It checks whether the current string starts with the specified prefix</p>
  <pre><code>
    public class StartsWithExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
          String prefix = "Hello";
  
          boolean startsWith = str.startsWith(prefix);
  
          System.out.println("String starts with prefix: " + startsWith); // Output: String starts with prefix: true
      }
  }
  
  </code></pre>
  
  
  <h2>public boolean endsWith(java.lang.String);</h2>
  <p>The endsWith(String suffix) method in Java is a member of the String class. It checks whether the current string ends with the specified suffix.</p>
  <pre><code>
    public class EndsWithExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
          String suffix = "World!";
  
          boolean endsWith = str.endsWith(suffix);
  
          System.out.println("String ends with suffix: " + endsWith); // Output: String ends with suffix: true
      }
  }
  
  </code></pre>
  
  <h2>public int hashCode();</h2>
  <p>The hashCode() method in Java is a member of the Object class, and it is also overridden in the String class. This method returns a hash code value for the object, which is used in hash-based collections like HashMap, HashSet, etc., to improve the performance of data retrieval operations.</p>
  <p>use: <br>
  Hash-based Collections: Hash-based data structures use hash codes to determine the index at which an object should be stored or looked up in the underlying array. This allows for constant-time complexity (O(1)) for insertion, deletion, and retrieval operations, on average, making these operations very fast even for large data sets.</p>
  <p>In this example, hashCode1 and hashCode2 will have the same value because the hashCode() method generates the hash code based on the content of the strings, not their memory addresses. If two strings have the same content, they will have the same hash code.</p>
  <pre><code>
  public class HashCodeExample {
      public static void main(String[] args) {
          String str1 = "Hello, World!";
          String str2 = "Hello, World!";
  
          int hashCode1 = str1.hashCode();
          int hashCode2 = str2.hashCode();
  
          System.out.println("Hash Code for str1: " + hashCode1); // Output: Hash Code for str1: -862545276
          System.out.println("Hash Code for str2: " + hashCode2); // Output: Hash Code for str2: -862545276
      }
  }
  
  </code></pre>
  
  
  <h2>public int indexOf(int);</h2>
  <p>The indexOf(int ch) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified character (Unicode code point) in the string. If the character is not found, it returns -1.</p>
  <pre><code>
  1.  //.indexOf()
  public class IndexOfExample {
  
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          int indexOfO = str.indexOf('o');
  
          System.out.println("Index of 'o': " + indexOfO);  // Output: Index of 'o': 4
      }
  }
  2.//without buildin
  public class CustomIndexOf {
      public static int customIndexOf(char target, String str) {
          for (int i = 0; i < str.length(); i++) {
              if (str.charAt(i) == target) {
                  return i;  // Return the index if the character is found
              }
          }
          return -1; 
      }
  
      public static void main(String[] args) {
          String myString = "Hello, World!";
          char targetChar = 'o';
  
          int indexOfO = customIndexOf(myString ,targetChar);
  
          System.out.println("Index of 'o': " + indexOfO);  // Output: Index of 'o': 4
      }
  }
  </code></pre>
  
  
  <h2>public int indexOf(int, int);</h2>
  <p>The indexOf(int ch, int fromIndex) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified character (ch) in the string, starting the search from the specified index (fromIndex). If the character is not found, it returns -1.</p>
  <pre><code>
    1.//.indexOf()
    public class IndexOfExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          int indexOfO = str.indexOf('o', 5);
  
          System.out.println("Index of 'o' starting from index 5: " + indexOfO);  // Output: Index of 'o' starting from index 5: 7
      }
  }
  
  2.//without buildin
  public class CustomIndexOf {
    public static int customIndexOf(char target, String str, int fromIndex) {
        if (fromIndex < 0 || fromIndex >= str.length()) {
            return -1;  // Invalid fromIndex, return -1
        }
  
        for (int i = fromIndex; i < str.length(); i++) {
            if (str.charAt(i) == target) {
                return i; 
            }
        }
        return -1; 
    }
  
    public static void main(String[] args) {
        String myString = "Hello, World!";
        char targetChar = 'o';
        int startIndex = 5;
  
        int indexOfO = customIndexOf(targetChar, myString, startIndex);
  
        System.out.println("Index of 'o' starting from index 5: " + indexOfO);  // Output: Index of 'o' starting from index 5: 7
    }
  }
  
  </code></pre>
  
  
  <h2>public int lastIndexOf(int);</h2>
  <p>The lastIndexOf(int ch) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified character (ch) in the string. If the character is not found, it returns -1</p>
  <pre><code>
  1.//.lastIndexOf
    public class LastIndexOfExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          int lastIndexOfO = str.lastIndexOf('o');
  
          System.out.println("Last index of 'o': " + lastIndexOfO);  // Output: Last index of 'o': 8
      }
  }
  
  2.//without buildin
  public class CustomLastIndexOf {
    public static int customLastIndexOf(char target, String str) {
        for (int i = str.length() - 1; i >= 0; i--) {
            if (str.charAt(i) == target) {
                return i; 
            }
        }
        return -1;  
    }
  
    public static void main(String[] args) {
        String myString = "Hello, World!";
        char targetChar = 'o';
  
        int lastIndexOfO = customLastIndexOf(targetChar, myString);
  
        System.out.println("Last index of 'o': " + lastIndexOfO);  // Output: Last index of 'o': 8
    }
  }
  
  </code></pre>
  
  
  <h2>public int lastIndexOf(int, int);</h2>
  <p> The lastIndexOf(int ch, int fromIndex) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified character (ch) in the string, searching backward starting from the specified index (fromIndex). If the character is not found, it returns -1.</p>
  <pre><code>
    1.//.lastIndexOf
    public class LastIndexOfExample {
      public static void main(String[] args) {
          String str = "Hello, World! Hello, Java!";
  
          int lastIndexOfO = str.lastIndexOf('o', 10);
  
          System.out.println("Last index of 'o' before index 10: " + lastIndexOfO);  // Output: Last index of 'o' before index 10: 8
      }
  }
  
  2.//without inbuild
  public class CustomLastIndexOf {
    public static int customLastIndexOf(char target, String str, int fromIndex) {
        if (fromIndex < 0 || fromIndex >= str.length()) {
            return -1;  // Invalid fromIndex, return -1
        }
  
        for (int i = fromIndex; i >= 0; i--) {
            if (str.charAt(i) == target) {
                return i;  // Return the index if the character is found
            }
        }
        return -1;  // Return -1 if the character is not found
    }
  
    public static void main(String[] args) {
        String myString = "Hello, World! Hello, Java!";
        char targetChar = 'o';
        int startIndex = 10;
  
        int lastIndexOfO = customLastIndexOf(targetChar, myString, startIndex);
  
        System.out.println("Last index of 'o' before index 10: " + lastIndexOfO);  // Output: Last index of 'o' before index 10: 8
    }
  }
  
  </code></pre>
  
  
  
  <h2>public int indexOf(java.lang.String);</h2>
  <p>The indexOf(String str) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified substring (str) in the string. If the substring is not found, it returns -1.</p>
  <pre><code>
    1.//.indexof()
    public class IndexOfExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          int indexOfWorld = str.indexOf("World");
  
          System.out.println("Index of 'World': " + indexOfWorld);  // Output: Index of 'World': 7
      }
  }
  
  2.//without inbuild
  public class get {
    public static int customIndexOf(String target, String str) {
        for (int i = 0; i <= str.length() - target.length(); i++) {
            if (str.substring(i, i + target.length()).equals(target)) {
                return i;  // Return the index if the substring is found
            }
        }
        return -1;  
    }
    public static void main(String[] args) {
        String myString = "Hello, World!";
        String targetSubstring = "World";
  
        int indexOfWorld = customIndexOf(targetSubstring, myString);
  
        System.out.println("Index of 'World': " + indexOfWorld);  // Output: Index of 'World': 7
    }
  }
  </code></pre>
  <pre>
  Start with i = 0.
  Check the substring from index 0 to 5 ("Hello"). No match.
  Increment i to 1.
  Check the substring from index 1 to 6 ("ello,"). No match.
  Increment i to 2.
  Check the substring from index 2 to 7 ("llo, W"). No match.
  Increment i to 3.
  Check the substring from index 3 to 8 ("lo, Wo"). No match.
  Increment i to 4.
  Check the substring from index 4 to 9 ("o, Wor"). No match.
  Increment i to 5.
  Check the substring from index 5 to 10 (", Worl"). No match.
  Increment i to 6.
  Check the substring from index 6 to 11 (" World"). Match found
  </pre>
  
  
  <h2>public int indexOf(java.lang.String, int);</h2>
  <p>The indexOf(String str, int fromIndex) method in Java is a member of the String class. It is used to find the index of the first occurrence of the specified substring (str) in the string, starting the search from the specified index (fromIndex). If the substring is not found, it returns -1.</p>
  <pre><code>
    public class IndexOfExample {
  
      public static void main(String[] args) {
          String str = "Hello, World! Hello, Java!";
  
          // Find the index of the substring "Hello" in the string starting from index 7
          int indexOfHello = str.indexOf("Hello", 7);
  
          // Print the result
          System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
      }
  }
  
  
  2.//without buildin
  public class CustomIndexOf {
    public static int customIndexOf(String target, String str, int fromIndex) {
        if (fromIndex < 0 || fromIndex >= str.length()) {
            return -1;  // Invalid fromIndex, return -1
        }
  
        for (int i = fromIndex; i <= str.length() - target.length(); i++) {
            if (str.substring(i, i + target.length()).equals(target)) {
                return i;  // Return the index if the substring is found
            }
        }
        return -1;  // Return -1 if the substring is not found
    }
  
    public static void main(String[] args) {
        String myString = "Hello, World! Hello, Java!";
        String targetSubstring = "Hello";
        int startIndex = 7;
  
        // Use the customIndexOf method to find the index of "Hello" starting from index 7
        int indexOfHello = customIndexOf(targetSubstring, myString, startIndex);
  
        System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
    }
  }
  
  </code></pre>
  
  
  
  <h2>public int lastIndexOf(java.lang.String);</h2>
  <p>The lastIndexOf(String str, int fromIndex) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified substring (str) in the string, starting the search from the specified index (fromIndex). If the substring is not found, it returns -1.</p>
  <pre><code>
    1.//.indexOf()
    public class IndexOfExample {
      public static void main(String[] args) {
          String str = "Hello, World! Hello, Java!";
  
          int indexOfHello = str.indexOf("Hello", 7);
  
          System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
      }
  }
  
  2.//without buildin
  public class ManualIndexOf {
  
    public static int manualIndexOf(String target, String str, int fromIndex) {
        if (fromIndex < 0 || fromIndex >= str.length()) {
            return -1;  // Invalid fromIndex, return -1
        }
  
        for (int i = fromIndex; i <= str.length() - target.length(); i++) {
            if (str.substring(i, i + target.length()).equals(target)) {
                return i;  // Return the index if the substring is found
            }
        }
        return -1;  // Return -1 if the substring is not found
    }
  
    public static void main(String[] args) {
        String myString = "Hello, World! Hello, Java!";
        String targetSubstring = "Hello";
        int startIndex = 7;
  
        int indexOfHello = manualIndexOf(targetSubstring, myString, startIndex);
  
        System.out.println("Index of 'Hello' starting from index 7: " + indexOfHello);  // Output: Index of 'Hello' starting from index 7: 13
    }
  }
  
  </code></pre>
  
  
  
  <h2>public int lastIndexOf(java.lang.String, int);</h2>
  <p>The lastIndexOf(String str, int fromIndex) method in Java is a member of the String class. It is used to find the index of the last occurrence of the specified substring (str) in the string, starting the search from the specified index (fromIndex). If the substring is not found, it returns -1.</p>
  <pre><code>
    public class LastIndexOfExample {
      public static void main(String[] args) {
          String str = "Hello, World! Hello, Java!";
  
          int lastIndexOfHello = str.lastIndexOf("Hello", 18);
  
          System.out.println("Last index of 'Hello' before index 18: " + lastIndexOfHello);  // Output: Last index of 'Hello' before index 18: 13
      }
  }
  
  2.//without buildin
  public class CustomLastIndexOf {
  
    public static void main(String[] args) {
      String myString = "Hello, World! Hello, Java!";
      String targetSubstring = "Hello";
      int startIndex = 18;
  
      int lastIndexOfHello = customLastIndexOf(targetSubstring, myString, startIndex);
  
      System.out.println("Last index of 'Hello' before index 18: " + lastIndexOfHello);  // Output: Last index of 'Hello' before index 18: 13
  }
  
    public static int customLastIndexOf(String target, String str, int fromIndex) {
        if (fromIndex < 0 || fromIndex >= str.length()) {
            return -1;  
        }
  
        for (int i = fromIndex; i >= target.length() - 1; i--) {
            if (substringEquals(str, i - target.length() + 1, i + 1, target)) {
                return i - target.length() + 1;  // Return the index if the substring is found
            }
        }
        return -1;  // Return -1 if the substring is not found
    }
  
    // Custom method to check if two substrings are equal
    private static boolean substringEquals(String str, int start1, int end1, String target) {
        if (end1 - start1 != target.length()) {
            return false;  // Different lengths, not equal
        }
        for (int i = start1; i < end1; i++) {
          for (int j = 0; j < target.length(); j++) {
        <!-- for (int i = start1, j = 0; i < end1; i++, j++) { -->
            if (str.charAt(i) != target.charAt(j)) {
                return false;  // Characters don't match, not equal
            }
        }
      }
        return true;  // All characters match, equal
    }
  
  }
  
  </code></pre>
  <pre>
    Start with i = 18 (fromIndex).
  Check the substring from index 17 to 13 ("Hello"). Match found!
  </pre>
  
  <h2>public java.lang.String substring(int);</h2>
  <p>The substring(int beginIndex) method in Java is a member of the String class. It is used to create a new string that is a substring of the original string, starting from the specified index (beginIndex) to the end of the original string.</p>
  <pre><code>
    1.//.Substring
    public class SubstringExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          String substring = str.substring(7);
  
          System.out.println("Substring from index 7 to the end: " + substring);  // Output: Substring from index 7 to the end: World!
      }
  }
  
  2.//without buildin
  public class CustomSubstring {
    public static void main(String[] args) {
      String myString = "Hello, World!";
  
      String customSubstring = customSubstring(myString, 7);
  
      System.out.println("Custom substring from index 7: " + customSubstring);  // Output: Custom substring from index 7: World!
  }
    public static String customSubstring(String str, int beginIndex) {
        if (beginIndex < 0 || beginIndex >= str.length()) {
            return "";  // Invalid beginIndex, return an empty string
        }
  
        StringBuilder result = new StringBuilder();
        for (int i = beginIndex; i < str.length(); i++) {
            result.append(str.charAt(i));
        }
  
        return result.toString();
    }
  }
  
  </code></pre>
  
  
  
  <h2>public java.lang.String substring(int, int);</h2>
  <p> The substring(int beginIndex, int endIndex) method in Java is a member of the String class. It is used to create a new string that is a substring of the original string, starting from the specified beginIndex and extending to the character at index endIndex - 1. The substring includes the character at beginIndex and goes up to, but does not include, the character at endIndex.</p>
  <pre><code>
    1.//.substring()
    public class SubstringExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          String substring = str.substring(7, 12);
  
          System.out.println("Substring from index 7 to index 12 (exclusive): " + substring);  // Output: Substring from index 7 to index 12 (exclusive): World
      }
  }
  
  2.//without buildin
  public class CustomSubstring {
  
    public static String customSubstring(String str, int beginIndex, int endIndex) {
        if (beginIndex < 0 || beginIndex >= str.length() || endIndex > str.length() || beginIndex > endIndex) {
            return "";  // Invalid indices, return an empty string
        }
  
        StringBuilder result = new StringBuilder();
        for (int i = beginIndex; i < endIndex; i++) {
            result.append(str.charAt(i));
        }
  
        return result.toString();
    }
  
    public static void main(String[] args) {
        String myString = "Hello, World!";
  
        // Use the customSubstring method to create a substring from index 7 to index 12 (exclusive)
        String customSubstring = customSubstring(myString, 7, 12);
  
        // Print the result
        System.out.println("Custom substring from index 7 to index 12 (exclusive): " + customSubstring);  // Output: Custom substring from index 7 to index 12 (exclusive): World
    }
  }
  
  </code></pre>
  
  
  
  <h2>public java.lang.CharSequence subSequence(int, int);</h2>
  <p>The subSequence(int beginIndex, int endIndex) method in Java is a member of the CharSequence interface. The CharSequence interface is implemented by various classes in Java, including String, StringBuilder, and StringBuffer.
  
    The subSequence method returns a new CharSequence that is a subsequence of the original sequence. The subsequence starts with the character at the specified beginIndex and extends to the character at endIndex - 1. The endIndex is exclusive, similar to the substring method.</p>
  <pre><code>
    public class SubsequenceExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          CharSequence subsequence = str.subSequence(7, 12);
  
          System.out.println("Subsequence from index 7 to index 12 (exclusive): " + subsequence);
      }
  }
  
  2.//without buildin
  public class CustomSubsequence {
    public static void main(String[] args) {
      String original = "Hello, World!";
  
      CharSequence customSubsequence = customSubsequence(original, 7, 12);
  
      System.out.println("Custom subsequence from index 7 to index 12 (exclusive): " + customSubsequence);
  }
    public static CharSequence customSubsequence(CharSequence sequence, int beginIndex, int endIndex) {
        if (beginIndex < 0 || beginIndex >= sequence.length() || endIndex > sequence.length() || beginIndex > endIndex) {
            return "";  // Invalid indices, return an empty CharSequence
        }
  
        StringBuilder result = new StringBuilder();
        for (int i = beginIndex; i < endIndex; i++) {
            result.append(sequence.charAt(i));
        }
  
        return result.toString();
    }
  }
  
  </code></pre>
  
  
  
  <h2>public java.lang.String concat(java.lang.String);</h2>
  <p>The concat method in Java is a member of the String class. It is used to concatenate one string to the end of another. The method returns a new string that represents the concatenation of the original string and the specified string.</p>
  <pre><code>
    public class ConcatExample {
      public static void main(String[] args) {
          String str1 = "Hello, ";
          String str2 = "World!";
  
          String result = str1.concat(str2);
  
          System.out.println("Concatenated String: " + result);  // Output: Concatenated String: Hello, World!
      }
  }
  
  2.//without buildin
  public class CustomConcatenation {
    public static void main(String[] args) {
      String str1 = "Hello, ";
      String str2 = "World!";
  
      String result = customConcat(str1, str2);
  
      System.out.println("Concatenated String: " + result);  // Output: Concatenated String: Hello, World!
  }
    public static String customConcat(String str1, String str2) {
        char[] resultArray = new char[str1.length() + str2.length()];
  
        // Copy characters from str1 to the resultArray
        for (int i = 0; i < str1.length(); i++) {
            resultArray[i] = str1.charAt(i);
        }
  
        // Copy characters from str2 to the resultArray
        for (int i = 0; i < str2.length(); i++) {
            resultArray[str1.length() + i] = str2.charAt(i);
        }
  
        // Create a new string from the resultArray
        return new String(resultArray);
    }
  }
  
  
  </code></pre>
  
  
  
  
  <h2>public java.lang.String replace(char, char);</h2>
  <p>The replace(char oldChar, char newChar) method in Java is a member of the String class. It is used to create a new string in which all occurrences of a specified character (oldChar) are replaced with another character (newChar).</p>
  <pre><code>
    public class ReplaceExample {
      public static void main(String[] args) {
          String original = "Hello, World!";
          char oldChar = 'o';
          char newChar = 'x';
  
          String result = original.replace(oldChar, newChar);
  
          System.out.println("Modified String: " + result);  // Output: Modified String: Hellx, Wxrld!
      }
  }
  
  2//without buildin
  public class CustomReplace {
  
    public static String customReplace(String original, char oldChar, char newChar) {
        char[] resultArray = new char[original.length()];
  
        // Iterate through each character in the original string
        for (int i = 0; i < original.length(); i++) {
            char currentChar = original.charAt(i);
  
            // Replace oldChar with newChar if it matches
            if (currentChar == oldChar) {
                resultArray[i] = newChar;
            } 
            else {
                resultArray[i] = currentChar;
            }
        }
  
        // Create a new string from the resultArray
        return new String(resultArray);
    }
  
    public static void main(String[] args) {
        String original = "Hello, World!";
        char oldChar = 'o';
        char newChar = 'x';
  
        String result = customReplace(original, oldChar, newChar);
  
        System.out.println("Modified String: " + result);  // Output: Modified String: Hellx, Wxrld!
    }
  }
  
  </code></pre>
  
  
  
  
  <h2>public boolean matches(java.lang.String);</h2>
  <p>The matches method in Java is a member of the String class. It is used to check whether a string matches a given regular expression. The method returns true if the entire string matches the specified regular expression, and false otherwise.</p>
  <pre><code>
    public class MatchesExample {
      public static void main(String[] args) {
          String str = "Hello123";
  
          boolean isMatch = str.matches("[A-Za-z]+\\d+");
  
          System.out.println("Is the string a match? " + isMatch);  // Output: Is the string a match? true
      }
  }
  
  
  public class CustomMatches {
  
    
    public static void main(String[] args) {
      String str = "Hello123";
  
      boolean isMatch = customMatches(str, "[A-Za-z]+\\d+");
  
      System.out.println("Is the string a match? " + isMatch);  // Output: Is the string a match? true
  }
    public static boolean customMatches(String input, String regex) {
        int inputLength = input.length();
        int regexLength = regex.length();
  
        // If the lengths are different, the strings cannot match
        if (inputLength != regexLength) {
            return false;
        }
  
        // Iterate through each character and check for a match
        for (int i = 0; i < inputLength; i++) {
            char inputChar = input.charAt(i);
            char regexChar = regex.charAt(i);
  
            // Check if the characters match or if regexChar is a wildcard '.'
            if (inputChar != regexChar && regexChar != '.') {
                return false;
            }
        }
  
        // All characters match
        return true;
    }
  }
  
  </code></pre>
  
  
  
  
  <h2>public boolean contains(java.lang.CharSequence);</h2>
  <p>The contains method in Java is a member of the String class. It is used to check whether a sequence of characters (specified as a CharSequence) is present in the original string. The method returns true if the sequence is found, and false otherwise.</p>
  <pre><code>
    public class ContainsExample {
      public static void main(String[] args) {
          String str = "Hello, World!";
  
          boolean containsSequence = str.contains("World");
  
          System.out.println("Does the string contain the sequence? " + containsSequence);  // Output: Does the string contain the sequence? true
      }
  }
  
  2.//without buildin
  public class CustomContains {
  
    public static void main(String[] args) {
      String str = "Hello, World!";
  
      boolean containsSequence = customContains(str, "World");
  
      System.out.println("Does the string contain the sequence? " + containsSequence);  // Output: Does the string contain the sequence? true
  }
    public static boolean customContains(String original, CharSequence sequence) {
        int sequenceLength = sequence.length();
        int originalLength = original.length();
  
        // Iterate through each possible starting index in the original string
        for (int i = 0; i <= originalLength - sequenceLength; i++) {
            // Check if the substring starting at index i matches the sequence
  
            if (original.regionMatches(i, sequence.toString(), 0, sequenceLength)) {
                return true;
            }
        }
  
        // The sequence is not found in the original string
        return false;
    }
  }
  
  </code></pre>
  <p>
    <ol>
    <li>toffset: The starting index of the region in the current string.</li>
    <li>other: The string to be compared with.</li>
    <li>ooffset: The starting index of the region in the other string.</li>
    <li>length: The number of characters to compare in both strings.</li>
  </ol></p>
  
  
  <h2>public java.lang.String replaceFirst(java.lang.String, java.lang.String);</h2>
  <p>The replaceFirst method in Java is a member of the String class. It is used to replace the first occurrence of a specified substring (specified as the first parameter) with another substring (specified as the second parameter). The method returns a new string with the first occurrence of the specified substring replaced.</p>
  <pre><code>
    1//.replaceFirst()
    public class ReplaceFirstExample {
      public static void main(String[] args) {
          String str = "apple banana apple orange apple";
  
          String result = str.replaceFirst("apple", "fruit");
  
          System.out.println("Modified String: " + result);  // Output: Modified String: fruit banana apple orange apple
      }
  }
  
  2.//without buildin
  public class CustomReplaceFirst {
    public static String customReplaceFirst(String original, String target, String replacement) {
        int index = original.indexOf(target);
  
        // If the target substring is found, replace it; otherwise, return the original string
        if (index != -1) {
            return original.substring(0, index) + replacement + original.substring(index + target.length());
        } else {
            return original;
        }
    }
  
    public static void main(String[] args) {
        String str = "apple banana apple orange apple";
  
        String result = customReplaceFirst(str, "apple", "fruit");
  
        System.out.println("Modified String: " + result);
        // Output: Modified String: fruit banana apple orange apple
    }
  }
  
  </code></pre>
  
  
  
  <h2>public java.lang.String replaceAll(java.lang.String, java.lang.String);</h2>
  <p>The replaceAll method in Java is a member of the String class. It is used to replace all occurrences of a specified substring (specified as the first parameter) with another substring (specified as the second parameter). The method returns a new string with all occurrences of the specified substring replaced.</p>
  <pre><code>
    1.//.replaceAll()
    public class ReplaceAllExample {
  
      public static void main(String[] args) {
          String str = "apple banana apple orange apple";
  
          String result = str.replaceAll("apple", "fruit");
  
          System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
      }
  }
  
  2.//without buildin
  public class CustomReplaceAll {
    public static String customReplaceAll(String original, String target, String replacement) {
  
        // Iterate until no more occurrences of the target substring are found
        while (original.contains(target)) {
            int index = original.indexOf(target);
  
            original = original.substring(0, index) + replacement + original.substring(index + target.length());
        }
  
        // Return the modified string
        return original;
    }
  
    public static void main(String[] args) {
        String str = "apple banana apple orange apple";
  
        String result = customReplaceAll(str, "apple", "fruit");
  
        System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
    }
  }
  
  </code></pre>
  
  <pre>
    Construct New String:
  
  original.substring(0, index): The substring before the target substring, i.e., an empty string.
  replacement: The replacement string, i.e., "fruit".
  original.substring(index + target.length()): The substring after the target substring, i.e., " banana apple orange apple".
  </pre>
  
  <h2>public java.lang.String replace(java.lang.CharSequence, java.lang.CharSequence);</h2>
  <p>The replace method in Java is a member of the String class. It is used to replace all occurrences of a specified CharSequence (substring or character sequence) with another CharSequence. The method returns a new string with all occurrences of the specified CharSequence replaced.</p>
  
  <pre><code>
    public class ReplaceExample {
      public static void main(String[] args) {
          String str = "apple banana apple orange apple";
  
          String result = str.replace("apple", "fruit");
  
          System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
      }
  }
  2.//without buildin
  
  public class CustomReplace {
  
    public static String customReplace(String original, CharSequence target, CharSequence replacement) {
        // Convert CharSequence to String
        String targetStr = target.toString();
        String replacementStr = replacement.toString();
  
        // Iterate until no more occurrences of the target substring are found
        while (original.contains(targetStr)) {
            int index = original.indexOf(targetStr);
  
            original = original.substring(0, index) + replacementStr + original.substring(index + targetStr.length());
        }
  
        // Return the modified string
        return original;
    }
  
    public static void main(String[] args) {
        String str = "apple banana apple orange apple";
  
        String result = customReplace(str, "apple", "fruit");
  
        System.out.println("Modified String: " + result); // Output: Modified String: fruit banana fruit orange fruit
    }
  }
  
  </code></pre>
  
  
  <h2>public java.lang.String[] split(java.lang.String, int);</h2>
  <p>The split method in Java is a member of the String class. It is used to split a string into an array of substrings based on a specified regular expression. The method returns an array of strings.</p>
  <pre><code>
    public class SplitExample {
      public static void main(String[] args) {
          String str = "apple,banana,orange,grape";
  
          String[] result = str.split(",");
  
      
          System.out.println("Split String:");
          for (String s : result) {
              System.out.println(s);
          }
          // Output:
          // Split String:
          // apple
          // banana
          // orange
          // grape
      }
  }
  
  2.//without buildin
  public class CustomSplit {
  
    public static String[] customSplit(String original, String delimiter, int limit) {
        // Check if the delimiter is present in the original string
        if (!original.contains(delimiter)) {
            // If the delimiter is not found, return the original string as the only element in the array
            return new String[]{original};
        }
  
        // Create a list to store the substrings
        List<String> substrings = new ArrayList<>();
  
        // Initialize variables for tracking the start and end indices
        int startIndex = 0;
        int endIndex;
  
        // Iterate through the original string
        while ((endIndex = original.indexOf(delimiter, startIndex)) != -1) {
            // Add the substring to the list
            substrings.add(original.substring(startIndex, endIndex));
  
            // Move the start index to the next position after the delimiter
            startIndex = endIndex + delimiter.length();
  
            // Break if the number of substrings reaches the specified limit
            if (substrings.size() == limit - 1) {
                break;
            }
        }
  
        // Add the remaining substring (after the last delimiter) to the list
        substrings.add(original.substring(startIndex));
  
        // Convert the list to an array
        return substrings.toArray(new String[0]);
    }
  
    public static void main(String[] args) {
        String str = "apple,banana,orange,grape";
  
        // Split the string based on the comma (",") delimiter with a limit of 2
        String[] result = customSplit(str, ",", 2);
  
        System.out.println("Custom Split String:");
        for (String s : result) {
            System.out.println(s);
        }
        // Output:
        // Custom Split String:
        // apple
        // banana,orange,grape
    }
  }
  
  </code></pre>
  <pre>
    // First iteration
  endIndex = original.indexOf(delimiter, startIndex); // endIndex = 5
  // Loop body executes
  
  // Second iteration
  startIndex = endIndex + delimiter.length(); // startIndex = 6
  endIndex = original.indexOf(delimiter, startIndex); // endIndex = 12
  // Loop body executes
  
  // Third iteration
  startIndex = endIndex + delimiter.length(); // startIndex = 13
  endIndex = original.indexOf(delimiter, startIndex); // endIndex = 19
  // Loop body executes
  
  // Fourth iteration
  startIndex = endIndex + delimiter.length(); // startIndex = 20
  endIndex = original.indexOf(delimiter, startIndex); // endIndex = -1
  // Loop condition is false, loop exits
  </pre>
  
  <h2>public java.lang.String[] split(java.lang.String);</h2>
  <p></p>
  <pre><code>
    public class SplitExample {
  
      public static void main(String[] args) {
          String str = "apple,banana,orange,grape";
  
          // Split the string based on the comma (",") delimiter
          String[] result = str.split(",");
  
          // Print the result
          System.out.println("Split String:");
          for (String s : result) {
              System.out.println(s);
          }
          // Output:
          // Split String:
          // apple
          // banana
          // orange
          // grape
      }
  }
  
  2.//without buildin
  public class CustomSplit {
  
    public static String[] customSplit(String original, String delimiter) {
        // Create a list to store the substrings
        List<String> substrings = new ArrayList<>();
  
        // Initialize variables for tracking the start and end indices
        int startIndex = 0;
        int endIndex;
  
        // Iterate through the original string
        while ((endIndex = original.indexOf(delimiter, startIndex)) != -1) {
            // Add the substring to the list
            substrings.add(original.substring(startIndex, endIndex));
  
            // Move the start index to the next position after the delimiter
            startIndex = endIndex + delimiter.length();
        }
  
        // Add the remaining substring (after the last delimiter) to the list
        substrings.add(original.substring(startIndex));
  
        // Convert the list to an array
        return substrings.toArray(new String[0]);
    }
  
    public static void main(String[] args) {
        String str = "apple,banana,orange,grape";
  
        // Split the string based on the comma (",") delimiter using custom method
        String[] result = customSplit(str, ",");
  
        // Print the result
        System.out.println("Custom Split String:");
        for (String s : result) {
            System.out.println(s);
        }
        // Output:
        // Custom Split String:
        // apple
        // banana
        // orange
        // grape
    }
  }
  
  </code></pre>
  
  
  <h2>public static java.lang.String join(java.lang.CharSequence, java.lang.CharSequence...);</h2>
  <p>The join method in Java is a static method of the String class introduced in Java 8. It is used to join multiple CharSequence instances into a single String. </p>
  <pre><code>
    1.//.Join()
    public class JoinExample {
      public static void main(String[] args) {
          // Join three strings with a comma as a delimiter
          String result = String.join(", ", "apple", "banana", "orange");
  
          System.out.println("Joined String: " + result); // Output: Joined String: apple, banana, orange
      }
  }
  
  
  2.//without buildin
  public class CustomJoin {
  
    public static void main(String[] args) {
      
      String result = customJoin(", ", "apple", "banana", "orange");
  
      System.out.println("Custom Joined String: " + result); // Output: Custom Joined String: apple, banana, orange
  }
    public static String customJoin(CharSequence delimiter, CharSequence... elements) {
        // Check if there are no elements to join
        if (elements.length == 0) {
            return "";
        }
  
        // Initialize the result with the first element
        StringBuilder result = new StringBuilder(elements[0]);
  
        // Iterate through the remaining elements
        for (int i = 1; i < elements.length; i++) {
            // Append the delimiter and the current element to the result
            result.append(delimiter).append(elements[i]);
        }
  
        // Convert StringBuilder to String
        return result.toString();
    }
  }
  
  </code></pre>
  
  
  <h2>public static java.lang.String join(java.lang.CharSequence, java.lang.Iterable`<` ? extends java.lang.CharSequence>);</h2>
  <p>
    The split method in Java is used to split a string into an array of substrings based on a specified regular expression. When you call split with a single String parameter, that string is treated as a regular expression to determine the splitting pattern.</p>
  <pre><code>
    1.//.join()
    import java.util.Arrays;
    public class JoinIterableExample {
    
        public static void main(String[] args) {
            // Join an Iterable of strings with a comma as a delimiter
            Iterable<CharSequence> elements = Arrays.asList("apple", "banana", "orange");
            String result = String.join(", ", elements);
    
            System.out.println("Joined String: " + result);// Output: Joined String: apple, banana, orange
        }
    }
    
    2.//without buildin
    import java.util.Arrays;
  
  public class CustomJoinIterable {
  
      public static String customJoin(CharSequence delimiter, Iterable < ? extends CharSequence> elements) {
          // Create a StringBuilder to store the result
          StringBuilder result = new StringBuilder();
  
          // Initialize a flag to determine if the delimiter should be added
          boolean addDelimiter = false;
  
          // Iterate through the elements
          for (CharSequence element : elements) {
              // Add the delimiter if needed
              if (addDelimiter) {
                  result.append(delimiter);
              }
  
              // Add the current element to the result
              result.append(element);
  
              // Set the flag to true for subsequent elements
              addDelimiter = true;
          }
  
          // Convert StringBuilder to String
          return result.toString();
      }
  
      public static void main(String[] args) {
          // Join an Iterable of strings with a comma as a delimiter using custom method
          Iterable<CharSequence> elements = Arrays.asList("apple", "banana", "orange");
          String result = customJoin(", ", elements);
  
          System.out.println("Custom Joined String: " + result); // Output: Custom Joined String: apple, banana, orange
      }
  }
  
  </code></pre>
  
  
  <h2>public java.lang.String toLowerCase(java.util.Locale);</h2>
  <p>The toLowerCase(Locale) method in Java is a member of the String class. It is used to convert all the characters in a string to lowercase based on the rules of a specified Locale.</p>
  <pre><code>
    public class ToLowerCaseExample {
      public static void main(String[] args) {
          String original = "HELLO WORLD";
      
          String lowercaseDefault = original.toLowerCase();     // Convert the string to lowercase using the default locale
  
          String lowercaseUS = original.toLowerCase(Locale.US);     // Convert the string to lowercase using a specific locale (for example, Locale.US)
  
          System.out.println("Lowercase (Default Locale): " + lowercaseDefault); // Lowercase (Default Locale): hello world
          System.out.println("Lowercase (Locale.US): " + lowercaseUS);// Lowercase (Locale.US): hello world  
      }
  } 
  </code></pre>
  
  
  
  
  <h2>public java.lang.String toLowerCase();</h2>
  <p></p>
  <pre><code>
    public class ToLowerCaseExample {
      public static void main(String[] args) {
          String original = "Hello World";
  
          String lowercase = original.toLowerCase();
  
          System.out.println("Lowercase: " + lowercase); // Lowercase: hello world
      }
  }
  
  2.//without buildin
  public class CustomToLowerCase {
  
    public static void main(String[] args) {
      String original = "Hello World";
  
      String lowercase = customToLowerCase(original);
  
      System.out.println("Lowercase: " + lowercase); // Lowercase: hello world
  }
    public static String customToLowerCase(String original) {
        // Create a StringBuilder to store the result
        StringBuilder result = new StringBuilder();
  
        // Iterate through each character in the original string
        for (int i = 0; i < original.length(); i++) {
            char currentChar = original.charAt(i);
  
            // Check if the character is an uppercase letter
            if (currentChar >= 'A' && currentChar <= 'Z') {
                // Convert uppercase letter to lowercase and append to the result
                result.append((char) (currentChar + ('a' - 'A')));
            } 
            else {
                // Keep non-uppercase letters unchanged and append to the result
                result.append(currentChar);
            }
        }
  
        // Convert StringBuilder to String
        return result.toString();
    }
  }
  
  </code></pre>
  
  <h2>public java.lang.String toUpperCase(java.util.Locale);</h2>
  <p>e customToUpperCase method iterates through each character in the original string. If a character is a lowercase letter, it is converted to uppercase by adjusting its ASCII value. Non-lowercase letters remain unchanged. The result is then stored in a StringBuilder and converted to a String.</p>
  <pre><code>
    import java.util.Locale;
    public class ToUpperCaseExample {
        public static void main(String[] args) {
            String original = "hello world";
    
            // Using the built-in toUpperCase(Locale) method
            String uppercaseDefault = original.toUpperCase();
    
            // Using the built-in toUpperCase(Locale) method with a specific locale (for example, Locale.US)
            String uppercaseUS = original.toUpperCase(Locale.US);
  
            System.out.println("Uppercase (Default Locale): " + uppercaseDefault);  // Uppercase (Default Locale): HELLO WORLD
            System.out.println("Uppercase (Locale.US): " + uppercaseUS); // Uppercase (Locale.US): HELLO WORLD
        }
    }
    
    2.//without buildin
    public class CustomToUpperCase {
  
      public static String customToUpperCase(String original) {
          // Create a StringBuilder to store the result
          StringBuilder result = new StringBuilder();
  
          // Iterate through each character in the original string
          for (int i = 0; i < original.length(); i++) {
              char currentChar = original.charAt(i);
  
              // Check if the character is a lowercase letter
              if (currentChar >= 'a' && currentChar <= 'z') {
                  // Convert lowercase letter to uppercase and append to the result
                  result.append((char) (currentChar - ('a' - 'A')));
              } else {
                  // Keep non-lowercase letters unchanged and append to the result
                  result.append(currentChar);
              }
          }
  
          // Convert StringBuilder to String
          return result.toString();
      }
  
      public static void main(String[] args) {
          String original = "hello world";
          // Convert the string to uppercase using custom method
          String uppercase = customToUpperCase(original);
  
          System.out.println("Uppercase: " + uppercase);    // Uppercase: HELLO WORLD
      }
  }
  
  </code></pre>
  
  <h2>public java.lang.String toUpperCase();</h2>
  <p>The toUpperCase() method in Java is a member of the String class. It is used to convert all the characters in a string to uppercase.</p>
  <pre><code>
    public class ToUpperCaseExample {
      public static void main(String[] args) {
          String original = "hello world";
  
          // Convert the string to uppercase
          String uppercase = original.toUpperCase();
  
          System.out.println("Uppercase: " + uppercase);  // Uppercase: HELLO WORLD
      }
  }
  
  </code></pre>
  
  
  
  
  <h2>public java.lang.String trim();</h2>
  <p>The trim() method in Java is a member of the String class. It is used to remove leading and trailing whitespace (spaces, tabs, and newlines) from a string. The method returns a new string with the whitespace removed.</p>
  <pre><code>
    public class TrimExample {
      public static void main(String[] args) {
          String original = "   Hello, World!   ";
  
          // Trim the string to remove leading and trailing whitespace
          String trimmed = original.trim();
  
          System.out.println("Trimmed: '" + trimmed + "'"); // Trimmed: 'Hello, World!'
      }
  }
  
  </code></pre>
  <pre>
    Initialization:
    start: Initialized to 0, representing the start index of the string.
    end: Initialized to original.length() - 1, representing the end index of the string.
  
    Find Start Index:
    A while loop is used to find the index of the first non-whitespace character from the start of the string.
    Inside the loop, Character.isWhitespace(original.charAt(start)) checks if the character at the current start index is whitespace.
    Return Trimmed Substring:
  
    Find End Index:
  Another while loop is used to find the index of the first non-whitespace character from the end of the string.
  Inside the loop, Character.isWhitespace(original.charAt(end)) checks if the character at the current end index is whitespace.
  The loop decrements end until a non-whitespace character is found or until end goes below start.
  
    
  Return Trimmed Substring:
    The substring(start, end + 1) method is then called to extract the substring from start to end + 1.
    The end + 1 is used to include the character at the end index in the resulting substring.
  
    Result:
    The resulting substring is the trimmed version of the original string, containing only the characters between the first non-whitespace character from the start and the first non-whitespace character from the end.
  </pre>
  
  <h2>public java.lang.String strip();</h2>
  <p>The strip() method in Java is a member of the String class. It was introduced in Java 11 and is used to remove leading and trailing whitespace from a string. The method is similar to trim(), but it uses the Unicode-aware definition of whitespace, which includes not only ASCII spaces, tabs, and newlines but also other Unicode whitespace characters</p>
  <pre><code>
    public class StripExample {
      public static void main(String[] args) {
          String original = "   Hello, World!   ";
  
          // Strip the string to remove leading and trailing whitespace
          String stripped = original.strip();
  
          System.out.println("Original: '" + original + "'");  // Original: '   Hello, World!   '
          System.out.println("Stripped: '" + stripped + "'");  // Original: '   Hello, World!   '
       
        
   x
      }
  }
  
  </code></pre>
  
  <h2>public java.lang.String stripLeading();</h2>
  <p>The strip() method in Java is a member of the String class. It was introduced in Java 11 and is used to remove leading and trailing whitespace from a string. The method is similar to trim(), but it uses the Unicode-aware definition of whitespace, which includes not only ASCII spaces, tabs, and newlines but also other Unicode whitespace characters.</p>
  <pre><code>
    public class StripExample {
      public static void main(String[] args) {
          String original = "   Hello, World!   ";
  
          // Strip the string to remove leading and trailing whitespace
          String stripped = original.strip();
  
          System.out.println("Original: '" + original + "'"); // Original: '   Hello, World!   '
          System.out.println("Stripped: '" + stripped + "'"); // Stripped: 'Hello, World!'       
         
      }
  }
  </code></pre>
  
  
  
  
  <h2>public java.lang.String stripTrailing();</h2>
  <p>The stripTrailing() method in Java is a member of the String class. It was introduced in Java 11 and is used to remove trailing whitespace (spaces, tabs, and newlines) from a string. Similar to strip(), it uses the Unicode-aware definition of whitespace.</p>
  <pre><code>
    public class StripTrailingExample {
      public static void main(String[] args) {
          String original = "   Hello, World!   ";
  
          // Strip trailing whitespace from the string
          String strippedTrailing = original.stripTrailing();
       
          System.out.println("Original: '" + original + "'");  // Original: '   Hello, World!   '
          System.out.println("Stripped Trailing: '" + strippedTrailing + "'"); // Stripped Trailing: '   Hello, World!'
      }
  }
  
  </code></pre>
  
  
  <h2>public boolean isBlank();</h2>
  <p>The isBlank() method in Java is a member of the String class. It was introduced in Java 11 and is used to check whether a string is empty or contains only whitespace characters (including Unicode whitespace). It returns true if the string is empty or contains only whitespace; otherwise, it returns false.</p>
  <pre><code>
    public class IsBlankExample {
  
      public static void main(String[] args) {
          String emptyString = "";
          String whitespaceString = "    ";
          String nonEmptyString = "Hello, World!";
  
          // Check if strings are blank
          boolean isEmptyBlank = emptyString.isBlank();
          boolean isWhitespaceBlank = whitespaceString.isBlank();
          boolean isNonEmptyBlank = nonEmptyString.isBlank();
  
          System.out.println("Is Empty String Blank: " + isEmptyBlank);             // true
          System.out.println("Is Whitespace String Blank: " + isWhitespaceBlank); // true
          System.out.println("Is Non-Empty String Blank: " + isNonEmptyBlank);     // false
      }
  }
  
  2.//without buildin
  public class CustomIsBlank {
  
    public static boolean customIsBlank(String str) {
        // Check if the string is null
        if (str == null) {
            return true;
        }
  
        // Check if the string is empty or contains only whitespace
        for (int i = 0; i < str.length(); i++) {
            if (!Character.isWhitespace(str.charAt(i))) {
                return false; // Non-whitespace character found
            }
        }
  
        return true; // String is either empty or contains only whitespace
    }
  
    public static void main(String[] args) {
        String emptyString = "";
        String whitespaceString = "    ";
        String nonEmptyString = "Hello, World!";
  
        // Check if strings are blank using custom method
        boolean isEmptyBlank = customIsBlank(emptyString);
        boolean isWhitespaceBlank = customIsBlank(whitespaceString);
        boolean isNonEmptyBlank = customIsBlank(nonEmptyString);
  
   
        System.out.println("Is Empty String Blank: " + isEmptyBlank);             // true
        System.out.println("Is Whitespace String Blank: " + isWhitespaceBlank); // true
        System.out.println("Is Non-Empty String Blank: " + isNonEmptyBlank);     // false
    }
  }
  
  </code></pre>
     
  <h2>  public java.util.stream.Stream<java.lang.String> lines();</h2>
  <p>The lines() method in Java is a member of the BufferedReader class and is used to create a Stream of lines from the text read from the underlying Reader. It is commonly used with the Files class to read lines from a file.</p>
  <pre><code>
    import java.io.BufferedReader;
    import java.io.FileReader;
    import java.io.IOException;
    import java.util.stream.Stream;
    
    public class LinesExample {
    
        public static void main(String[] args) {
            // Provide the path to your text file
            String filePath = "path/to/your/textfile.txt";
    
            // Try-with-resources to ensure proper resource management
            try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
                // Use lines() to create a Stream of lines
                Stream<String> lines = reader.lines();
    
                // Process each line using the Stream API
                lines.forEach(System.out::println);
            } 
            catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    
  </code></pre>
  
  
  <h2>  public java.lang.String indent(int);</h2>
  <p>The indent(int) method in Java is a member of the String class. It was introduced in Java 12 and is used to create a new String where each line in the original string is indented by a specified number of spaces.</p>
  <pre><code>
    public class IndentExample {
  
      public static void main(String[] args) {
          String original = "Line 1\nLine 2\nLine 3";
  
          // Indent each line by 4 spaces
          String indented = original.indent(4);
  
          // Print the results
          System.out.println("Original:\n" + original);
          System.out.println("Indented:\n" + indented);
      }
  }
  
  2.//without buildin
  public class ManualIndent {
  
    public static String manualIndent(String original, int spaces) {
        if (original == null) {
            return null;
        }
  
        // Step 2: Split into Lines
        String[] lines = original.split("\n");
  
        // Step 3: Indent Each Line
        StringBuilder indentedBuilder = new StringBuilder();
        for (String line : lines) {
            // Step 3: Append Indentation and Line
            for (int i = 0; i < spaces; i++) {
                indentedBuilder.append(' '); // Append spaces
            }
            indentedBuilder.append(line).append("\n");
        }
  
        // Step 4: Remove Trailing Newline
        if (lines.length > 0) {
            indentedBuilder.deleteCharAt(indentedBuilder.length() - 1);
        }
  
        // Step 5: Return Indented String
        return indentedBuilder.toString();
    }
  
    public static void main(String[] args) {
        String original = "Line 1\nLine 2\nLine 3";
  
        // Indent each line by 4 spaces using custom method
        String indented = manualIndent(original, 4);
  
        // Print the results
        System.out.println("Original:\n" + original);
        System.out.println("Indented:\n" + indented);
    }
  }
  
  </code></pre>
  
  
  <h2>  public java.lang.String stripIndent();</h2>
  <p>The stripIndent() method in Java is a member of the String class. It was introduced in Java 13 and is used to remove common leading whitespace from each line of a string. This is particularly useful when defining multi-line strings in the source code with consistent indentation.</p>
  <pre><code>
    public class StripIndentExample {
  
      public static void main(String[] args) {
          String indentedString = """
              Line 1
              Line 2
              Line 3
          """;
  
          // Strip common leading whitespace from each line
          String stripped = indentedString.stripIndent();
  
          // Print the results
          System.out.println("Original:\n" + indentedString);
          System.out.println("Stripped Indent:\n" + stripped);
      }
  }
  
  </code></pre>
  
  
  <h2> public java.lang.String translateEscapes();</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2> public <R> R transform(java.util.function.Function<? super java.lang.String, ? extends R>);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2>public java.lang.String toString();</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2> public java.util.stream.IntStream chars();</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2> public java.util.stream.IntStream codePoints();</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  
  <h2> public char[] toCharArray();</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2>public static java.lang.String format(java.lang.String, java.lang.Object...);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2>public static java.lang.String format(java.util.Locale, java.lang.String, java.lang.Object...);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2>public java.lang.String formatted(java.lang.Object...);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  
  <h2>public static java.lang.String valueOf(java.lang.Object);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public static java.lang.String valueOf(char[]);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  
  <h2>public static java.lang.String valueOf(char[], int, int);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public static java.lang.String copyValueOf(char[], int, int);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  
  <h2>public static java.lang.String copyValueOf(char[]);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public static java.lang.String valueOf(boolean);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public static java.lang.String valueOf(char);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public static java.lang.String valueOf(long);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public static java.lang.String valueOf(float);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public static java.lang.String valueOf(double);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2>public native java.lang.String intern();</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public java.lang.String repeat(int);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public java.util.Optional<java.lang.String> describeConstable();</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  <h2>public java.lang.String resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  
  <h2>public int compareTo(java.lang.Object);</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  <h2>public java.lang.Object resolveConstantDesc(java.lang.invoke.MethodHandles$Lookup) throws java.lang.ReflectiveOperationException;</h2>
  <p></p>
  <pre><code>
  
  </code></pre>
  
  
  
  </div>
      </details>
  



      <h1>Collection</h1>
      <details>
                    <summary>
                      <span class="faq-title"> 
                        <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                      <img src="plus.svg" class="expand-icon" alt="Plus">
                    </summary>        
                    <div class="faq-content">
              <pre><code>
                public interface java.util.Collection<E> extends java.lang.Iterable<E> 
                  public abstract int size();
                  public abstract boolean isEmpty();
                  public abstract boolean contains(java.lang.Object);
                  public abstract java.util.Iterator<E> iterator();
                  public abstract java.lang.Object[] toArray();
                  public abstract <T> T[] toArray(T[]);
                  public default <T> T[] toArray(java.util.function.IntFunction<T[]>);
                  public abstract boolean add(E);
                  public abstract boolean remove(java.lang.Object);
                  public abstract boolean containsAll(java.util.Collection<?>);
                  public abstract boolean addAll(java.util.Collection<? extends E>);
                  public abstract boolean removeAll(java.util.Collection<?>);
                  public abstract boolean retainAll(java.util.Collection<?>);
                  public abstract void clear();
                  public abstract boolean equals(java.lang.Object);
                  public abstract int hashCode();
                  public default java.util.Spliterator<E> spliterator();
                  public default java.util.stream.Stream<E> stream();
                  public default java.util.stream.Stream<E> parallelStream();
              </code></pre>
                  </div>
                  </details>

                  <h1 style="color: rgb(204, 201, 32);">List</h1>
                  <details>
                 <summary>
                   <span class="faq-title"> 
                     <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                   <img src="plus.svg" class="expand-icon" alt="Plus">
                 </summary>        
                 <div class="faq-content">
           <pre><code>
             LIST
           
           
             public interface java.util.List<E> extends java.util.Collection<E> 
             public abstract int size();
             public abstract boolean isEmpty();
             public abstract boolean contains(java.lang.Object);
             public abstract java.util.Iterator<E> iterator();
             public abstract java.lang.Object[] toArray();
             public abstract <T> T[] toArray(T[]);
             public abstract boolean add(E);
             public abstract boolean remove(java.lang.Object);
             public abstract boolean containsAll(java.util.Collection<?>);
             public abstract boolean addAll(java.util.Collection<? extends E>);
             public abstract boolean addAll(int, java.util.Collection<? extends E>);
             public abstract boolean removeAll(java.util.Collection<?>);
             public abstract boolean retainAll(java.util.Collection<?>);
             public default void replaceAll(java.util.function.UnaryOperator<E>);
             public default void sort(java.util.Comparator<? super E>);
             public abstract void clear();
             public abstract boolean equals(java.lang.Object);
             public abstract int hashCode();
             public abstract E get(int);
             public abstract E set(int, E);
             public abstract void add(int, E);
             public abstract E remove(int);
             public abstract int indexOf(java.lang.Object);
             public abstract int lastIndexOf(java.lang.Object);
             public abstract java.util.ListIterator<E> listIterator();
             public abstract java.util.ListIterator<E> listIterator(int);
             public abstract java.util.List<E> subList(int, int);
             public default java.util.Spliterator<E> spliterator();
             public static <E> java.util.List<E> of();
             public static <E> java.util.List<E> of(E);
             public static <E> java.util.List<E> of(E, E);
             public static <E> java.util.List<E> of(E, E, E);
             public static <E> java.util.List<E> of(E, E, E, E);
             public static <E> java.util.List<E> of(E, E, E, E, E);
             public static <E> java.util.List<E> of(E, E, E, E, E, E);
             public static <E> java.util.List<E> of(E, E, E, E, E, E, E);
             public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E);
             public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E, E);
             public static <E> java.util.List<E> of(E, E, E, E, E, E, E, E, E, E);
             public static <E> java.util.List<E> of(E...);
             public static <E> java.util.List<E> copyOf(java.util.Collection<? extends E>);
           </code></pre>
               </div>
               </details>
           
           
               
               <h1  style="color:rgb(223, 3, 150)">ArrayList</h1>
                  <details>
                 <summary>
                   <span class="faq-title"> 
                     <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                   <img src="plus.svg" class="expand-icon" alt="Plus">
                 </summary>        
                 <div class="faq-content">
           <pre><code>
             ARRAYLIST
             
           
             public class java.util.ArrayList<E> extends java.util.AbstractList<E> implements java.util.List<E>, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
             public java.util.ArrayList(int);
             public java.util.ArrayList();
             public java.util.ArrayList(java.util.Collection<? extends E>);
             public void trimToSize();
             public void ensureCapacity(int);
             public int size();
             public boolean isEmpty();
             public boolean contains(java.lang.Object);
             public int indexOf(java.lang.Object);
             public int lastIndexOf(java.lang.Object);
             public java.lang.Object clone();
             public java.lang.Object[] toArray();
             public <T> T[] toArray(T[]);
             public E get(int);
             public E set(int, E);
             public boolean add(E);
             public void add(int, E);
             public E remove(int);
             public boolean equals(java.lang.Object);
             public int hashCode();
             public boolean remove(java.lang.Object);
             public void clear();
             public boolean addAll(java.util.Collection<? extends E>);
             public boolean addAll(int, java.util.Collection<? extends E>);
             public boolean removeAll(java.util.Collection<?>);
             public boolean retainAll(java.util.Collection<?>);
             public java.util.ListIterator<E> listIterator(int);
             public java.util.ListIterator<E> listIterator();
             public java.util.Iterator<E> iterator();
             public java.util.List<E> subList(int, int);
             public void forEach(java.util.function.Consumer<? super E>);
             public java.util.Spliterator<E> spliterator();
             public boolean removeIf(java.util.function.Predicate<? super E>);
             public void replaceAll(java.util.function.UnaryOperator<E>);
             public void sort(java.util.Comparator<? super E>);
           </code></pre>
               </div>
               </details>
           
           
               <h1  style="color:rgb(223, 3, 150)">LinkedList</h1>
               <details>
              <summary>
                <span class="faq-title"> 
                  <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
                <img src="plus.svg" class="expand-icon" alt="Plus">
              </summary>        
              <div class="faq-content">
           <pre>
             <code>
               LINKEDLIST
             
             
           
               PS D:\APP\all folder\3D Objects\dsa> javap -public java.util.LinkedList
               Compiled from "LinkedList.java"
               public class java.util.LinkedList<E> extends java.util.AbstractSequentialList<E> implements java.util.List<E>, java.util.Deque<E>, java.lang.Cloneable, java.io.Serializable {
                 public java.util.LinkedList();
                 public java.util.LinkedList(java.util.Collection<? extends E>);
                 public E getFirst();
                 public E getLast();
                 public E removeFirst();
                 public E removeLast();
                 public void addFirst(E);
                 public void addLast(E);
                 public boolean contains(java.lang.Object);
                 public int size();
                 public boolean add(E);
                 public boolean remove(java.lang.Object);
                 public boolean addAll(java.util.Collection<? extends E>);
                 public boolean addAll(int, java.util.Collection<? extends E>);
                 public void clear();
                 public E get(int);
                 public E set(int, E);
                 public void add(int, E);
                 public E remove(int);
                 public int indexOf(java.lang.Object);
                 public int lastIndexOf(java.lang.Object);
                 public E peek();
                 public E element();
                 public E poll();
                 public E remove();
                 public boolean offer(E);
                 public boolean offerFirst(E);
                 public boolean offerLast(E);
                 public E peekFirst();
                 public E peekLast();
                 public E pollFirst();
                 public E pollLast();
                 public void push(E);
                 public E pop();
                 public boolean removeFirstOccurrence(java.lang.Object);
                 public boolean removeLastOccurrence(java.lang.Object);
                 public java.util.ListIterator<E> listIterator(int);
                 public java.util.Iterator<E> descendingIterator();
                 public java.lang.Object clone();
                 public java.lang.Object[] toArray();
                 public <T> T[] toArray(T[]);
                 public java.util.Spliterator<E> spliterator();
             </code>
           
           </pre>
           
            </div>
            </details>
           
           
            <h1  style="color:rgb(223, 3, 150)">Stack</h1>
            <details>
           <summary>
             <span class="faq-title"> 
               <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
             <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             public class java.util.Stack<E> extends java.util.Vector<E> 
               private static final long serialVersionUID;
               public java.util.Stack();
               public E push(E);
               public synchronized E pop();
               public synchronized E peek();
               public boolean empty();
               public synchronized int search(java.lang.Object);
           </code></pre>
           </div>
           </details>
           
           
           
           <h1  style="color:rgb(223, 3, 150)">Vector</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
           <code>
             public class java.util.Vector<E> extends java.util.AbstractList<E> implements java.util.List<E>, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
               protected java.lang.Object[] elementData;
               protected int elementCount;
               protected int capacityIncrement;
               private static final long serialVersionUID;
               public java.util.Vector(int, int);
               public java.util.Vector(int);
               public java.util.Vector();
               public java.util.Vector(java.util.Collection<? extends E>);
               public synchronized void copyInto(java.lang.Object[]);
               public synchronized void trimToSize();
               public synchronized void ensureCapacity(int);
               private java.lang.Object[] grow(int);
               private java.lang.Object[] grow();
               public synchronized void setSize(int);
               public synchronized int capacity();
               public synchronized int size();
               public synchronized boolean isEmpty();
               public java.util.Enumeration<E> elements();
               public boolean contains(java.lang.Object);
               public int indexOf(java.lang.Object);
               public synchronized int indexOf(java.lang.Object, int);
               public synchronized int lastIndexOf(java.lang.Object);
               public synchronized int lastIndexOf(java.lang.Object, int);
               public synchronized E elementAt(int);
               public synchronized E firstElement();
               public synchronized E lastElement();
               public synchronized void setElementAt(E, int);
               public synchronized void removeElementAt(int);
               public synchronized void insertElementAt(E, int);
               public synchronized void addElement(E);
               public synchronized boolean removeElement(java.lang.Object);
               public synchronized void removeAllElements();
               public synchronized java.lang.Object clone();
               public synchronized java.lang.Object[] toArray();
               public synchronized <T> T[] toArray(T[]);
               E elementData(int);
               static <E> E elementAt(java.lang.Object[], int);
               public synchronized E get(int);
               public synchronized E set(int, E);
               private void add(E, java.lang.Object[], int);
               public synchronized boolean add(E);
               public boolean remove(java.lang.Object);
               public void add(int, E);
               public synchronized E remove(int);
               public void clear();
               public synchronized boolean containsAll(java.util.Collection<?>);
               public boolean addAll(java.util.Collection<? extends E>);
               public boolean removeAll(java.util.Collection<?>);
               public boolean retainAll(java.util.Collection<?>);
               public boolean removeIf(java.util.function.Predicate<? super E>);
               private static long[] nBits(int);
               private static void setBit(long[], int);
               private static boolean isClear(long[], int);
               private synchronized boolean bulkRemove(java.util.function.Predicate<? super E>);       
               public synchronized boolean addAll(int, java.util.Collection<? extends E>);
               public synchronized boolean equals(java.lang.Object);
               public synchronized int hashCode();
               public synchronized java.lang.String toString();
               public synchronized java.util.List<E> subList(int, int);
               protected synchronized void removeRange(int, int);
               private void shiftTailOverGap(java.lang.Object[], int, int);
               private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
               private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;        
               public synchronized java.util.ListIterator<E> listIterator(int);
               public synchronized java.util.ListIterator<E> listIterator();
               public synchronized java.util.Iterator<E> iterator();
               public synchronized void forEach(java.util.function.Consumer<? super E>);
               public synchronized void replaceAll(java.util.function.UnaryOperator<E>);
               public synchronized void sort(java.util.Comparator<? super E>);
               public java.util.Spliterator<E> spliterator();
               void checkInvariants();
               private static boolean lambda$retainAll$1(java.util.Collection, java.lang.Object);      
               private static boolean lambda$removeAll$0(java.util.Collection, java.lang.Object);  
           </code>
           </pre>
           
           </div>
           </details>
           
           
           <h1  style="color:rgb(223, 3, 150)">Enumeration</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             public interface java.util.Enumeration<E> 
               public abstract boolean hasMoreElements();
               public abstract E nextElement();
               public default java.util.Iterator<E> asIterator();
           </code></pre>
           </div>
           </details>
           
           <h1  style="color: rgb(204, 201, 32);">Queue</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             public interface java.util.Queue<E> extends java.util.Collection<E> 
               public abstract boolean add(E);
               public abstract boolean offer(E);
               public abstract E remove();
               public abstract E poll();
               public abstract E element();
               public abstract E peek();
           </code></pre>
           </div>
           </details>
           
           
           
           <h1 style="color:rgb(223, 3, 150)">PriorityQueue</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             PriorityQueue
           
           
             public class java.util.PriorityQueue<E> extends java.util.AbstractQueue<E> implements java.io.Serializable {
               private static final long serialVersionUID;
               private static final int DEFAULT_INITIAL_CAPACITY;
               transient java.lang.Object[] queue;
               int size;
               private final java.util.Comparator<? super E> comparator;
               transient int modCount;
               public java.util.PriorityQueue();
               public java.util.PriorityQueue(int);
               public java.util.PriorityQueue(java.util.Comparator<? super E>);
               public java.util.PriorityQueue(int, java.util.Comparator<? super E>);
               public java.util.PriorityQueue(java.util.Collection<? extends E>);
               public java.util.PriorityQueue(java.util.PriorityQueue<? extends E>);
               public java.util.PriorityQueue(java.util.SortedSet<? extends E>);
               private static java.lang.Object[] ensureNonEmpty(java.lang.Object[]);
               private void initFromPriorityQueue(java.util.PriorityQueue<? extends E>);
               private void initElementsFromCollection(java.util.Collection<? extends E>);
               private void initFromCollection(java.util.Collection<? extends E>);
               private void grow(int);
               public boolean add(E);
               public boolean offer(E);
               public E peek();
               private int indexOf(java.lang.Object);
               public boolean remove(java.lang.Object);
               void removeEq(java.lang.Object);
               public boolean contains(java.lang.Object);
               public java.lang.Object[] toArray();
               public <T> T[] toArray(T[]);
               public java.util.Iterator<E> iterator();
               public int size();
               public void clear();
               public E poll();
               E removeAt(int);
               private void siftUp(int, E);
               private static <T> void siftUpComparable(int, T, java.lang.Object[]);
               private static <T> void siftUpUsingComparator(int, T, java.lang.Object[], java.util.Comparator<? super T>);
               private void siftDown(int, E);
               private static <T> void siftDownComparable(int, T, java.lang.Object[], int);
               private static <T> void siftDownUsingComparator(int, T, java.lang.Object[], int, java.util.Comparator<? super T>);
               private void heapify();
               public java.util.Comparator<? super E> comparator();
               private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;
               private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
               public final java.util.Spliterator<E> spliterator();
               public boolean removeIf(java.util.function.Predicate<? super E>);
               public boolean removeAll(java.util.Collection<?>);
               public boolean retainAll(java.util.Collection<?>);
               private static long[] nBits(int);
               private static void setBit(long[], int);
               private static boolean isClear(long[], int);
               private boolean bulkRemove(java.util.function.Predicate<? super E>);
               public void forEach(java.util.function.Consumer<? super E>);
               private static boolean lambda$retainAll$1(java.util.Collection, java.lang.Object);      
               private static boolean lambda$removeAll$0(java.util.Collection, java.lang.Object);   
           </code></pre>
           </div>
           </details>
           
           
           
           <h1 style="color:rgb(223, 3, 150)"> Dequeue</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             Dequeue
           
           
             public interface java.util.Deque<E> extends java.util.Queue<E> 
               public abstract void addFirst(E);
               public abstract void addLast(E);
               public abstract boolean offerFirst(E);
               public abstract boolean offerLast(E);
               public abstract E removeFirst();
               public abstract E removeLast();
               public abstract E pollFirst();
               public abstract E pollLast();
               public abstract E getFirst();
               public abstract E getLast();
               public abstract E peekFirst();
               public abstract E peekLast();
               public abstract boolean removeFirstOccurrence(java.lang.Object);
               public abstract boolean removeLastOccurrence(java.lang.Object);
               public abstract boolean add(E);
               public abstract boolean offer(E);
               public abstract E remove();
               public abstract E poll();
               public abstract E element();
               public abstract E peek();
               public abstract boolean addAll(java.util.Collection<? extends E>);
               public abstract void push(E);
               public abstract E pop();
               public abstract boolean remove(java.lang.Object);
               public abstract boolean contains(java.lang.Object);
               public abstract int size();
               public abstract java.util.Iterator<E> iterator();
               public abstract java.util.Iterator<E> descendingIterator();
           </code></pre>
           </div>
           </details>
           
           <h1 style="color:rgb(223, 3, 150)"> ArrayDequeue</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             ArrayDequeue
           
             public class java.util.ArrayDeque<E> extends java.util.AbstractCollection<E> implements java.util.Deque<E>, java.lang.Cloneable, java.io.Serializable {
               transient java.lang.Object[] elements;
               transient int head;
               transient int tail;
               private static final int MAX_ARRAY_SIZE;
               private static final long serialVersionUID;
               private void grow(int);
               private int newCapacity(int, int);
               public java.util.ArrayDeque();
               public java.util.ArrayDeque(int);
               public java.util.ArrayDeque(java.util.Collection<? extends E>);
               static final int inc(int, int);
               static final int dec(int, int);
               static final int inc(int, int, int);
               static final int sub(int, int, int);
               static final <E> E elementAt(java.lang.Object[], int);
               static final <E> E nonNullElementAt(java.lang.Object[], int);
               public void addFirst(E);
               public void addLast(E);
               public boolean addAll(java.util.Collection<? extends E>);
               private void copyElements(java.util.Collection<? extends E>);
               public boolean offerFirst(E);
               public boolean offerLast(E);
               public E removeFirst();
               public E removeLast();
               public E pollFirst();
               public E pollLast();
               public E getFirst();
               public E getLast();
               public E peekFirst();
               public E peekLast();
               public boolean removeFirstOccurrence(java.lang.Object);
               public boolean removeLastOccurrence(java.lang.Object);
               public boolean add(E);
               public boolean offer(E);
               public E remove();
               public E poll();
               public E element();
               public E peek();
               public void push(E);
               public E pop();
               boolean delete(int);
               public int size();
               public boolean isEmpty();
               public java.util.Iterator<E> iterator();
               public java.util.Iterator<E> descendingIterator();
               public java.util.Spliterator<E> spliterator();
               public void forEach(java.util.function.Consumer<? super E>);
               public boolean removeIf(java.util.function.Predicate<? super E>);
               public boolean removeAll(java.util.Collection<?>);
               public boolean retainAll(java.util.Collection<?>);
               private boolean bulkRemove(java.util.function.Predicate<? super E>);
               private static long[] nBits(int);
               private static void setBit(long[], int);
               private static boolean isClear(long[], int);
               private boolean bulkRemoveModified(java.util.function.Predicate<? super E>, int);
               public boolean contains(java.lang.Object);
               public boolean remove(java.lang.Object);
               public void clear();
               private static void circularClear(java.lang.Object[], int, int);
               public java.lang.Object[] toArray();
               private <T> T[] toArray(java.lang.Class<T[]>);
               public <T> T[] toArray(T[]);
               public java.util.ArrayDeque<E> clone();
               private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;        
               private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
               void checkInvariants();
               public java.lang.Object clone() throws java.lang.CloneNotSupportedException;
               private static boolean lambda$retainAll$1(java.util.Collection, java.lang.Object);      
               private static boolean lambda$removeAll$0(java.util.Collection, java.lang.Object); 
           
            
           </code></pre>
           </div>
           </details>
           
           
            
           <h1 style="color: rgb(204, 201, 32);">Set</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             SET
             
             public interface java.util.Set<E> extends java.util.Collection<E> 
             public abstract int size();
             public abstract boolean isEmpty();
             public abstract boolean contains(java.lang.Object);
             public abstract java.util.Iterator<E> iterator();
             public abstract java.lang.Object[] toArray();
             public abstract <T> T[] toArray(T[]);
             public abstract boolean add(E);
             public abstract boolean remove(java.lang.Object);
             public abstract boolean containsAll(java.util.Collection<?>);
             public abstract boolean addAll(java.util.Collection<? extends E>);
             public abstract boolean retainAll(java.util.Collection<?>);
             public abstract boolean removeAll(java.util.Collection<?>);
             public abstract void clear();
             public abstract boolean equals(java.lang.Object);
             public abstract int hashCode();
             public default java.util.Spliterator<E> spliterator();
             public static <E> java.util.Set<E> of();
             public static <E> java.util.Set<E> of(E);
             public static <E> java.util.Set<E> of(E, E);
             public static <E> java.util.Set<E> of(E, E, E);
             public static <E> java.util.Set<E> of(E, E, E, E);
             public static <E> java.util.Set<E> of(E, E, E, E, E);
             public static <E> java.util.Set<E> of(E, E, E, E, E, E);
             public static <E> java.util.Set<E> of(E, E, E, E, E, E, E);
             public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E);
             public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E, E);
             public static <E> java.util.Set<E> of(E, E, E, E, E, E, E, E, E, E);
             public static <E> java.util.Set<E> of(E...);
             public static <E> java.util.Set<E> copyOf(java.util.Collection<? extends E>);
             
           </code></pre>
           </div>
           </details>
           
           
           
           <h1 style="color:rgb(223, 3, 150)"> HashSet</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
             HASHSET
             
             public class java.util.HashSet<E> extends java.util.AbstractSet<E> implements java.util.Set<E>, java.lang.Cloneable, java.io.Serializable {
             public java.util.HashSet();
             public java.util.HashSet(java.util.Collection<? extends E>);
             public java.util.HashSet(int, float);
             public java.util.HashSet(int);
             public java.util.Iterator<E> iterator();
             public int size();
             public boolean isEmpty();
             public boolean contains(java.lang.Object);
             public boolean add(E);
             public boolean remove(java.lang.Object);
             public void clear();
             public java.lang.Object clone();
             public java.util.Spliterator<E> spliterator();
             public java.lang.Object[] toArray();
             public <T> T[] toArray(T[]);
             public static <T> java.util.HashSet<T> newHashSet(int);
           </div>
           </details>
           
           
           
           <h1 style="color:rgb(223, 3, 150)"> linkedhashset</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             linkedhashset
           
           
             public class java.util.LinkedHashSet<E> extends java.util.HashSet<E> implements java.util.Set<E>, java.lang.Cloneable, java.io.Serializable {
               private static final long serialVersionUID;
               public java.util.LinkedHashSet(int, float);
               public java.util.LinkedHashSet(int);
               public java.util.LinkedHashSet();
               public java.util.LinkedHashSet(java.util.Collection<? extends E>);
               public java.util.Spliterator<E> spliterator();
               public static <T> java.util.LinkedHashSet<T> newLinkedHashSet(int);
           </code></pre>
           </div>
           </details>
           
           
           <h1 style="color:rgb(223, 3, 150)">TreeSet</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             TREESET
             
             public class java.util.TreeSet<E> extends java.util.AbstractSet<E> implements java.util.NavigableSet<E>, java.lang.Cloneable, java.io.Serializable {
             public java.util.TreeSet();
             public java.util.TreeSet(java.util.Comparator<? super E>);
             public java.util.TreeSet(java.util.Collection<? extends E>);
             public java.util.TreeSet(java.util.SortedSet<E>);
             public java.util.Iterator<E> iterator();
             public java.util.Iterator<E> descendingIterator();
             public java.util.NavigableSet<E> descendingSet();
             public int size();
             public boolean isEmpty();
             public boolean contains(java.lang.Object);
             public boolean add(E);
             public boolean remove(java.lang.Object);
             public void clear();
             public boolean addAll(java.util.Collection<? extends E>);
             public java.util.NavigableSet<E> subSet(E, boolean, E, boolean);
             public java.util.NavigableSet<E> headSet(E, boolean);
             public java.util.NavigableSet<E> tailSet(E, boolean);
             public java.util.SortedSet<E> subSet(E, E);
             public java.util.SortedSet<E> headSet(E);
             public java.util.SortedSet<E> tailSet(E);
             public java.util.Comparator<? super E> comparator();
             public E first();
             public E last();
             public E lower(E);
             public E floor(E);
             public E ceiling(E);
             public E higher(E);
             public E pollFirst();
             public E pollLast();
             public java.lang.Object clone();
             public java.util.Spliterator<E> spliterator();
           </code></pre>
           </div>
           </details>
           
           
           
           <h1>Map</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             MAP
             
             public interface java.util.Map<K, V> {
             public abstract int size();
             public abstract boolean isEmpty();
             public abstract boolean containsKey(java.lang.Object);
             public abstract boolean containsValue(java.lang.Object);
             public abstract V get(java.lang.Object);
             public abstract V put(K, V);
             public abstract V remove(java.lang.Object);
             public abstract void putAll(java.util.Map<? extends K, ? extends V>);
             public abstract void clear();
             public abstract java.util.Set<K> keySet();
             public abstract java.util.Collection<V> values();
             public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();
             public abstract boolean equals(java.lang.Object);
             public abstract int hashCode();
             public default V getOrDefault(java.lang.Object, V);
             public default void forEach(java.util.function.BiConsumer<? super K, ? super V>);
             public default void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public default V putIfAbsent(K, V);
             public default boolean remove(java.lang.Object, java.lang.Object);
             public default boolean replace(K, V, V);
             public default V replace(K, V);
             public default V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
             public default V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public default V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public default V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
             public static <K, V> java.util.Map<K, V> of();
             public static <K, V> java.util.Map<K, V> of(K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V);      
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> ofEntries(java.util.Map$Entry<? extends K, ? extends V>...);
             public static <K, V> java.util.Map$Entry<K, V> entry(K, V);
             public static <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V>);
           </code></pre>
           </div>
           </details>
           
           
           <h1 style="color: rgb(204, 201, 32);">HashMap</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             HASHMAP
             
             public class java.util.HashMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.Map<K, V>, java.lang.Cloneable, java.io.Serializable {
             public java.util.HashMap(int, float);
             public java.util.HashMap(int);
             public java.util.HashMap();
             public java.util.HashMap(java.util.Map<? extends K, ? extends V>);
             public int size();
             public boolean isEmpty();
             public V get(java.lang.Object);
             public boolean containsKey(java.lang.Object);
             public V put(K, V);
             public void putAll(java.util.Map<? extends K, ? extends V>);
             public V remove(java.lang.Object);
             public void clear();
             public boolean containsValue(java.lang.Object);
             public java.util.Set<K> keySet();
             public java.util.Collection<V> values();
             public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
             public V getOrDefault(java.lang.Object, V);
             public V putIfAbsent(K, V);
             public boolean remove(java.lang.Object, java.lang.Object);
             public boolean replace(K, V, V);
             public V replace(K, V);
             public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
             public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);      
             public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);     
             public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
             public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);   
             public java.lang.Object clone();
             public static <K, V> java.util.HashMap<K, V> newHashMap(int);
           </code></pre>
           </div>
           </details>
           
           
           
           <h1 style="color: rgb(204, 201, 32);">LinkedHashMap</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             LinkedHashMap
           
           
             public class java.util.LinkedHashMap<K, V> extends java.util.HashMap<K, V> implements java.util.Map<K, V> {
               private static final long serialVersionUID;
               transient java.util.LinkedHashMap$Entry<K, V> head;
               transient java.util.LinkedHashMap$Entry<K, V> tail;
               final boolean accessOrder;
               private void linkNodeLast(java.util.LinkedHashMap$Entry<K, V>);
               private void transferLinks(java.util.LinkedHashMap$Entry<K, V>, java.util.LinkedHashMap$Entry<K, V>);
               void reinitialize();
               java.util.HashMap$Node<K, V> newNode(int, K, V, java.util.HashMap$Node<K, V>);
               java.util.HashMap$Node<K, V> replacementNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);
               java.util.HashMap$TreeNode<K, V> newTreeNode(int, K, V, java.util.HashMap$Node<K, V>);  
               java.util.HashMap$TreeNode<K, V> replacementTreeNode(java.util.HashMap$Node<K, V>, java.util.HashMap$Node<K, V>);
               void afterNodeRemoval(java.util.HashMap$Node<K, V>);
               void afterNodeInsertion(boolean);
               void afterNodeAccess(java.util.HashMap$Node<K, V>);
               void internalWriteEntries(java.io.ObjectOutputStream) throws java.io.IOException;       
               public java.util.LinkedHashMap(int, float);
               public java.util.LinkedHashMap(int);
               public java.util.LinkedHashMap();
               public java.util.LinkedHashMap(java.util.Map<? extends K, ? extends V>);
               public java.util.LinkedHashMap(int, float, boolean);
               public boolean containsValue(java.lang.Object);
               public V get(java.lang.Object);
               public V getOrDefault(java.lang.Object, V);
               public void clear();
               protected boolean removeEldestEntry(java.util.Map$Entry<K, V>);
               public java.util.Set<K> keySet();
               final <T> T[] keysToArray(T[]);
               final <T> T[] valuesToArray(T[]);
               public java.util.Collection<V> values();
               public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
               public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
               public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
               public static <K, V> java.util.LinkedHashMap<K, V> newLinkedHashMap(int);
           </code></pre>
           </div>
           </details>
           
           
           
           <h1 style="color: rgb(204, 201, 32);">TreeMap</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             
             TREEMAP
             
             public class java.util.TreeMap<K, V> extends java.util.AbstractMap<K, V> implements java.util.NavigableMap<K, V>, java.lang.Cloneable, java.io.Serializable {
             public java.util.TreeMap();
             public java.util.TreeMap(java.util.Comparator<? super K>);
             public java.util.TreeMap(java.util.Map<? extends K, ? extends V>);
             public java.util.TreeMap(java.util.SortedMap<K, ? extends V>);
             public int size();
             public boolean containsKey(java.lang.Object);
             public boolean containsValue(java.lang.Object);
             public V get(java.lang.Object);
             public java.util.Comparator<? super K> comparator();
             public K firstKey();
             public K lastKey();
             public void putAll(java.util.Map<? extends K, ? extends V>);
             public V put(K, V);
             public V putIfAbsent(K, V);
             public V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
             public V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);      
             public V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
             public V remove(java.lang.Object);
             public void clear();
             public java.lang.Object clone();
             public java.util.Map$Entry<K, V> firstEntry();
             public java.util.Map$Entry<K, V> lastEntry();
             public java.util.Map$Entry<K, V> pollFirstEntry();
             public java.util.Map$Entry<K, V> pollLastEntry();
             public java.util.Map$Entry<K, V> lowerEntry(K);
             public K lowerKey(K);
             public java.util.Map$Entry<K, V> floorEntry(K);
             public K floorKey(K);
             public java.util.Map$Entry<K, V> ceilingEntry(K);
             public K ceilingKey(K);
             public java.util.Map$Entry<K, V> higherEntry(K);
             public K higherKey(K);
             public java.util.Set<K> keySet();
             public java.util.NavigableSet<K> navigableKeySet();
             public java.util.NavigableSet<K> descendingKeySet();
             public java.util.Collection<V> values();
             public java.util.Set<java.util.Map$Entry<K, V>> entrySet();
             public java.util.NavigableMap<K, V> descendingMap();
             public java.util.NavigableMap<K, V> subMap(K, boolean, K, boolean);
             public java.util.NavigableMap<K, V> headMap(K, boolean);
             public java.util.NavigableMap<K, V> tailMap(K, boolean);
             public java.util.SortedMap<K, V> subMap(K, K);
             public java.util.SortedMap<K, V> headMap(K);
             public java.util.SortedMap<K, V> tailMap(K);
             public boolean replace(K, V, V);
             public V replace(K, V);
             public void forEach(java.util.function.BiConsumer<? super K, ? super V>);
             public void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);   
           </code></pre>
           </div>
           </details>
           
           
           <h1>Map.Entry</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               Map.Entry
           
               public interface java.util.Map<K, V> 
             public abstract int size();
             public abstract boolean isEmpty();
             public abstract boolean containsKey(java.lang.Object);
             public abstract boolean containsValue(java.lang.Object);
             public abstract V get(java.lang.Object);
             public abstract V put(K, V);
             public abstract V remove(java.lang.Object);
             public abstract void putAll(java.util.Map<? extends K, ? extends V>);
             public abstract void clear();
             public abstract java.util.Set<K> keySet();
             public abstract java.util.Collection<V> values();
             public abstract java.util.Set<java.util.Map$Entry<K, V>> entrySet();
             public abstract boolean equals(java.lang.Object);
             public abstract int hashCode();
             public default V getOrDefault(java.lang.Object, V);
             public default void forEach(java.util.function.BiConsumer<? super K, ? super V>);       
             public default void replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public default V putIfAbsent(K, V);
             public default boolean remove(java.lang.Object, java.lang.Object);
             public default boolean replace(K, V, V);
             public default V replace(K, V);
             public default V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
             public default V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public default V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
             public default V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>);
             public static <K, V> java.util.Map<K, V> of();
             public static <K, V> java.util.Map<K, V> of(K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V);  
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> of(K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V, K, V);
             public static <K, V> java.util.Map<K, V> ofEntries(java.util.Map$Entry<? extends K, ? extends V>...);
             public static <K, V> java.util.Map$Entry<K, V> entry(K, V);
             public static <K, V> java.util.Map<K, V> copyOf(java.util.Map<? extends K, ? extends V>);
             </code>
           </pre>
           </div>
           </details>
           
           
           
           <h1>Dictionary</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               Dictionary
           
                 public abstract class java.util.Dictionary<K, V> 
                 public java.util.Dictionary();
                 public abstract int size();
                 public abstract boolean isEmpty();
                 public abstract java.util.Enumeration<K> keys();
                 public abstract java.util.Enumeration<V> elements();
                 public abstract V get(java.lang.Object);
                 public abstract V put(K, V);
                 public abstract V remove(java.lang.Object);
             </code>
           </pre>
           </div>
           </details>
           
           
           
           
           
           
           <h1 style="color: rgb(204, 201, 32);"> HashTable</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre><code>
             HashTable
           
             public class java.util.Hashtable<K, V> extends java.util.Dictionary<K, V> implements java.util.Map<K, V>, java.lang.Cloneable, java.io.Serializable {
               private transient java.util.Hashtable$Entry<?, ?>[] table;
               private transient int count;
               private int threshold;
               private float loadFactor;
               private transient int modCount;
               private static final long serialVersionUID;
               private static final int MAX_ARRAY_SIZE;
               private volatile transient java.util.Set<K> keySet;
               private volatile transient java.util.Set<java.util.Map$Entry<K, V>> entrySet;
               private volatile transient java.util.Collection<V> values;
               private static final int KEYS;
               private static final int VALUES;
               private static final int ENTRIES;
               public java.util.Hashtable(int, float);
               public java.util.Hashtable(int);
               public java.util.Hashtable();
               public java.util.Hashtable(java.util.Map<? extends K, ? extends V>);
               java.util.Hashtable(java.lang.Void);
               public synchronized int size();
               public synchronized boolean isEmpty();
               public synchronized java.util.Enumeration<K> keys();
               public synchronized java.util.Enumeration< V> elements();
               public synchronized boolean contains(java.lang.Object);
               public boolean containsValue(java.lang.Object);
               public synchronized boolean containsKey(java.lang.Object);
               public synchronized V get(java.lang.Object);
               protected void rehash();
               private void addEntry(int, K, V, int);
               public synchronized V put(K, V);
               public synchronized V remove(java.lang.Object);
               public synchronized void putAll(java.util.Map<? extends K, ? extends V>);
               public synchronized void clear();
               public synchronized java.lang.Object clone();
               final java.util.Hashtable<?, ?> cloneHashtable();
               public synchronized java.lang.String toString();
               private < T> java.util.Enumeration< T> getEnumeration(int);
               private < T> java.util.Iterator< T> getIterator(int);
               public java.util.Set< K> keySet();
               public java.util.Set< java.util.Map$Entry< K, V>> entrySet();
               public java.util.Collection< V> values();
               public synchronized boolean equals(java.lang.Object);
               public synchronized int hashCode();
               public synchronized V getOrDefault(java.lang.Object, V);
               public synchronized void forEach(java.util.function.BiConsumer<? super K, ? super V>);
               public synchronized void replaceAll(java.util.function.BiFunction<? super K, ? super V, 
             ? extends V>);
               public synchronized V putIfAbsent(K, V);
               public synchronized boolean remove(java.lang.Object, java.lang.Object);
               public synchronized boolean replace(K, V, V);
               public synchronized V replace(K, V);
               public synchronized V computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>);
               public synchronized V computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
               public synchronized V compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>);
               public synchronized V merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? 
             extends V>);
               private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;
               void writeHashtable(java.io.ObjectOutputStream) throws java.io.IOException;
               final void defaultWriteHashtable(java.io.ObjectOutputStream, int, float) throws java.io.IOException;
               private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
               void readHashtable(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
               private void reconstitutionPut(java.util.Hashtable$Entry<?, ?>[], K, V) throws java.io.StreamCorruptedException;
             }
           </code>
           </pre>
           </div>
           </details>
           
           
           <h1>properties</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
              properties
           
              public class java.util.Properties extends java.util.Hashtable< java.lang.Object, java.lang.Object> {
               private static final long serialVersionUID;
               private static final jdk.internal.misc.Unsafe UNSAFE;
               protected volatile java.util.Properties defaults;
               private volatile transient java.util.concurrent.ConcurrentHashMap< java.lang.Object, java.lang.Object> map;
               public java.util.Properties();
               public java.util.Properties(int);
               public java.util.Properties(java.util.Properties);
               private java.util.Properties(java.util.Properties, int);
               public synchronized java.lang.Object setProperty(java.lang.String, java.lang.String);   
               public synchronized void load(java.io.Reader) throws java.io.IOException;
               public synchronized void load(java.io.InputStream) throws java.io.IOException;
               private void load0(java.util.Properties$LineReader) throws java.io.IOException;
               private java.lang.String loadConvert(char[], int, int, java.lang.StringBuilder);
               private java.lang.String saveConvert(java.lang.String, boolean, boolean);
               private static void writeComments(java.io.BufferedWriter, java.lang.String) throws java.io.IOException;
               public void save(java.io.OutputStream, java.lang.String);
               public void store(java.io.Writer, java.lang.String) throws java.io.IOException;
               public void store(java.io.OutputStream, java.lang.String) throws java.io.IOException;
               private void store0(java.io.BufferedWriter, java.lang.String, boolean) throws java.io.IOException;
               private static void writeDateComment(java.io.BufferedWriter) throws java.io.IOException;
               public synchronized void loadFromXML(java.io.InputStream) throws java.io.IOException, java.util.InvalidPropertiesFormatException;
               public void storeToXML(java.io.OutputStream, java.lang.String) throws java.io.IOException;
               public void storeToXML(java.io.OutputStream, java.lang.String, java.lang.String) throws java.io.IOException;
               public void storeToXML(java.io.OutputStream, java.lang.String, java.nio.charset.Charset) throws java.io.IOException;
               public java.lang.String getProperty(java.lang.String);
               public java.lang.String getProperty(java.lang.String, java.lang.String);
               public java.util.Enumeration<?> propertyNames();
               public java.util.Set< java.lang.String> stringPropertyNames();
               public void list(java.io.PrintStream);
               public void list(java.io.PrintWriter);
               private void enumerate(java.util.Map< java.lang.String, java.lang.Object>);
               private void enumerateStringProperties(java.util.Map< java.lang.String, java.lang.String>);
               public int size();
               public boolean isEmpty();
               public java.util.Enumeration< java.lang.Object> keys();
               public java.util.Enumeration< java.lang.Object> elements();
               public boolean contains(java.lang.Object);
               public boolean containsValue(java.lang.Object);
               public boolean containsKey(java.lang.Object);
               public java.lang.Object get(java.lang.Object);
               public synchronized java.lang.Object put(java.lang.Object, java.lang.Object);
               public synchronized java.lang.Object remove(java.lang.Object);
               public synchronized void putAll(java.util.Map<?, ?>);
               public synchronized void clear();
               public synchronized java.lang.String toString();
               public java.util.Set< java.lang.Object> keySet();
               public java.util.Collection< java.lang.Object> values();
               public java.util.Set< java.util.Map$Entry< java.lang.Object, java.lang.Object>> entrySet();
               public synchronized boolean equals(java.lang.Object);
               public synchronized int hashCode();
               public java.lang.Object getOrDefault(java.lang.Object, java.lang.Object);
               public synchronized void forEach(java.util.function.BiConsumer<? super java.lang.Object, ? super java.lang.Object>);
               public synchronized void replaceAll(java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
               public synchronized java.lang.Object putIfAbsent(java.lang.Object, java.lang.Object);   
               public synchronized boolean remove(java.lang.Object, java.lang.Object);
               public synchronized boolean replace(java.lang.Object, java.lang.Object, java.lang.Object);
               public synchronized java.lang.Object replace(java.lang.Object, java.lang.Object);
               public synchronized java.lang.Object computeIfAbsent(java.lang.Object, java.util.function.Function<? super java.lang.Object, ?>);
               public synchronized java.lang.Object computeIfPresent(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
               public synchronized java.lang.Object compute(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
               public synchronized java.lang.Object merge(java.lang.Object, java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ?>);
               protected void rehash();
               public synchronized java.lang.Object clone();
               void writeHashtable(java.io.ObjectOutputStream) throws java.io.IOException;
               void readHashtable(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
               static {};
             </code>
           </pre>
           </div>
           </details>
           
           <h1>Iterator</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               Iterator
           
                 public interface java.util.Iterator<E> 
                 public abstract boolean hasNext();
                 public abstract E next();
                 public default void remove();
                 public default void forEachRemaining(java.util.function.Consumer<? super E>);
             </code>
           </pre>
           </div>
           </details>
           
           <h1>Other Utility Classes:</h1>
           <pre>
             
           Arrays: Provides utility methods for working with arrays, like sorting and searching.
           Date: Represents a specific instant in time.
           Calendar: Provides methods for manipulating dates and times.
           Random: Generates random numbers.
           Scanner: Allows parsing primitive types and strings using regular expressions.
           TimeZone: Represents a time zone offset, and also figures daylight savings.
           </pre>
           
           <h1>Array</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               ARRAYS 
           
             public class java.util.Arrays 
             public static void sort(int[]);
             public static void sort(int[], int, int);
             public static void sort(long[]);
             public static void sort(long[], int, int);
             public static void sort(short[]);
             public static void sort(short[], int, int);
             public static void sort(char[]);
             public static void sort(char[], int, int);
             public static void sort(byte[]);
             public static void sort(byte[], int, int);
             public static void sort(float[]);
             public static void sort(float[], int, int);
             public static void sort(double[]);
             public static void sort(double[], int, int);
             public static void parallelSort(byte[]);
             public static void parallelSort(byte[], int, int);
             public static void parallelSort(char[]);
             public static void parallelSort(char[], int, int);
             public static void parallelSort(short[]);
             public static void parallelSort(short[], int, int);
             public static void parallelSort(int[]);
             public static void parallelSort(int[], int, int);
             public static void parallelSort(long[]);
             public static void parallelSort(long[], int, int);
             public static void parallelSort(float[]);
             public static void parallelSort(float[], int, int);
             public static void parallelSort(double[]);
             public static void parallelSort(double[], int, int);
             public static <T extends java.lang.Comparable<? super T>> void parallelSort(T[]);
             public static <T extends java.lang.Comparable<? super T>> void parallelSort(T[], int, int);
             public static <T> void parallelSort(T[], java.util.Comparator<? super T>);
             public static <T> void parallelSort(T[], int, int, java.util.Comparator<? super T>);
             public static void sort(java.lang.Object[]);
             public static void sort(java.lang.Object[], int, int);
             public static <T> void sort(T[], java.util.Comparator<? super T>);
             public static <T> void sort(T[], int, int, java.util.Comparator<? super T>);
             public static <T> void parallelPrefix(T[], java.util.function.BinaryOperator<T>);
             public static <T> void parallelPrefix(T[], int, int, java.util.function.BinaryOperator<T>);
             public static void parallelPrefix(long[], java.util.function.LongBinaryOperator);
             public static void parallelPrefix(long[], int, int, java.util.function.LongBinaryOperator); 
             public static void parallelPrefix(double[], java.util.function.DoubleBinaryOperator);
             public static void parallelPrefix(double[], int, int, java.util.function.DoubleBinaryOperator);
             public static void parallelPrefix(int[], java.util.function.IntBinaryOperator);
             public static void parallelPrefix(int[], int, int, java.util.function.IntBinaryOperator);   
             public static int binarySearch(long[], long);
             public static int binarySearch(long[], int, int, long);
             public static int binarySearch(int[], int);
             public static int binarySearch(int[], int, int, int);
             public static int binarySearch(short[], short);
             public static int binarySearch(short[], int, int, short);
             public static int binarySearch(char[], char);
             public static int binarySearch(char[], int, int, char);
             public static int binarySearch(byte[], byte);
             public static int binarySearch(byte[], int, int, byte);
             public static int binarySearch(double[], double);
             public static int binarySearch(double[], int, int, double);
             public static int binarySearch(float[], float);
             public static int binarySearch(float[], int, int, float);
             public static int binarySearch(java.lang.Object[], java.lang.Object);
             public static int binarySearch(java.lang.Object[], int, int, java.lang.Object);
             public static <T> int binarySearch(T[], T, java.util.Comparator<? super T>);
             public static <T> int binarySearch(T[], int, int, T, java.util.Comparator<? super T>);      
             public static boolean equals(long[], long[]);
             public static boolean equals(long[], int, int, long[], int, int);
             public static boolean equals(int[], int[]);
             public static boolean equals(int[], int, int, int[], int, int);
             public static boolean equals(short[], short[]);
             public static boolean equals(short[], int, int, short[], int, int);
             public static boolean equals(char[], char[]);
             public static boolean equals(char[], int, int, char[], int, int);
             public static boolean equals(byte[], byte[]);
             public static boolean equals(byte[], int, int, byte[], int, int);
             public static boolean equals(boolean[], boolean[]);
             public static boolean equals(boolean[], int, int, boolean[], int, int);
             public static boolean equals(double[], double[]);
             public static boolean equals(double[], int, int, double[], int, int);
             public static boolean equals(float[], float[]);
             public static boolean equals(float[], int, int, float[], int, int);
             public static boolean equals(java.lang.Object[], java.lang.Object[]);
             public static boolean equals(java.lang.Object[], int, int, java.lang.Object[], int, int);
             public static <T> boolean equals(T[], T[], java.util.Comparator<? super T>);
             public static <T> boolean equals(T[], int, int, T[], int, int, java.util.Comparator<? super T>);
             public static void fill(long[], long);
             public static void fill(long[], int, int, long);
             public static void fill(int[], int);
             public static void fill(int[], int, int, int);
             public static void fill(short[], short);
             public static void fill(short[], int, int, short);
             public static void fill(char[], char);
             public static void fill(char[], int, int, char);
             public static void fill(byte[], byte);
             public static void fill(byte[], int, int, byte);
             public static void fill(boolean[], boolean);
             public static void fill(boolean[], int, int, boolean);
             public static void fill(double[], double);
             public static void fill(double[], int, int, double);
             public static void fill(float[], float);
             public static void fill(float[], int, int, float);
             public static void fill(java.lang.Object[], java.lang.Object);
             public static void fill(java.lang.Object[], int, int, java.lang.Object);
             public static <T> T[] copyOf(T[], int);
             public static <T, U> T[] copyOf(U[], int, java.lang.Class<? extends T[]>);
             public static byte[] copyOf(byte[], int);
             public static short[] copyOf(short[], int);
             public static int[] copyOf(int[], int);
             public static long[] copyOf(long[], int);
             public static char[] copyOf(char[], int);
             public static float[] copyOf(float[], int);
             public static double[] copyOf(double[], int);
             public static boolean[] copyOf(boolean[], int);
             public static <T> T[] copyOfRange(T[], int, int);
             public static <T, U> T[] copyOfRange(U[], int, int, java.lang.Class<? extends T[]>);        
             public static byte[] copyOfRange(byte[], int, int);
             public static short[] copyOfRange(short[], int, int);
             public static int[] copyOfRange(int[], int, int);
             public static long[] copyOfRange(long[], int, int);
             public static char[] copyOfRange(char[], int, int);
             public static float[] copyOfRange(float[], int, int);
             public static double[] copyOfRange(double[], int, int);
             public static boolean[] copyOfRange(boolean[], int, int);
             public static <T> java.util.List<T> asList(T...);
             public static int hashCode(long[]);
             public static int hashCode(int[]);
             public static int hashCode(short[]);
             public static int hashCode(char[]);
             public static int hashCode(byte[]);
             public static int hashCode(boolean[]);
             public static int hashCode(float[]);
             public static int hashCode(double[]);
             public static int hashCode(java.lang.Object[]);
             public static int deepHashCode(java.lang.Object[]);
             public static boolean deepEquals(java.lang.Object[], java.lang.Object[]);
             public static java.lang.String toString(long[]);
             public static java.lang.String toString(int[]);
             public static java.lang.String toString(short[]);
             public static java.lang.String toString(char[]);
             public static java.lang.String toString(byte[]);
             public static java.lang.String toString(boolean[]);
             public static java.lang.String toString(float[]);
             public static java.lang.String toString(double[]);
             public static java.lang.String toString(java.lang.Object[]);
             public static java.lang.String deepToString(java.lang.Object[]);
             public static <T> void setAll(T[], java.util.function.IntFunction<? extends T>);
             public static <T> void parallelSetAll(T[], java.util.function.IntFunction<? extends T>);    
             public static void setAll(int[], java.util.function.IntUnaryOperator);
             public static void parallelSetAll(int[], java.util.function.IntUnaryOperator);
             public static void setAll(long[], java.util.function.IntToLongFunction);
             public static void parallelSetAll(long[], java.util.function.IntToLongFunction);
             public static void setAll(double[], java.util.function.IntToDoubleFunction);
             public static void parallelSetAll(double[], java.util.function.IntToDoubleFunction);
             public static <T> java.util.Spliterator<T> spliterator(T[]);
             public static <T> java.util.Spliterator<T> spliterator(T[], int, int);
             public static java.util.Spliterator$OfInt spliterator(int[]);
             public static java.util.Spliterator$OfInt spliterator(int[], int, int);
             public static java.util.Spliterator$OfLong spliterator(long[]);
             public static java.util.Spliterator$OfLong spliterator(long[], int, int);
             public static java.util.Spliterator$OfDouble spliterator(double[]);
             public static java.util.Spliterator$OfDouble spliterator(double[], int, int);
             public static <T> java.util.stream.Stream<T> stream(T[]);
             public static <T> java.util.stream.Stream<T> stream(T[], int, int);
             public static java.util.stream.IntStream stream(int[]);
             public static java.util.stream.IntStream stream(int[], int, int);
             public static java.util.stream.LongStream stream(long[]);
             public static java.util.stream.LongStream stream(long[], int, int);
             public static java.util.stream.DoubleStream stream(double[]);
             public static java.util.stream.DoubleStream stream(double[], int, int);
             public static int compare(boolean[], boolean[]);
             public static int compare(boolean[], int, int, boolean[], int, int);
             public static int compare(byte[], byte[]);
             public static int compare(byte[], int, int, byte[], int, int);
             public static int compareUnsigned(byte[], byte[]);
             public static int compareUnsigned(byte[], int, int, byte[], int, int);
             public static int compare(short[], short[]);
             public static int compare(short[], int, int, short[], int, int);
             public static int compareUnsigned(short[], short[]);
             public static int compareUnsigned(short[], int, int, short[], int, int);
             public static int compare(char[], char[]);
             public static int compare(char[], int, int, char[], int, int);
             public static int compare(int[], int[]);
             public static int compare(int[], int, int, int[], int, int);
             public static int compareUnsigned(int[], int[]);
             public static int compareUnsigned(int[], int, int, int[], int, int);
             public static int compare(long[], long[]);
             public static int compare(long[], int, int, long[], int, int);
             public static int compareUnsigned(long[], long[]);
             public static int compareUnsigned(long[], int, int, long[], int, int);
             public static int compare(float[], float[]);
             public static int compare(float[], int, int, float[], int, int);
             public static int compare(double[], double[]);
             public static int compare(double[], int, int, double[], int, int);
             public static <T extends java.lang.Comparable<? super T>> int compare(T[], T[]);
             public static <T extends java.lang.Comparable<? super T>> int compare(T[], int, int, T[], int, int);
             public static <T> int compare(T[], T[], java.util.Comparator<? super T>);
             public static <T> int compare(T[], int, int, T[], int, int, java.util.Comparator<? super T>);
             public static int mismatch(boolean[], boolean[]);
             public static int mismatch(boolean[], int, int, boolean[], int, int);
             public static int mismatch(byte[], byte[]);
             public static int mismatch(byte[], int, int, byte[], int, int);
             public static int mismatch(char[], char[]);
             public static int mismatch(short[], short[]);
             public static int mismatch(short[], int, int, short[], int, int);
             public static int mismatch(int[], int[]);
             public static int mismatch(int[], int, int, int[], int, int);
             public static int mismatch(long[], long[]);
             public static int mismatch(int[], int, int, int[], int, int);
             public static int mismatch(long[], long[]);
             public static int mismatch(float[], float[]);
             public static int mismatch(float[], int, int, float[], int, int);
             public static int mismatch(double[], double[]);
             public static int mismatch(double[], int, int, double[], int, int);
             public static int mismatch(java.lang.Object[], java.lang.Object[]);
             public static int mismatch(java.lang.Object[], int, int, java.lang.Object[], int, int);     
             public static <T> int mismatch(T[], T[], java.util.Comparator<? super T>);
             public static <T> int mismatch(T[], int, int, T[], int, int, java.util.Comparator<? super T>
             </code>
           </pre>
           </div>
           </details>
           
           <h1>Date</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               Date
           
               public class java.util.Date implements java.io.Serializable, java.lang.Cloneable, java.lang.Comparable<java.util.Date> {
                 private static final sun.util.calendar.BaseCalendar gcal;
                 private static sun.util.calendar.BaseCalendar jcal;
                 private transient long fastTime;
                 private transient sun.util.calendar.BaseCalendar$Date cdate;
                 private static int defaultCenturyStart;
                 private static final long serialVersionUID;
                 private static final java.lang.String[] wtb;
                 private static final int[] ttb;
                 public java.util.Date();
                 public java.util.Date(long);
                 public java.util.Date(int, int, int);
                 public java.util.Date(int, int, int, int, int);
                 public java.util.Date(int, int, int, int, int, int);
                 public java.util.Date(java.lang.String);
                 public java.lang.Object clone();
                 public static long UTC(int, int, int, int, int, int);
                 public static long parse(java.lang.String);
                 public int getYear();
                 public void setYear(int);
                 public int getMonth();
                 public void setMonth(int);
                 public int getDate();
                 public void setDate(int);
                 public int getDay();
                 public int getHours();
                 public void setHours(int);
                 public int getMinutes();
                 public void setMinutes(int);
                 public int getSeconds();
                 public void setSeconds(int);
                 public long getTime();
                 private final long getTimeImpl();
                 public void setTime(long);
                 public boolean before(java.util.Date);
                 public boolean after(java.util.Date);
                 public boolean equals(java.lang.Object);
                 static final long getMillisOf(java.util.Date);
                 public int compareTo(java.util.Date);
                 public int hashCode();
                 public java.lang.String toString();
                 private static final java.lang.StringBuilder convertToAbbr(java.lang.StringBuilder, java.lang.String);
                 public java.lang.String toLocaleString();
                 public java.lang.String toGMTString();
                 public int getTimezoneOffset();
                 private final sun.util.calendar.BaseCalendar$Date getCalendarDate();
                 private final sun.util.calendar.BaseCalendar$Date normalize();
                 private final sun.util.calendar.BaseCalendar$Date normalize(sun.util.calendar.BaseCalendar$Date);
                 private static final sun.util.calendar.BaseCalendar getCalendarSystem(int);
                 private static final sun.util.calendar.BaseCalendar getCalendarSystem(long);
                 private static final sun.util.calendar.BaseCalendar getCalendarSystem(sun.util.calendar.BaseCalendar$Date);
                 private static final synchronized sun.util.calendar.BaseCalendar getJulianCalendar();   
                 private void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;        
                 private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
                 public static java.util.Date from(java.time.Instant);
                 public java.time.Instant toInstant();
                 public int compareTo(java.lang.Object);
                 static {};
             </code>
           </pre>
           </div>
           </details>
           
           <h1>Random</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               Random
               
               public class java.util.Random implements java.util.random.RandomGenerator,java.io.Serializable 
                 static final long serialVersionUID;
                 private final java.util.concurrent.atomic.AtomicLong seed;
                 private static final long multiplier;
                 private static final long addend;
                 private static final long mask;
                 private static final double DOUBLE_UNIT;
                 private static final float FLOAT_UNIT;
                 private static final java.util.concurrent.atomic.AtomicLong seedUniquifier;
                 private double nextNextGaussian;
                 private boolean haveNextNextGaussian;
                 private static final java.io.ObjectStreamField[] serialPersistentFields;
                 private static final jdk.internal.misc.Unsafe unsafe;
                 private static final long seedOffset;
                 public java.util.Random();
                 private java.util.Random(java.lang.Void);
                 private static long seedUniquifier();
                 public java.util.Random(long);
                 private static long initialScramble(long);
                 public static java.util.Random from(java.util.random.RandomGenerator);
                 public synchronized void setSeed(long);
                 protected int next(int);
                 public void nextBytes(byte[]);
                 public int nextInt();
                 public int nextInt(int);
                 public long nextLong();
                 public boolean nextBoolean();
                 public float nextFloat();
                 public double nextDouble();
                 public synchronized double nextGaussian();
                 private void readObject(java.io.ObjectInputStream) throws java.io.IOException, java.lang.ClassNotFoundException;
                 private synchronized void writeObject(java.io.ObjectOutputStream) throws java.io.IOException;
                 private void resetSeed(long);
                 public java.util.stream.IntStream ints(long);
                 public java.util.stream.IntStream ints();
                 public java.util.stream.IntStream ints(long, int, int);
                 public java.util.stream.IntStream ints(int, int);
                 public java.util.stream.LongStream longs(long);
                 public java.util.stream.LongStream longs();
                 public java.util.stream.LongStream longs(long, long, long);
                 public java.util.stream.LongStream longs(long, long);
                 public java.util.stream.DoubleStream doubles(long);
                 public java.util.stream.DoubleStream doubles();
                 public java.util.stream.DoubleStream doubles(long, double, double);
                 public java.util.stream.DoubleStream doubles(double, double);
                 static {};
             </code>
           </pre>
           </div>
           </details>
           
           
           
           
           <h1>Scanner</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               Scanner
           
               public final class java.util.Scanner implements java.util.Iterator<java.lang.String>, java.io.Closeable {
                 private java.nio.CharBuffer buf;
                 private static final int BUFFER_SIZE;
                 private int position;
                 private java.util.regex.Matcher matcher;
                 private java.util.regex.Pattern delimPattern;
                 private java.util.regex.Pattern hasNextPattern;
                 private int hasNextPosition;
                 private java.lang.String hasNextResult;
                 private java.lang.Readable source;
                 private boolean sourceClosed;
                 private boolean needInput;
                 private boolean skipped;
                 private int savedScannerPosition;
                 private java.lang.Object typeCache;
                 private boolean matchValid;
                 private boolean closed;
                 private int radix;
                 private int defaultRadix;
                 private java.util.Locale locale;
                 private java.util.Scanner$PatternLRUCache patternCache;
                 private java.io.IOException lastException;
                 int modCount;
                 private static java.util.regex.Pattern WHITESPACE_PATTERN;
                 private static java.util.regex.Pattern FIND_ANY_PATTERN;
                 private static java.util.regex.Pattern NON_ASCII_DIGIT;
                 private java.lang.String groupSeparator;
                 private java.lang.String decimalSeparator;
                 private java.lang.String nanString;
                 private java.lang.String infinityString;
                 private java.lang.String positivePrefix;
                 private java.lang.String negativePrefix;
                 private java.lang.String positiveSuffix;
                 private java.lang.String negativeSuffix;
                 private static volatile java.util.regex.Pattern boolPattern;
                 private static final java.lang.String BOOLEAN_PATTERN;
                 private java.util.regex.Pattern integerPattern;
                 private java.lang.String digits;
                 private java.lang.String non0Digit;
                 private int SIMPLE_GROUP_INDEX;
                 private static volatile java.util.regex.Pattern separatorPattern;
                 private static volatile java.util.regex.Pattern linePattern;
                 private static final java.lang.String LINE_SEPARATOR_PATTERN;
                 private static final java.lang.String LINE_PATTERN;
                 private java.util.regex.Pattern floatPattern;
                 private java.util.regex.Pattern decimalPattern;
                 static final boolean $assertionsDisabled;
                 private static java.util.regex.Pattern boolPattern();
                 private java.lang.String buildIntegerPatternString();
                 private java.util.regex.Pattern integerPattern();
                 private static java.util.regex.Pattern separatorPattern();
                 private static java.util.regex.Pattern linePattern();
                 private void buildFloatAndDecimalPattern();
                 private java.util.regex.Pattern floatPattern();
                 private java.util.regex.Pattern decimalPattern();
                 private java.util.Scanner(java.lang.Readable, java.util.regex.Pattern);
                 public java.util.Scanner(java.lang.Readable);
                 public java.util.Scanner(java.io.InputStream);
                 public java.util.Scanner(java.io.InputStream, java.lang.String);
                 public java.util.Scanner(java.io.InputStream, java.nio.charset.Charset);
                 private static java.nio.charset.Charset toCharset(java.lang.String);
                 private static java.lang.Readable makeReadable(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
                 private static java.lang.Readable makeReadable(java.io.InputStream, java.nio.charset.Charset);
                 public java.util.Scanner(java.io.File) throws java.io.FileNotFoundException;
                 public java.util.Scanner(java.io.File, java.lang.String) throws java.io.FileNotFoundException;
                 public java.util.Scanner(java.io.File, java.nio.charset.Charset) throws java.io.IOException;
                 private java.util.Scanner(java.io.File, java.nio.charset.CharsetDecoder) throws java.io.FileNotFoundException;
                 private static java.nio.charset.CharsetDecoder toDecoder(java.lang.String);
                 private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel, java.nio.charset.CharsetDecoder);
                 private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel, java.nio.charset.Charset);
                 public java.util.Scanner(java.nio.file.Path) throws java.io.IOException;
                 public java.util.Scanner(java.nio.file.Path, java.lang.String) throws java.io.IOException;
                 public java.util.Scanner(java.nio.file.Path, java.nio.charset.Charset) throws java.io.IOException;
                 public java.util.Scanner(java.lang.String);
                 public java.util.Scanner(java.nio.channels.ReadableByteChannel);
                 private static java.lang.Readable makeReadable(java.nio.channels.ReadableByteChannel);
                 public java.util.Scanner(java.nio.channels.ReadableByteChannel, java.lang.String);      
                 public java.util.Scanner(java.nio.channels.ReadableByteChannel, java.nio.charset.Charset);
                 private void saveState();
                 private void revertState();
                 private boolean revertState(boolean);
                 private void cacheResult();
                 private void cacheResult(java.lang.String);
                 private void clearCaches();
                 private java.lang.String getCachedResult();
                 private void useTypeCache();
                 private void readInput();
                 private boolean makeSpace();
                 private void translateSavedIndexes(int);
                 private void throwFor();
                 private boolean hasTokenInBuffer();
                 private java.lang.String getCompleteTokenInBuffer(java.util.regex.Pattern);
                 private boolean findPatternInBuffer(java.util.regex.Pattern, int);
                 private boolean matchPatternInBuffer(java.util.regex.Pattern);
                 private void ensureOpen();
                 public void close();
                 public java.io.IOException ioException();
                 public java.util.regex.Pattern delimiter();
                 public java.util.Scanner useDelimiter(java.util.regex.Pattern);
                 public java.util.Scanner useDelimiter(java.lang.String);
                 public java.util.Locale locale();
                 public java.util.Scanner useLocale(java.util.Locale);
                 public int radix();
                 public java.util.Scanner useRadix(int);
                 private void setRadix(int);
                 public java.util.regex.MatchResult match();
                 public java.lang.String toString();
                 public boolean hasNext();
                 public java.lang.String next();
                 public void remove();
                 public boolean hasNext(java.lang.String);
                 public java.lang.String next(java.lang.String);
                 public boolean hasNext(java.util.regex.Pattern);
                 public java.lang.String next(java.util.regex.Pattern);
                 public boolean hasNextLine();
                 public java.lang.String nextLine();
                 public java.lang.String findInLine(java.lang.String);
                 public java.lang.String findInLine(java.util.regex.Pattern);
                 public java.lang.String findWithinHorizon(java.lang.String, int);
                 public java.lang.String findWithinHorizon(java.util.regex.Pattern, int);
                 public java.util.Scanner skip(java.util.regex.Pattern);
                 public java.util.Scanner skip(java.lang.String);
                 public boolean hasNextBoolean();
                 public boolean nextBoolean();
                 public boolean hasNextByte();
                 public boolean hasNextByte(int);
                 public byte nextByte();
                 public byte nextByte(int);
                 public boolean hasNextShort();
                 public boolean hasNextShort(int);
                 public short nextShort();
                 public short nextShort(int);
                 public boolean hasNextInt();
                 public boolean hasNextInt(int);
                 private java.lang.String processIntegerToken(java.lang.String);
                 public int nextInt();
                 public int nextInt(int);
                 public boolean hasNextLong();
                 public boolean hasNextLong(int);
                 public long nextLong();
                 public long nextLong(int);
                 private java.lang.String processFloatToken(java.lang.String);
                 public boolean hasNextFloat();
                 public float nextFloat();
                 public boolean hasNextDouble();
                 public double nextDouble();
                 public boolean hasNextBigInteger();
                 public boolean hasNextBigInteger(int);
                 public java.math.BigInteger nextBigInteger();
                 public java.math.BigInteger nextBigInteger(int);
                 public boolean hasNextBigDecimal();
                 public java.math.BigDecimal nextBigDecimal();
                 public java.util.Scanner reset();
                 public java.util.stream.Stream<java.lang.String> tokens();
                 public java.util.stream.Stream<java.util.regex.MatchResult> findAll(java.util.regex.Pattern);
                 public java.util.stream.Stream<java.util.regex.MatchResult> findAll(java.lang.String);  
                 public java.lang.Object next();
                 static {};
           
             </code>
           </pre>
           </div>
           </details>
           
           
           <h1>TimeZone:</h1>
           <details>
           <summary>
            <span class="faq-title"> 
              <h3>The Java String API provides a wide range of methods for working with strings. </h3></span>
            <img src="plus.svg" class="expand-icon" alt="Plus">
           </summary>        
           <div class="faq-content">
           <pre>
             <code>
               public abstract class java.util.TimeZone implements java.io.Serializable,java.lang.Cloneable {
                 public static final int SHORT;
                 public static final int LONG;
                 private static final int ONE_MINUTE;
                 private static final int ONE_HOUR;
                 private static final int ONE_DAY;
                 static final long serialVersionUID;
                 static final java.util.TimeZone NO_TIMEZONE;
                 private java.lang.String ID;
                 private transient java.time.ZoneId zoneId;
                 private static volatile java.util.TimeZone defaultTimeZone;
                 static final java.lang.String GMT_ID;
                 private static final int GMT_ID_LENGTH;
                 static final boolean $assertionsDisabled;
                 public java.util.TimeZone();
                 public abstract int getOffset(int, int, int, int, int, int);
                 public int getOffset(long);
                 int getOffsets(long, int[]);
                 public abstract void setRawOffset(int);
                 public abstract int getRawOffset();
                 public java.lang.String getID();
                 public void setID(java.lang.String);
                 public final java.lang.String getDisplayName();
                 public final java.lang.String getDisplayName(java.util.Locale);
                 public final java.lang.String getDisplayName(boolean, int);
                 public java.lang.String getDisplayName(boolean, int, java.util.Locale);
                 private static java.lang.String[] getDisplayNames(java.lang.String, java.util.Locale);
                 public int getDSTSavings();
                 public abstract boolean useDaylightTime();
                 public boolean observesDaylightTime();
                 public abstract boolean inDaylightTime(java.util.Date);
                 public static synchronized java.util.TimeZone getTimeZone(java.lang.String);
                 public static java.util.TimeZone getTimeZone(java.time.ZoneId);
                 public java.time.ZoneId toZoneId();
                 private java.time.ZoneId toZoneId0();
                 private static java.util.TimeZone getTimeZone(java.lang.String, boolean);
                 public static synchronized java.lang.String[] getAvailableIDs(int);
                 public static synchronized java.lang.String[] getAvailableIDs();
                 private static native java.lang.String getSystemTimeZoneID(java.lang.String);
                 private static native java.lang.String getSystemGMTOffsetID();
                 public static java.util.TimeZone getDefault();
                 static java.util.TimeZone getDefaultRef();
                 private static synchronized java.util.TimeZone setDefaultZone();
                 public static void setDefault(java.util.TimeZone);
                 public boolean hasSameRules(java.util.TimeZone);
                 public java.lang.Object clone();
                 private static final java.util.TimeZone parseCustomTimeZone(java.lang.String);
                 static {};
           
             </code>
           </pre>
           </div>
           </details>


 </div>
            
    <div id="stage">
        <canvas id="Canvas" width="50" height="45"></canvas>
     </div>
  
  
  
     <button onclick="topFunction()" id="myBtn" title="Go to top"><i class='bx bx-up-arrow-alt bx-sm' style='color:#ffffff'  ></i></button>
            
     <div id="recommend">
      <div class="recompopup">
          <h2>We've  a lot more for you to learn from </h2>
          <h1><span style="color: #8d67cf;">Free Courses </span> by Keesite</h1>
      <ul>
   
          <li>
          <a href="recommendation.html">
          <div class="course1">
              <img src="1.png" alt="">
              <h2>Cloud Computing</h2>
              <p>  Embrace the transformative power of cloud computing, Leverage its potential to optimize...</p>
          </div></a>
          <svg viewBox="0 0 200 200" width="25"  height="25" xmlns="http://www.w3.org/2000/svg">
              <circle cx="100" cy="100" fill="#8d67cf" r="78" stroke="black" stroke-width="3"/>
              <g class="eyes">
                <circle cx="61" cy="82" r="12"/>
                <circle cx="127" cy="82" r="12"/> </g>
              <path d="m136.81 116.53c.69 26.17-64.11 42-81.52-.73" style="fill:none; stroke: black; stroke-width: 3;"/>
            </svg>
      </li>
      <li>
          <a href="recommendation.html">
          <div class="course2">
              <img src="2.png" alt="">
              <h2>Networking</h2>
              <p> Explore the vast realm of networking to seamlessly connect and share information...</p>
  
          </div></a>
          <svg viewBox="0 0 200 200" width="25"  height="25" xmlns="http://www.w3.org/2000/svg">
              <circle cx="100" cy="100" fill="#8d67cf" r="78" stroke="black" stroke-width="3"/>
              <g class="eyes">
                <circle cx="61" cy="82" r="12"/>
                <circle cx="127" cy="82" r="12"/> </g>
              <path d="m136.81 116.53c.69 26.17-64.11 42-81.52-.73" style="fill:none; stroke: black; stroke-width: 3;"/>
            </svg>
      </li>
      <li>
          <div class="course3">
              <img src="3.png" alt="">
           
              <h2>SQL</h2>
              <p>Unlock the potential of SQL for streamlined data management and retrieval, enabling...</p>
          </div>
          <svg viewBox="0 0 200 200" width="25"  height="25" xmlns="http://www.w3.org/2000/svg">
              <circle cx="100" cy="100" fill="#8d67cf" r="78" stroke="black" stroke-width="3"/>
              <g class="eyes">
                <circle cx="61" cy="82" r="12"/>
                <circle cx="127" cy="82" r="12"/> </g>
              <path d="m136.81 116.53c.69 26.17-64.11 42-81.52-.73" style="fill:none; stroke: black; stroke-width: 3;"/>
            </svg>
      </li>  
      </ul>
        <button onclick="" >view all</button>
          <span class="close" onclick="closePopup()">&times;</span>
      </div>
  </div>
  
  
     <footer>
                  <div class="content">
                    <div class="top">
                      <div class="logo-details">
                        <!-- <i class="fab fa-slack"></i> -->
                      
                        <span class="logo_name">Keesite  <svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-key"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path></svg> </span>
                      </div>
                      <!-- <div class="media-icons">
                        <a href="#"><i class="fab fa-facebook-f"></i></a>
                        <a href="#"><i class="fab fa-twitter"></i></a>
                        <a href="#"><i class="fab fa-instagram"></i></a>
                        <a href="#"><i class="fab fa-linkedin-in"></i></a>
                        <a href="#"><i class="fab fa-youtube"></i></a>
                      </div> -->
                    </div>
                    <div class="link-boxes">
                      <ul class="box">
                        <li class="link_name">Accont</li>
                        <li><a href="#">Profile</a></li>
                        <li><a href="#">Todo list</a></li>
                        <li><a href="#">Roadmap</a></li>
                        <li><a href="#">feedback</a></li>
                      </ul>
                      <ul class="box">
                        <li class="link_name">100 Q/A challenge</li>
                        <li><a href="#">Python</a><a href="#"></a></li>
                        <li><a href="#"> javascript</a></li>
                        <li><a href="#"> java</a></li>
                        <li><a href="#"> sql</a></li>
                      </ul>
                      <ul class="box">
                        <li class="link_name">frontend</li>
                        <li><a href="#">HTML</a></li>
                        <li><a href="#">CSS </a></li>
                        <li><a href="#">JAVASCRIPT </a></li>
                        <!-- <li><a href="#">dsa</a></li>
                        <li><a href="#">jjjj</a></li> -->
                       
                      </ul>
                      <ul class="box">
                        <li class="link_name">courses</li>
                        <li><a href="#">DSA(java and python)</a></li>
                        <li><a href="#">github</a></li>
                        <li><a href="#">Database</a></li>
                        <li><a href="#">Machine Learning</a></li>
                      </ul>
                      <!-- <ul class="box input-box">
                        <li class="link_name">Subscribe</li>
                        <li><input type="text" placeholder="Enter your email"></li>
                        <li><input type="button" value="Subscribe"></li>
                      </ul> -->
                    </div>
                  </div>
                  <div class="bottom-details">
                    <div class="bottom_text">
                       <span class="copyright_text">copyright @ keesite 2023  </span><!-- <a href="#">CodingLab.</a>All rights reserved-->
                      <span class="policy_terms">
                        <span><svg width="24px" height="24px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-at-sign"><circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path></svg> keesitelearn@gmail.com</span>
                        <!-- <a href="#">Privacy policy</a>
                        <a href="#">Terms & condition</a> -->
                      </span>
                    </div>
                  </div>
                </footer>    
              
  
                <script>
                  // Get the button:
                  let mybutton = document.getElementById("myBtn");
                  // When the user scrolls down 20px from the top of the document, show the button
                  window.onscroll = function() {
                  scrollFunction()
                  };
                  function scrollFunction() {
                  if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
                  mybutton.style.display = "block";
                  } else {
                  mybutton.style.display = "none";
                  }
                  }
                  
                  // When the user clicks on the button, scroll to the top of the document
                  function topFunction() {
                  //   document.body.scrollTop = 0; // For Safari
                  document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
                  }
                  </script>
                  
                  
  
  
  
                  <script src="homepage.js"></script><script src=""></script>
  
      <script>
          const canvas = document.getElementById('Canvas');
          const ctx = canvas.getContext('2d');
          // ctx.clearRect(0, 0, canvas.width, canvas.height);
        
          const cubeWidth = 26;
          const cubeHeight =20;
          const cubeDepth = 20;
        
          // Set cube position
          const cubeX = (canvas.width - cubeWidth) / 2;
          const cubeY = (canvas.height - cubeHeight) / 2;
        
          
          function drawCube() {
        
            ctx.beginPath();// Front face
            ctx.moveTo(cubeX, cubeY);
            ctx.lineTo(cubeX + cubeWidth, cubeY);
            ctx.lineTo(cubeX + cubeWidth, cubeY + cubeHeight);
            ctx.lineTo(cubeX, cubeY + cubeHeight);
            ctx.closePath();
            ctx.fillStyle = '#8d8f84';
            ctx.fill();
        
        
            ctx.beginPath();//top face
            ctx.moveTo(cubeX, cubeY);
            ctx.lineTo(cubeX + cubeWidth / 2, cubeY - cubeDepth / 2);
            ctx.lineTo(cubeX + cubeWidth / 2 + cubeWidth, cubeY - cubeDepth / 2);
            ctx.lineTo(cubeX + cubeWidth, cubeY);
            ctx.closePath();
            ctx.fillStyle = 'white';
            ctx.fill();
        
           
            ctx.beginPath();//side face
            ctx.moveTo(cubeX + cubeWidth, cubeY);
            ctx.lineTo(cubeX + cubeWidth / 2 + cubeWidth, cubeY - cubeDepth / 2);
            ctx.lineTo(cubeX + cubeWidth / 2 + cubeWidth, cubeY + cubeHeight - cubeDepth / 2);
            ctx.lineTo(cubeX + cubeWidth, cubeY + cubeHeight);
            ctx.closePath();
            ctx.fillStyle = '#8d8f84';
            ctx.fill();
          }
        
          setTimeout( function() {
        
            ctx.fillStyle = '#8d67cf';
            ctx.font = '10px FontAwesome';  
            ctx.fillText("\uf084",25,9);
          },1000);
          drawCube();
        
        
        </script> 
  
  <script>
      function openForm() {
    document.getElementById("myForm").style.display = "block";
    
    }
    function closeForm() {
    document.getElementById("myForm").style.display = "none";
    }
    </script>  
  
  
  
  <script src="https://smtpjs.com/v3/smtp.js"></script>
  
  <script>
  const submit=document.getElementsByClassName('container')[0];
  
  submit.addEventListener('submit',(e)=>
  {
      e.preventDefault();
  
  // console.log(fname.value);
  // console.log(fphone.value);
  // console.log(fmessage.value);
  
  console.log("clicked");
  })
  
   function sendEmail(){
  
  const fname=document.getElementById('name');
  console.log(name);
  const femail=document.getElementById('email');
  const fphone=document.getElementById('phone');
  const fmessage=document.getElementById('message');
  
  let ebody= ` 
  <b>Name: </b>${fname.value}<br>
  <b>Email: </b>${femail.value}<br>
  <b>phone NO: </b>${fphone.value}<br>
  <b>query:</b> ${fmessage.value} `
  
              Email.send({
                  Host:"smtp.elasticemail.com",
                  Username:"keerthikaravi1405@gmail.com",
                  Password: "882FE9E23494C1F767E8347592F3DBBA1364",
                  To:'keesitelearn@gmail.com',
                  From:document.getElementById('email').value,
                  Subject:"New Contact Form Enquiry" + email.value,
                  Body: ebody
              }).then(
                  message => alert("your query send successfully")
              );
             
  
          };
      </script> 
  
  
  <script>
  
    const body = document.querySelector("body"),
          nav = document.querySelector("nav"),
          modeToggle = document.querySelector(".dark-light");
          // imageContainer = document.querySelector(".image-container");
    
          let getMode = localStorage.getItem("mode");
              if(getMode && getMode === "dark-mode"){
                body.classList.add("dark");
                modeToggle.classList.add("active");
              //   updateImage("dark");
              }
    
    
         modeToggle.addEventListener("click" , () =>{
            modeToggle.classList.toggle("active");
            body.classList.toggle("dark");
            // js code to keep user selected mode even page refresh or file reopen
  
            if(!body.classList.contains("dark")){
                localStorage.setItem("mode" , "light-mode");
              //   updateImage("light");
  
            }
            else{
                localStorage.setItem("mode" , "dark-mode");
              //   updateImage("dark");
            }
          });
  
  //         function updateImage(mode) {
    
  //     const lightImagePath = "river.gif";
  //     const darkImagePath = "night.gif";
  
   
  //     imageContainer.src = mode === "dark" ? darkImagePath : lightImagePath;
  //   }
      </script>
  
      
  <script>
    function view() {
  document.getElementById("wrapper").style.display = "block";
  
  }
  function nonview() {
  document.getElementById("wrapper").style.display = "none";
  }
  </script>  
  
  
  
  <script>
    const hamburger = document.querySelector('.hamburger-menu');
    const navMenu = document.querySelector('.nav-menu');
    
    hamburger.addEventListener('click', () => {
    navMenu.classList.toggle('hide');
    });
    
  </script>
  <script>
    var delay = 30000;
    setTimeout(function() {
        document.getElementById('recommend').style.display = 'block';
    }, delay);
  
    function closePopup() {
        document.getElementById('recommend').style.display = 'none';
    }
  </script>
  <!-- <script>
        
    document.addEventListener("scroll", function () {
      var threshold = 50;
  
      // document.getElementById("test").innerHTML = window.scrollY; //show the count
      
      var sidebar = document.getElementById("navbar");
      var content = document.getElementById("bgcontent");
  
      if (window.scrollY >= threshold) {
        sidebar.classList.add("fixed");
      } 
      else {
        sidebar.classList.remove("fixed");
      }
  
      var check = content.offsetHeight - sidebar.offsetHeight - 21;
      console.log(check);//679
  
      if (window.scrollY >= check) {
        sidebar.classList.add("bottom");
      } else {
        sidebar.classList.remove("bottom");
      }
    });
  </script> -->
  </body>
  </html>